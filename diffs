aalat.h
=====================================
1c1
<       common/aalat/alat(ifull),along(ifull)
---
>       common/aalat/alat(ifull),along(ifull),slwa(ifull),rtt(ifull,kl)
=====================================
 
arrays.h
=====================================
1c1,2
<       real t,u,v,qg,psl,ps
---
> c note zs now before psl Fri  04-19-1996
> c has qg from 4/12/00 (removed from pbl.h)
=====================================
 
betts1.h
=====================================
=====================================
 
bigxy4.h
=====================================
=====================================
 
cldcom.h
=====================================
=====================================
 
co2dta.h
=====================================
=====================================
 
comhtg.h
=====================================
=====================================
 
constant.h
=====================================
1c1,8
<       real rearth,r,g,cp,cpv
---
> * --- mathematical
> c     parameter( iZERO =  0, iONE =   1, iMONE = -1, iTWO =2 )
> c     parameter( iTHREE = 3, iSEVEN = 7 )
> c
> c     parameter( fZERO = 0.0, fONE = 1.0, fMONE = -1.0 )
> c     parameter( fHALF = 0.5, fHUNDRED = 100.0 )
> c     parameter( fPI   = 3.1415926 )
> 
=====================================
 
const_phys.h
=====================================
=====================================
 
cparams.h
=====================================
=====================================
 
darcdf.h
=====================================
=====================================
 
dates.h
=====================================
=====================================
 
dava.h
=====================================
1d0
<       real davt
=====================================
 
davb.h
=====================================
=====================================
 
establ.h
=====================================
=====================================
 
extraout.h
=====================================
=====================================
 
filnames.h
=====================================
2c2
<       common/filesin/albfile,icefile,maskfile
---
>       common/filesin/albfile,deepfudg,icefile,maskfile
12c12
<       character*80 albfile,icefile,maskfile
---
>       character*80 albfile,deepfudg,icefile,maskfile
=====================================
 
gdrag.h
=====================================
=====================================
 
hcon.h
=====================================
=====================================
 
indices.h
=====================================
2,4c2
<       common/indices/iw(ifull),isw(ifull),is(ifull),ise(ifull),
<      .               ie(ifull),ine(ifull),in(ifull),iwn(ifull),
<      .               ien(ifull),
---
>       common/indices/in(ifull),is(ifull),iw(ifull),ie(ifull),
5a4
>      .               ine(ifull),ise(ifull),ien(ifull),iwn(ifull),
=====================================
 
kdacom.h
=====================================
=====================================
 
kuocom.h
=====================================
1,9d0
<       integer kbsav,ktsav,iterconv,ksc,kscsea,kuocb,methdetr,methprec,
<      .        nclddia,ncvcloud,ncvmix,ndavconv,nevapcc,nevapls,nkuo,
<      .        nrhcrit,nstab_cld
<       real convpsav,alflnd,alfsea ,cldh_lnd,cldm_lnd,cldl_lnd,
<      .     cldh_sea,cldm_sea,cldl_sea,convfact,convtime,
<      .     detrain,detrainx,dsig2,dsig4,
<      .     epsconv,fldown,rhcv,rhmois,rhsat,sigcb,sigcll,
<      .     sigkscb,sigcll,sigkscb,sigksct,tied_con,tied_over,tied_rh
<       
=====================================
 
latlong.h
=====================================
=====================================
 
liqwpar.h
=====================================
1,2c1
<       integer ifullw
<       parameter(ifullw=1)
---
>       parameter(ilw=1,jlw=1,klw=1)
4,6c3,5
< c     parameter(ifullw=ifull)
<       real qfg,qlg
<       common/liqw/qfg(ifullw,kl),qlg(ifullw,kl)
---
> c     parameter(ilw=il,jlw=jl,klw=kl)
>       common/micro1/qc(ilw*jlw,klw),qp(ilw*jlw,klw),klmax(ilw*jlw),
>      .       vp(ilw*jlw,klw),tcldfl,tw(klw)
=====================================
 
lwout.h
=====================================
=====================================
 
map.h
=====================================
1,2d0
<       real em,emu,emv,f,fu,fv,dmdx,dmdy,dmdxv,dmdyu,zs
<       logical land
6a5
>       logical land
=====================================
 
mapproj.h
=====================================
=====================================
 
morepbl.h
=====================================
1,3c1,2
<       real condx,fg,eg,runoff,condc,rnet,pblh
<       common/morepbl/condx(ifull),fg(ifull),eg(ifull)
<      .              ,runoff(ifull),condc(ifull),rnet(ifull),pblh(ifull)
---
>       common / morepbl / condx(ifull),fg(ifull),eg(ifull)
>      .                 ,runoff(ifull),condc(ifull),rnet(ifull)       
=====================================
 
netcdf.h
=====================================
=====================================
 
newmpar.h
=====================================
=====================================
 
nlin.h
=====================================
1d0
<       real tn,un,vn
=====================================
 
nsibd.h
=====================================
=====================================
 
params.h
=====================================
=====================================
 
parmdyn.h
=====================================
11c11
< !     morder was in namelist, e.g. 24 ! set morder to 2 or 4 for nonlin
---
> !     morder in namelist, e.g. 24 ! set morder to 2 or 4 for nonlin
15,16c15,16
< !     morder_r was in namelist ! set morder_r to 2 or 4 for upglobal
< !     this gives order for nritch advection options - not used nowadays
---
> !     morder_r in namelist ! set morder_r to 2 or 4 for upglobal
> !     this gives order for nritch advection options
18,21c18,26
<       common/paramdyn/epsp,epsu,epsf,m,mex,mfix,mfix_qg,
<      .                mspec,mup,nonl,nritch,nritch_t,nrot,
<      .                nstag,nstagu,ntbar,
<      .                nvsplit,nxmap,restol
---
>       parameter(ntomg=0)    ! 0 for standard, 1 for correction in adjust5
> !                             2 for lagged in nonlin
> !                             3 tomgsav holds omgfnl; leaves tv part as before
> 
>       common/paramdyn/ntbar,morder,morder_r,epsp,epsu,epsf,
>      .                nritch,nritch_t,
>      .                nuv,nstag,nstagu,mst_bs,mstu_bs,nspec_us,nrot,
>      .                mfix_qg,nstabchk,nxmap,m,mex,mfix,mspec,mup,
>      .                nvsplit,nonl,restol,nunst
=====================================
 
parm.h
=====================================
1,12d0
<       integer meso,nps,npsav,nsd,nem,ngwd,nrungcm,newtop,nhor,nhorps,
<      .        khor,khdif,kountr,ndiur,nrad,nvmix,nlocal,
<      .        nhstest,namip,nspecial,nsib,nsoil,newsoilm,
<      .        ntsea,ntsur,ntsur2,lgwd,newztsea,nglacier,
<      .        nbd,kbotdav,nbox,nud_p,nud_q,nud_t,nud_uv,nud_hrs,
<      .        ktau,ndi,ndi2,ntau,nperday,nmaxpr,nlv,
<      .        ia,ib,ja,jb,id,jd,idjd,
<      .        io_clim,io_in,io_out,io_rest,io_spec,
<      .        nwt,kwt,nqg,nrun,nrunx,nextout,nclim,nfly
<       real qgmin,hdiff,hdifmax,rlong0,rlat0,schmidt,schm13,
<      .     aleadfr,av_vmod,vmodmin,snmin,tss_sh,ds,dt,dtin,timea
<       logical diag
18c6
<       common/parmradn/kountr,ndiur,nrad   
---
>       common/parmradn/kountr,ndiur   
22c10
<       common/parmtest/nhstest,namip,nspecial
---
>       common/parmtest/nhstest,namip
26,28c14,15
<       common/parmsfce/nsib,nsoil,newsoilm,ntsea,ntsur,ntsur2,
<      .                lgwd,newztsea,aleadfr,av_vmod,vmodmin,snmin,
<      .                tss_sh,nglacier
---
>       common/parmsfce/nsib,nsoil,newsoilm,nsiceup,ntsea,ntsur,ntsur2,
>      .                lgwd,newztsea,aleadfr,av_vmod,vmodmin,snmin,tss_sh
32,33c19,21
<       common/parmtime/ktau,ntau,nperday,ds,dt,dtin,timea,nmaxpr,    
<      .                diag,nlv,ia,ib,ja,jb,id,jd,idjd,ndi,ndi2
---
>       common/parmtime/ktau,ntau,kstart,ds,dt,dtin,timea,nmaxpr,diag,nlv,    
>      .                ia,ib,ja,jb,id,jd,idjd
>       logical diag
35,36c23,24
<       common/parmio/io_clim,io_in,io_out,io_rest,io_spec,    ! type of I/O
<      .              nwt,kwt,nqg,nrun,nrunx,nextout,nclim,nfly  
---
>       common/parmio/io_clim, io_in, io_out, io_rest, io_spec,  ! type of I/O
>      .              nwt,kwt,nqg,nrun,nrunx,nextout,nclim  
=====================================
 
parmhor.h
=====================================
2c2
<       common/parmhor/nt_adv,ndept
---
>       common/parmhor/nt_adv
4,6c4
<       
< !     for RMIP1 m_bs was -2; during 2002 it was 2
<       parameter (m_bs=-2)    !  0 for B&S off     usually -2
---
>       parameter (m_bs=2)     !  0 for B&S off     usually -2
9,14d6
< !     m_bs is superseded on 23/7/03 by mh_bs
<       parameter (mh_bs=3)    !  5 for B&S off     usually 4
< !                               4 for B&S on for gases (in ints)
< !                               3 for B&S on for T, gases 
< !                               2 for B&S on for u, v, T, gases 
< !                               1 for B&S on for psl, u, v, T, gases 
=====================================
 
parm_nqg.h
=====================================
=====================================
 
parmvert.h
=====================================
2c2
<       common/paramvrt/nvad,nvadh
---
>       common/paramvrt/nvad,nvadh,nvadq,nvadt,nqq
4,6c4,8
< !     for RMIP1 following were (1,1,2); during 2002 were (0,2,3)
<       parameter (nimp=0)  !  0 for original explicit non-flux TVD term
< !                            1 for implicit non-flux TVD term
---
> !!!!!!parameter (nqq=0)     ! 0 for simple qg;  2 for k**3 treatment
> !                             3 for qg**(1/3);  4 for qg**(1/4)
> !                             6 for [1-k/(kl+.5)]**3 treatment
> !                             7 for old nqq=3 (vadvtvd only)
> !     usually use nqq=0 or 3
9a12,13
>       parameter (nimp=0)  !  0 for original explicit non-flux TVD term
> !                            1 for implicit non-flux TVD term
15c19
< !     parameter (n_bs=0)  !  0 off            was  in vadv30in, vadvl_w
---
>       parameter (n_bs=0)  !  0 off                     in vadv30in, vadvl_w
20a25,30
>       parameter (ntop= 3) !  0 zero-gradient top & bottom, all fields
> !                            1 zero-gradient top & bottom, all fields
> !                            2 same, but topmost u,v zero
> !                            3 same, but top 1/2 level SL u,v zero
> !                            other options depend on particular nvad,nspline
> !                            only used in vadv30in, vadvl_w (not vadvtvd)
21a32,38
>       parameter (nvdep=0) !  0 for original;
> !                            1 for new average vels
> !                              only used in vadv30, vadvl_w (not vadvtvd)
>       parameter (nvint=0) !  0 simple+1/2; 1 simple;
> !                            2 for Bessel;
> !                            3 for spline
> !                            7 for Akima
=====================================
 
particle.h
=====================================
=====================================
 
pbl.h
=====================================
1c1
<       common/pbl/cduv(ifull),cdtq(ifull),tss(ifull),slwa(ifull)
---
>       common/pbl/cduv(ifull),cdtq(ifull),tss(ifull)
=====================================
 
prec.h
=====================================
1d0
<       real precip,precc,rnd03,rnd06,rnd09,rnd12,rnd15,rnd18,rnd21
3,4c2
<      .            rnd03(ifull),rnd06(ifull),rnd09(ifull),
<      .            rnd12(ifull),rnd15(ifull),rnd18(ifull),rnd21(ifull)
---
>      .            rnd6(ifull),rnd12(ifull),rnd18(ifull)
=====================================
 
qfg_qlg.h
=====================================
=====================================
 
radisw.h
=====================================
=====================================
 
rdflux.h
=====================================
=====================================
 
rdparm.h
=====================================
=====================================
 
rnddta.h
=====================================
=====================================
 
scamdim.h
=====================================
=====================================
 
screen.h
=====================================
2c2
<      .  scrrel(ifull),u10(ifull)
---
>      .  scrrel(ifull),u3(ifull),u10(ifull),tscrn3hr(ifull,8)
=====================================
 
sigs.h
=====================================
3,5d2
<       real sig,sigmh,dsig,rata,ratb,bet,tbar,tbardsig,dtmax,betm,
<      &     ratha,rathb
<      
=====================================
 
soil.h
=====================================
1,2d0
<       real zoland,zmin,zolnd,zolog,sicedep,fracice,alb,albsav,so4t
<       logical sice
5a4
>       logical sice
=====================================
 
soilsnow.h
=====================================
13d12
<      .   , sno(ifull)     ! accum. snow in mm since last write (like precip)
=====================================
 
soilv.h
=====================================
1,5c1,7
<       parameter (mxst=13)  ! max_no_of_soil_types
<       common/soilpr/swilt(0:mxst),ssat(0:mxst),sfc(0:mxst),
<      & bch(mxst),cnsd(mxst),css(mxst),hsbh(mxst),hyds(mxst),
<      & i2bp3(mxst),ibp2(mxst),rhos(mxst),sucs(mxst),
<      & clay(mxst),sand(mxst),silt(mxst),
---
>       parameter (mxst=13)
>       common/soilpr/
>      & rhos(mxst),css(mxst),cnsd(mxst),bch(mxst),ssat(mxst),
>      & swilt(mxst),hsbh(mxst),i2bp3(mxst),
>      & ibp2(mxst),sfc(mxst),sucs(mxst),hyds(mxst),silt(mxst),
>      & clay(mxst),sand(mxst),sormax(mxst),
>      & tgmax(mxst),zse(ms),
7c9
<      & froot(5),zse(ms)
---
>      & froot(5)
=====================================
 
srccom.h
=====================================
=====================================
 
stime.h
=====================================
=====================================
 
swocom.h
=====================================
=====================================
 
tabcom.h
=====================================
=====================================
 
tfcom.h
=====================================
=====================================
 
tracers.h
=====================================
1,8c1,2
<       integer iradon,ico2,iso2,iso4,ich4,io2,ngas,nllp,ntrac,ntracmax,
<      .        npwr,ilt,jlt,klt,indso2,ilso2,jlso2,ngasmax,
<      .        nsumtr,k_t,ico2em,idrydep,iwetdep,irain,nso2sour,nso2slev,
<      .        nso2lev,iso2em,jso2em,iso2emindex,iso2lev
<       real tr,sumtr,cem,alpha,beta,radonem,rain,
<      .     so2background,co2fact,condrag,so2em,so2fact
<       parameter(iradon=0,ico2=0,iso2=0,iso4=0,ich4=0,io2=0,ngas=0)
< !     parameter(iradon=1,ico2=2,iso2=0,iso4=0,ich4=0,io2=0,ngas=2)
---
>       parameter(iRADON=0,iCO2=0,iSO2=0,iSO4=0,iCH4=0,iO2=0,ngas=0)
> !     parameter(iRADON=1,iCO2=2,iSO2=0,iSO4=0,iCH4=0,iO2=0,ngas=2)
14,16c8,10
<       parameter(ntracmax=max(ntrac,1))      ! ntracmax >= 1
< !     parameter(ntracmax=ntrac)             ! set this or next line
< !     parameter(ntracmax=1)                 ! no gases & nllp=0
---
>       parameter(ngasmax=max(ngas,1), ntracmax=max(ntrac,1)) ! each >= 1
> !     parameter(ntracmax=ntrac)              ! set this or next line
> !     parameter(ntracmax=1)                  ! no gases & nllp=0
19c13
<       parameter(ilt=il**npwr,jlt=jl**npwr,klt=kl**npwr) ! gives one of next two   
---
>       parameter(ilt=il**npwr,jlt=jl**npwr,klt=kl**npwr)   ! gives one of next two   
25,26c19,21
<       common/tracer/tr(ilt*jlt,klt,ntracmax),sumtr(ilso2*jlso2,-2:klt)
<       common/c_tracer/ nsumtr,cem,k_t,alpha,beta  
---
>       common/tracer/tr(ilt*jlt,klt,ntracmax),
>      .              sumTr(ilso2*jlso2,-2:klt),wspeed(ilt*jlt)
>       common/c_tracer/ nSumTr, CEm, k_t, alpha, beta  
30c25
<       parameter ( idrydep = -2,iwetdep= -1,irain= 0)
---
>       parameter ( iDRYDEP = -2, iWETDEP= -1, iRAIN= 0)
32,36c27,32
<       parameter(nso2sour=   1,nso2slev=3)
<       common/cnsib/nso2lev,so2background,co2fact,     
<      -  condrag,iso2em(2,nso2sour),       
<      -  jso2em(nso2sour),so2em(nso2sour),           
<      -  iso2emindex(nso2sour),so2fact(nso2slev),iso2lev(0:nso2slev)   
---
>       parameter(nSO2SOUR=   1,nSO2SLEV=3)
>       common/cnsib/nSO2lev,SO2BackGround,CO2fact,     
>      -  condrag,iSO2em(2,nSO2SOUR),       
>      -  jSO2em(nSO2SOUR), SO2em(nSO2SOUR),           
>      -  iSO2emIndex(nSO2SOUR),SO2fact(nSO2SLEV),     
>      -               iSO2lev(0:nSO2SLEV)   
38,42c34,35
<       parameter(ngasmax=max(ngas,1))  ! ngasmax >= 1
< !     parameter(ngasmax=ngas)         ! ngasmax >= 1
< !     parameter(ngasmax=1)            ! ngasmax >= 1
<       real gasmin(ngasmax)            ! used by mass fixer in adjust5
<       data gasmin/ngasmax*0./         ! modify this line for specific gases          
---
>       real gasmin(ngasmax)     ! used by mass fixer in adjust5
>       data gasmin/ngasmax*0./  ! modify this line for specific gases          
=====================================
 
trcom2.h
=====================================
=====================================
 
vecs.h
=====================================
=====================================
 
vecsuva.h
=====================================
=====================================
 
vecsuv.h
=====================================
=====================================
 
vvel.h
=====================================
1d0
<       real sdot,dpsldt
=====================================
 
xarrs.h
=====================================
1d0
<       real ux,vx,tx,pslx
=====================================
 
xyzinfo.h
=====================================
=====================================
 
adjust5.f
=====================================
2c2,3
<       parameter (moistfix=2) ! 0 earlier; 1 for cube-root fix; 2 best, with ps
---
>       parameter (moist=0)    ! set moist to 0, 1 or 2  in nonlin and adjust5
>       parameter (moistfix=2) ! 0 usual; 1 for cube-root fix; 2 best, with ps
6c7
< !     nuv in parm.h:  now always 10
---
> !     nuv in parm.h:  ! x0 for simple method, x2 for fancy one
17c18
<       include 'parmdyn.h'  
---
>       include 'parmdyn.h'  ! morder,ntomg
27d27
<       common/dpsdt/dpsdt(ifull)    ! shared adjust5 & openhist
33c33
<      . wcud(ifull),wcvd(ifull),dum3(3*ijk - 6*ifull)
---
>      . wcud(ifull),wcvd(ifull),dum3(2*ijk - 6*ifull)
35c35,36
<       common/work3sav/qgsav(ifull,kl),trsav(ilt*jlt,klt,ngasmax) ! passed from nonlin
---
>       common/work3d/tomgsav(ifull,kl)
>       common/work3sav/qgsav(ifull,kl),trsav(ilt*jlt,klt,ngasmax)  ! passed from nonlin
188a190,194
>         if(ntomg.eq.3)then
>           tx(iq,k)=tx(iq,k)+((t(iq,k)-tbar2d(iq))*omgfnl(iq,k)
>      .               -tomgsav(iq,k))*hdt*roncp/sig(k) 
>           tomgsav(iq,k)=omgfnl(iq,k) ! save for next use by tomgsav in nonlin
>         endif   !  (ntomg.eq.3)
194a201,219
>       if(nstabchk.gt.0)then
> !       check for unstable layers from level ~5 up; theta in wrk1 array
>         do k=1,kl
>          do iq=1,ifull
>           wrk1(iq,k)=tx(iq,k)*sig(k)**(-r/cp)
>          enddo     ! iq loop
>         enddo      !  k loop
>         do k=nstabchk,kl
>          do iq=1,ifull
>           if(wrk1(iq,k).lt.wrk1(iq,k-1))then
>            wrk1(iq,k)=(dsig(k-1)*wrk1(iq,k-1)+dsig(k)*wrk1(iq,k))/
>      .                     (dsig(k-1)+dsig(k))      ! this is theta_bar
>            tx(iq,k)=wrk1(iq,k)/(sig(k)**(-r/cp))
>            tx(iq,k-1)=wrk1(iq,k)/(sig(k-1)**(-r/cp))
>           endif
>          enddo     ! iq loop
>         enddo      !  k loop
>       endif   ! (nstabchk.gt.0)
> 
247,255d271
<        if(diag.and.k.le.2)then   !  only for last k of loop (i.e. 1)
<         iq=idjd
<         print  *,'adjust5(k) p & n e w s ',k,p(iq,k),
<      .   p(in(iq),k),p(ie(iq),k),p(iw(iq),k),p(is(iq),k)
<         print  *,'adjust5(k) pe & n e w s ',k,pe(iq,k),
<      .   pe(in(iq),k),pe(ie(iq),k),pe(iw(iq),k),pe(is(iq),k)
<         print  *,'adjust5(k) rhsl & n e w s ',k,rhsl(iq),
<      .   rhsl(in(iq)),rhsl(ie(iq)),rhsl(iw(iq)),rhsl(is(iq))
<        endif  ! (diag.and.k.le.2)
338,339c354,594
< !      straightforward rev. cubic interp of u and v (i.e. nuv=10)
<        call unstaguv(cc,dd,u(1,k),v(1,k))  ! usual
---
> !      for globpea can broadcast increments in u & v back to unstaggered grid
>        if(nuv.ge.20)then   ! broadcast true increments back 20,21,22
>          call staguv(u(1,k),v(1,k),aa,bb)   ! from old u,v ! was ..3
>          if(diag.and.k.eq.nlv)then
>            print *,'nuv = ',nuv
>            print *,'old unstaggered u'
>            call printa('u   ',u(1,k),ktau,nlv,ia,ib,ja,jb,0.,1.)
>            print *,'old unstaggered v'
>            call printa('v   ',v(1,k),ktau,nlv,ia,ib,ja,jb,0.,1.)
>            print *,'old staggered u'
>            call printa('ust0',aa,ktau,nlv,ia,ib,ja,jb,0.,1.)
>            print *,'new staggered u'
>            call printa('usta',cc,ktau,nlv,ia,ib,ja,jb,0.,1.)
>            print *,'old staggered v'
>            call printa('vst0',bb,ktau,nlv,ia,ib,ja,jb,0.,1.)
>            print *,'new staggered v'
>            call printa('vsta',dd,ktau,nlv,ia,ib,ja,jb,0.,1.)
>          endif
>          do iq=1,ifull
>           aa(iq)=cc(iq)-aa(iq)  ! aa contains u increment
>           bb(iq)=dd(iq)-bb(iq)  ! bb contains v increment
>          enddo  ! iq loop
>        elseif(nuv.ge.10)then   ! broadcast actual values back  10,11,12
>          if(diag.and.k.eq.nlv)then
>            call staguv(u(1,k),v(1,k),aa,bb)  ! just diagnostic ! was ..3
>            print *,'nuv = ',nuv
>            print *,'old staggered u'
>            call printa('ust0',aa,ktau,nlv,ia,ib,ja,jb,0.,1.)
>            print *,'new staggered u'
>            call printa('usta',cc,ktau,nlv,ia,ib,ja,jb,0.,1.)
>            print *,'old staggered v'
>            call printa('vst0',bb,ktau,nlv,ia,ib,ja,jb,0.,1.)
>            print *,'new staggered v'
>            call printa('vsta',dd,ktau,nlv,ia,ib,ja,jb,0.,1.)
>          endif
>          do iq=1,ifull
>           aa(iq)=cc(iq)   ! contains latest staggered u
>           bb(iq)=dd(iq)   ! contains latest staggered v
>           u(iq,k)=0.
>           v(iq,k)=0.
>          enddo  ! iq loop
>        else                     ! broadcast increments back via ux  00,01,02
> !        N.B. this one has saved staggered ux & vx in u & v (in upglobal)
>          do iq=1,ifull
>           aa(iq)=cc(iq)-ux(iq,k)
>           bb(iq)=dd(iq)-vx(iq,k)
>          enddo  ! iq loop
>        endif
>        if(nuv.eq.00.or.nuv.eq.10.or.nuv.eq.20.or.nuv.eq.30)then
> !        straightforward cubic interp of u and v (or their increments)
>          call unstaguv(aa,bb,ux(1,k),vx(1,k))
>          if(nuv.eq.30)then    !  not yet checked out nys options for this
>            call unstaguv(cc,dd,aa,bb)
>            do iq=1,ifull
>             aa(iq)=aa(iq)-u(iq,k)   ! increments for simple interp
>             bb(iq)=bb(iq)-v(iq,k)
>             if(abs(aa(iq)).lt.2.*abs(ux(iq,k)))ux(iq,k)=aa(iq)
>             if(abs(bb(iq)).lt.2.*abs(vx(iq,k)))vx(iq,k)=bb(iq)
> c           ux(iq,k)=aa(iq)
> c           vx(iq,k)=bb(iq)
> c           if(abs(ux(iq,k)).gt..2*abs(u(iq,k)))ux(iq,k)=aa(iq)
> c           if(abs(vx(iq,k)).gt..2*abs(v(iq,k)))vx(iq,k)=bb(iq)
>            enddo  ! iq loop
>          endif     !  (nuv.eq.30)
>          do iq=1,ifull                         ! usual code
>           u(iq,k)=u(iq,k)+ux(iq,k)       ! usual code
>           v(iq,k)=v(iq,k)+vx(iq,k)       ! usual code
>          enddo  ! iq loop                      ! usual code
> 
>          if(nys.eq.1)then                                      !nys=1
> !          can apply Yeh & Sun filter (for nuv=00, 10, 20)     !nys=1
> !cdir nodep
>            do iq=1,ifull                                       !nys=1
>              aa(iq)=    cc(iq)-cc(iwu2(iq))                    !nys=1
>              bb(iq)=    dd(iq)-dd(isv2(iq))                    !nys=1
>            enddo   ! iq loop                                   !nys=1
> !cdir nodep
>            do iq=1,ifull                                       !nys=1
>              if(aa(iwu2(iq))*aa(ieu2(iq)).ge.0.)then           !nys=1
>                umin=min(cc(iq),cc(iwu2(iq)))                   !nys=1
>                umax=max(cc(iq),cc(iwu2(iq)))                   !nys=1
>                u(iq,k)=min( max(umin,u(iq,k)) , umax )     !nys=1
>              endif                                             !nys=1
>              if(bb(isv2(iq))*bb(inv2(iq)).ge.0.)then           !nys=1
>                vmin=min(dd(iq),dd(isv2(iq)))                   !nys=1
>                vmax=max(dd(iq),dd(isv2(iq)))                   !nys=1
>                v(iq,k)=min( max(vmin,v(iq,k)) , vmax )     !nys=1
>              endif                                             !nys=1
>            enddo   ! iq loop                                   !nys=1
>          elseif(nys.eq.2)then    ! B & S  filter
> !cdir nodep
>            do iq=1,ifull                                       !nys=2
>                umin=min(cc(iq),cc(iwu2(iq)))                   !nys=2
>                umax=max(cc(iq),cc(iwu2(iq)))                   !nys=2
>                u(iq,k)=min( max(umin,u(iq,k)) , umax )     !nys=2
>                vmin=min(dd(iq),dd(isv2(iq)))                   !nys=2
>                vmax=max(dd(iq),dd(isv2(iq)))                   !nys=2
>                v(iq,k)=min( max(vmin,v(iq,k)) , vmax )     !nys=2
>            enddo   ! iq loop                                   !nys=2
>          elseif(nys.eq.4)then    ! unstaguv code  jlm version of S & Y
> !cdir nodep
>            do iq=1,ifull
>                aa(iq)=    cc(iq)-cc(iwu2(iq))                  !nys=1
>                bb(iq)=    dd(iq)-dd(isv2(iq))                  !nys=1
>              wcu(iq)=-1.    ! just used as indicator here
>              wcv(iq)=-1.    ! just used as indicator here
>            enddo   ! iq loop
> !cdir nodep
>            do iq=1,ifull
>              if(aa(iq)*aa(ieu2(iq)).gt.0.)
>      .                    wcu(iwu2(iq))=wcu(iwu2(iq))+.7 ! extreme value allowed
>              if(aa(iwu2(iq))*aa(iq).gt.0.)
>      .                    wcu(ieu2(iq))=wcu(ieu2(iq))+.7 ! extreme value allowed
>              if(bb(iq)*bb(inv2(iq)).gt.0.)
>      .                    wcv(isv2(iq))=wcv(isv2(iq))+.7 ! extreme value allowed
>              if(bb(isv2(iq))*bb(iq).gt.0.)
>      .                    wcv(inv2(iq))=wcv(inv2(iq))+.7 ! extreme value allowed
>            enddo   ! iq loop
> !cdir nodep
>            do iq=1,ifull
>              if(wcu(iq).lt.0.)then
>                  umin=min(cc(iq),cc(iwu2(iq)))                 !nys=1
>                  umax=max(cc(iq),cc(iwu2(iq)))                 !nys=1
>                  u(iq,k)=min( max(umin,u(iq,k)) , umax )   !nys=1
>              endif
>              if(wcv(iq).lt.0.)then
>                  vmin=min(dd(iq),dd(isv2(iq)))                 !nys=1
>                  vmax=max(dd(iq),dd(isv2(iq)))                 !nys=1
>                  v(iq,k)=min( max(vmin,v(iq,k)) , vmax )   !nys=1
>              endif
>            enddo   ! iq loop
>          endif     !   (nys.eq.1)  else (nys.eq.2)
>          if(diag.and.k.eq.nlv.and.nuv.ne.10)then
>            print *,'nuv = ',nuv
>            print *,'staggered u increment'
>            call printa('du_s',aa,ktau,nlv,ia,ib,ja,jb,0.,1.)
>            print *,'unstaggered u increment'
>            call printa('du_u',ux(1,k),ktau,nlv,ia,ib,ja,jb,0.,1.)
>            print *,'staggered v increment'
>            call printa('dv_s',bb,ktau,nlv,ia,ib,ja,jb,0.,1.)
>            print *,'unstaggered v increment'
>            call printa('dv_u',vx(1,k),ktau,nlv,ia,ib,ja,jb,0.,1.)
>          endif
> 
>        elseif(nuv.eq.01.or.nuv.eq.11.or.nuv.eq.21)then
> !       linear interp via fancy cartesian projections
> !       first uc components at staggered u & v positions
>         do iq=1,ifull
>          wcu(iq)=aa(iq)*axu(iq)
>          wcv(iq)=bb(iq)*bxv(iq)
>         enddo   ! iq loop
> !cdir nodep
>         do iq=1,ifull   !  convert to unstaggered positions
>          wcincr=.5*(wcu(iq)+wcu(iwu2(iq))+wcv(iq)+wcv(isv2(iq)))
>          u(iq,k)=u(iq,k)+wcincr*ax(iq)
>          v(iq,k)=v(iq,k)+wcincr*bx(iq)
>         enddo   ! iq loop
> !       then vc components at staggered u & v positions
>         do iq=1,ifull
>          wcu(iq)=aa(iq)*ayu(iq)
>          wcv(iq)=bb(iq)*byv(iq)
>         enddo   ! iq loop
> !cdir nodep
>         do iq=1,ifull   !  convert to unstaggered positions
>          wcincr=.5*(wcu(iq)+wcu(iwu2(iq))+wcv(iq)+wcv(isv2(iq)))
>          u(iq,k)=u(iq,k)+wcincr*ay(iq)
>          v(iq,k)=v(iq,k)+wcincr*by(iq)
>         enddo   ! iq loop
> !       then wc components at staggered u & v positions
>         do iq=1,ifull
>          wcu(iq)=aa(iq)*azu(iq)
>          wcv(iq)=bb(iq)*bzv(iq)
>         enddo   ! iq loop
> !cdir nodep
>         do iq=1,ifull   !  convert to unstaggered positions
>          wcincr=.5*(wcu(iq)+wcu(iwu2(iq))+wcv(iq)+wcv(isv2(iq)))
>          u(iq,k)=u(iq,k)+wcincr*az(iq)
>          v(iq,k)=v(iq,k)+wcincr*bz(iq)
>         enddo   ! iq loop
> 
>        elseif(nuv.eq.02.or.nuv.eq.12.or.nuv.eq.22)then
> !       cubic interp via fancy cartesian projections
> !       first uc components at staggered u & v positions
>         do iq=1,ifull
>          wcu(iq)=aa(iq)*axu(iq)
>          wcv(iq)=bb(iq)*bxv(iq)
>         enddo   ! iq loop
> !cdir nodep
>         do iq=1,ifull   !  convert to unstaggered positions
>          wcua(iq)=.5*(wcu(iq)+wcu(iwu2(iq)))
>          wcud(iq)=    wcu(iq)-wcu(iwu2(iq))
>          wcva(iq)=.5*(wcv(iq)+wcv(isv2(iq)))
>          wcvd(iq)=    wcv(iq)-wcv(isv2(iq))
>         enddo   ! iq loop
> !cdir nodep
>         do iq=1,ifull
>          wcincr=wcua(iq)-(wcud(ieu2(iq))-wcud(iwu2(iq)))/16.
>      .         +wcva(iq)-(wcvd(inv2(iq))-wcvd(isv2(iq)))/16.
>          u(iq,k)=u(iq,k)+wcincr*ax(iq)
>          v(iq,k)=v(iq,k)+wcincr*bx(iq)
>         enddo   ! iq loop
> !       then vc components at staggered u & v positions
>         do iq=1,ifull
>          wcu(iq)=aa(iq)*ayu(iq)
>          wcv(iq)=bb(iq)*byv(iq)
>         enddo   ! iq loop
> !cdir nodep
>         do iq=1,ifull   !  convert to unstaggered positions
>          wcua(iq)=.5*(wcu(iq)+wcu(iwu2(iq)))
>          wcud(iq)=    wcu(iq)-wcu(iwu2(iq))
>          wcva(iq)=.5*(wcv(iq)+wcv(isv2(iq)))
>          wcvd(iq)=    wcv(iq)-wcv(isv2(iq))
>         enddo   ! iq loop
> !cdir nodep
>         do iq=1,ifull
>          wcincr=wcua(iq)-(wcud(ieu2(iq))-wcud(iwu2(iq)))/16.
>      .         +wcva(iq)-(wcvd(inv2(iq))-wcvd(isv2(iq)))/16.
>          u(iq,k)=u(iq,k)+wcincr*ay(iq)
>          v(iq,k)=v(iq,k)+wcincr*by(iq)
>         enddo   ! iq loop
> !       then wc components at staggered u & v positions
>         do iq=1,ifull
>          wcu(iq)=aa(iq)*azu(iq)
>          wcv(iq)=bb(iq)*bzv(iq)
>         enddo   ! iq loop
> !cdir nodep
>         do iq=1,ifull   !  convert to unstaggered positions
>          wcua(iq)=.5*(wcu(iq)+wcu(iwu2(iq)))
>          wcud(iq)=    wcu(iq)-wcu(iwu2(iq))
>          wcva(iq)=.5*(wcv(iq)+wcv(isv2(iq)))
>          wcvd(iq)=    wcv(iq)-wcv(isv2(iq))
>         enddo   ! iq loop
> !cdir nodep
>         do iq=1,ifull
>          wcincr=wcua(iq)-(wcud(ieu2(iq))-wcud(iwu2(iq)))/16.
>      .         +wcva(iq)-(wcvd(inv2(iq))-wcvd(isv2(iq)))/16.
>          u(iq,k)=u(iq,k)+wcincr*az(iq)
>          v(iq,k)=v(iq,k)+wcincr*bz(iq)
>         enddo   ! iq loop
>        endif    ! elseif(nuv.eq.00,01,02  10,11,12)
> 
392a648
> !       before t update to allow for moist=1,2 options
396a653,658
>         if(ntomg.eq.1)t(iq,k)=t(iq,k)+hdt*((t(iq,k)-tbar2d(iq))
>      .      *omgf(iq,k)  -tomgsav(iq,k))*roncp/sig(k) 
>         if(moist.eq.1)qg(iq,k)=qg(iq,k)*(ps(iq)*sig(k))**3
>      .                 /(1.+1.5*dt*dpsldt(iq,k)/sig(k))
>         if(moist.eq.2)qg(iq,k)=(qg(iq,k)*ps(iq)*sig(k)
>      .                /(1.+.5*dt*dpsldt(iq,k)/sig(k)))**3
403,407c665,667
<          write (6,"('sdot',9f8.3/4x,9f8.3)") (sdot(idjd,kk),kk=1,kl)
<          write (6,"('t   ',9f8.2/4x,9f8.2)") (t(idjd,kk),kk=1,kl)
<          write (6,"('u   ',9f8.2/4x,9f8.2)") (u(idjd,kk),kk=1,kl)
<          write (6,"('v   ',9f8.2/4x,9f8.2)") (v(idjd,kk),kk=1,kl)
<          write (6,"('qg  ',9f8.3/4x,9f8.3)")(1000.*qg(idjd,kk),kk=1,kl)
---
>           write (6,"('t_ad1(1-9)',9f8.2)") (t(idjd,k),k=1,9)
>           write (6,"('qg ',19f7.3/(8x,19f7.3))") 
>      .               (1000.*qg(idjd,k),k=1,kl)
409,410c669,673
<         if(nvad.eq.4)call vadvtvd(t,t,u,u,v,v)
<         if(nvad.eq.7)call vadv30(t,t,u,u,v,v)   ! for vadvbess
---
>         if(nvad.eq.3)call vadvni(t,t,u,u,v,v)
>         if(nvad.eq.4.or.nvad.ge.44)
>      .               call vadvtvd(t,t,u,u,v,v)
>         if(nvad.eq.5)call vadv30(t,t,u,u,v,v)
>         if(nvad.eq.8)call vadvl_w(t,t,u,u,v,v)
413,418c676,678
<           write (6,"('qg  ',9f8.3/4x,9f8.3)")(1000.*qg(idjd,kk),kk=1,kl)
<           write (6,"('t   ',9f8.2/4x,9f8.2)") (t(idjd,kk),kk=1,kl)
<           write (6,"('thet',9f8.2/4x,9f8.2)")  
<      .                 (t(idjd,k)*sig(k)**(-roncp),k=1,kl)
<         write (6,"('u   ',9f8.2/4x,9f8.2)") (u(idjd,kk),kk=1,kl)
<         write (6,"('v   ',9f8.2/4x,9f8.2)") (v(idjd,kk),kk=1,kl)
---
>           write (6,"('t_ad2(1-9)',9f8.2)") (t(idjd,k),k=1,9)
>           write (6,"('qg ',19f7.3/(8x,19f7.3))") 
>      .               (1000.*qg(idjd,k),k=1,kl)
457d716
<        dpsdt(iq)=(ps(iq)-aa(iq))*24.*3600./(100.*dt) ! diagnostic in hPa/day
496,497c755
<         if(mfix_qg.eq.1)alph_q = min(ratio,sqrt(ratio))  ! why min?
<         if(mfix_qg.eq.2)alph_q = sqrt(ratio)
---
>         alph_q = min(ratio,sqrt(ratio))
510c768
<         endif      ! (moistfix.eq.1)
---
>         endif      ! (moistfix.eq.2)
521c779
<       if(mfix_qg.gt.0.and.mspec.eq.1.and.ngas.ge.1)then
---
>       if(mfix_qg.gt.1.and.mspec.eq.1.and.ngas.ge.1)then
542,543c800
<          if(mfix_qg.eq.1)alph_g = min(ratio,sqrt(ratio))  ! why min?
<          if(mfix_qg.eq.2)alph_g = sqrt(ratio)
---
>          alph_g = min(ratio,sqrt(ratio))
579c836
<       endif       !  mfix_qg.gt.0
---
>       endif       !  mfix_qg.gt.1
=====================================
 
amip1data.f
=====================================
=====================================
 
amipdata.f
=====================================
=====================================
 
amipsst.f
=====================================
2c2
< !     this one primarily does namip=2      
---
> !     this one also does namip=2      
21d20
<       common/work2b/fracice_in(ifull),dum2b(ifull,2)
24,26c23,25
<       integer mdays(0:13)
<       data mdays/31, 31,28,31,30,31,30,31,31,30,31,30,31, 31/
<       save ssta,sstb,aice,bice,iyr,imo,iday,iyr_m,imo_m
---
>       integer mdays(0:13),num
>       data mdays/31, 31,28,31,30,31,30,31,31,30,31,30,31, 31/,num/0/
>       save num,ssta,sstb,aice,bice,iyr,imo,iday
41c40
<       if(ktau.eq.0)then
---
>       if(num.eq.0)then
85c84
<       endif     ! (ktau.eq.0)
---
>       endif     ! (num.eq.0)
140d138
<         fracice(iq)=0.  
144d141
<           fracice(iq)=1.  ! as used in amip1 runs
161c158
< 6     do iq=1,ifull  
---
> 6     do iq=1,ifull
163,164c160,162
<          tgg(iq,1)=rat1*ssta(iq)+rat2*sstb(iq)  ! sea water temperature
< c        alb(iq)=.11       ! set in indata/radriv90
---
>          tss(iq)=rat1*ssta(iq)+rat2*sstb(iq)
> c        tgg(iq)=tss(iq)   ! dont do this, as it is tice
> c        alb(iq)=.11         ! probably don't set; check it!
167,175c165,167
<       print *,'rat1,rat2,land,ssta,sstb,tgg1: ',
<      .           rat1,rat2,land(idjd),ssta(idjd),sstb(idjd),tgg(idjd,1)
<       fracice_in(:)=min(.01*(rat1*aice(:)+rat2*bice(:)),1.) ! convert from %
<       do iq=1,ifull
<         if(fracice_in(iq).le..02)fracice_in(iq)=0.
<       enddo
<       
<       if(ktau.eq.0)then
<         fracice(:)=fracice_in(:)
---
>       print *,'rat1,rat2,land,ssta,sstb,tss: ',
>      .         rat1,rat2,land(idjd),ssta(idjd),sstb(idjd),tss(idjd)
>       if(namip.eq.2)then  ! also interpolate sice
177,183c169,176
<          if(.not.land(iq))then
<            tss(iq)=tgg(iq,1)
< 	    if(fracice(iq).gt.0.)then
<              sice(iq)=.true.
<              sicedep(iq)=2.  ! N.B. tss, tgg3 re-set in indata
< 	    endif  ! (fracice(iq).gt.0.)
<          endif    ! (.not.land(iq))
---
>          fracice(iq)=.01*(rat1*aice(iq)+rat2*bice(iq))  ! convert from %
> 	  if(fracice(iq).gt..02)then
>            sice(iq)=.true.
>            sicedep(iq)=.5
> 	  else
>            sice(iq)=.false.
>            sicedep(iq)=0.
> 	  endif
186,188c179,180
<      .          rat1,rat2,sice(idjd),aice(idjd),bice(idjd),fracice(idjd)
<         return
<       endif       ! (ktau.eq.0)
---
>      .         rat1,rat2,sice(idjd),aice(idjd),bice(idjd),fracice(idjd)
>       endif  ! (namip.eq.2)
190,205c182,183
<       do iq=1,ifull
<        if(.not.land(iq))then
< 	  if(fracice_in(iq).gt.0.)then
< 	    if(fracice(iq).eq.0.)then
< !            create values for tice, and set averaged tss
< !            N.B. if already a sice point, keep present tice
< !            N.B. sflux will update changed sice, sicedep
<              tgg(iq,3)=min(271.2,tss(iq),t(iq,1)+.04*6.5) ! for 40 m level 1
<            endif  ! (fracice(iq).eq.0.)
< 	  endif    ! (fracice_in(iq).gt.0.)
<          fracice(iq)=fracice_in(iq)
<          tss(iq)=tgg(iq,3)*fracice(iq)+tgg(iq,1)*(1.-fracice(iq))
<        endif      ! (.not.land(iq))
<       enddo
<       print *,'rat1,rat2,sice,aice,bice,fracice: ',
<      .        rat1,rat2,sice(idjd),aice(idjd),bice(idjd),fracice(idjd)
---
>       num=1
> 	  
=====================================
 
bett_cuc.f
=====================================
=====================================
 
bettinit.f
=====================================
=====================================
 
bettrain.f
=====================================
=====================================
 
betts.f
=====================================
10a11
>       include 'comhtg.h'
15c16
<       common/work3/tnew(ifull,kl),dum3(ifull,kl,4)
---
>       common / work3 / tnew(ifull,kl),dum3(ifull,kl,3)
=====================================
 
bettspli.f
=====================================
=====================================
 
bug.f
=====================================
=====================================
 
c9tocc.f
=====================================
=====================================
 
ccmark.f
=====================================
=====================================
 
cctocc4.f
=====================================
57c57
<       common/work3f/nface(ifull),xg(ifull),yg(ifull),
---
>       common/work3b/nface(ifull),xg(ifull),yg(ifull),
63c63
<      .              uc(ifull),vc(ifull),wc(ifull),dum3b(3*ijk-22*ifull)
---
>      .              uc(ifull),vc(ifull),wc(ifull),dum3b(2*ijk-22*ifull)
65c65
<       common/work3b/rlong4(ifull,4),rlat4(ifull,4),  ! shared with setxyz
---
>       common/work3d/rlong4(ifull,4),rlat4(ifull,4),  ! shared with setxyz
67c67
<      .              dum3d(2*ijk-8*ifull-2*iquad*iquad) 
---
>      .              dum3d(ijk-8*ifull-2*iquad*iquad) 
558c558
<      .       ,dum2(3*ifull -(il+4)*(il+4)*(npanels+1) )
---
>      .       ,dum2(2*ifull -(il+4)*(il+4)*(npanels+1) )
=====================================
 
cctocc4old.f
=====================================
=====================================
 
cctocc.f
=====================================
=====================================
 
cctolcon.f
=====================================
=====================================
 
cldblk.f
=====================================
=====================================
 
cldcom.f
=====================================
1c1,4
< c $Log$
< c Revision 1.1  2003/08/13 01:24:20  dix043
< c Initial revision
< c
---
> c $Log$
> c Revision 1.1  2003/08/13 01:24:20  dix043
> c Initial revision
> c
> c Revision 1.1.1.1  2002/12/18 23:02:17  dix043
> c Source imported from farrer:~cslm/ccam
> c
=====================================
 
clddia.f
=====================================
12a13
>       include 'aalat.h'     ! for rtt
51,52c52,53
<       data clmx/.8,.6,.7/    ! HML 6,.1&.5,.3*x+.4*x**8  for nrhcrit=8  b16
< c     data clmx/.8,.6,.7/    ! HML 8,.1&.5,.3*x+.4*x**8  for nrhcrit=8  e31
---
> !     data clmx/.8,.6,.7/    ! HML 6,.1&.5,.3*x+.4*x**8  for nrhcrit=8  b16
>       data clmx/.8,.6,.7/    ! HML 8,.1&.5,.3*x+.4*x**8  for nrhcrit=8  e31
253,254c254,255
< c       print *,'rtt cooling rate (deg/day) from prev call radrive '
< c       print 91,(86400.*rtt(iq,k),k=1,kl)
---
>         print *,'rtt cooling rate (deg/day) from prev call radrive '
>         print 91,(86400.*rtt(iq,k),k=1,kl)
292c293
<       if(nrhcrit.eq.9)then   ! test power-scheme
---
>       if(nrhcrit.eq.9)then   ! power-scheme
297,298c298,299
< !        cf(nc)=max(cf(nc),.1*cld+.7*cld**24 )      ! high***  
<          cf(nc)=max(cf(nc),.05*cld+.75*cld**32 )    ! high***  
---
> c        cf(nc)=max(cf(nc),clmx(nc)*cld**20)   
>          cf(nc)=max(cf(nc),clmx(nc)*cld**8)   
306c307,308
<          cf(nc)=max(cf(nc),.1*cld+.7*cld**16 )    ! mid*** 
---
> c        cf(nc)=max(cf(nc),clmx(nc)*cld**12)  
>          cf(nc)=max(cf(nc),clmx(nc)*cld**4)   
314c316,317
<          cf(nc)=max(cf(nc),.1*cld+.7*cld**8 )   ! low*** 
---
> c        cf(nc)=max(cf(nc),clmx(nc)*cld**8)
>          cf(nc)=max(cf(nc),clmx(nc)*cld**4)   
319,345d321
< 
<       if(nrhcrit.eq.10)then   ! newer power-scheme
<         nc=1       ! high
<         cf(nc)=0.  ! cloud frac = 0.
<         do k=icld(1,nc),icld(2,nc)
<          cld=max(0.,min(.01*rhum(k),1.))
<          cf(nc)=max(cf(nc),.05*cld+.85*cld**24 )    ! high***  
<         enddo ! k=icld(1,nc),icld(2,nc)
<         ktd(nc)=icld(1,nc)   ! k value for cloud top
<         kbd(nc)=icld(2,nc)   ! k value for cloud bottom
<         nc=2       ! middle
<         cf(nc)=0.  ! cloud frac = 0.
<         do k=icld(1,nc),icld(2,nc)
<          cld=max(0.,min(.01*rhum(k),1.))
<          cf(nc)=max(cf(nc),.15*cld+.55*cld**16 )    ! mid*** 
<         enddo ! k=icld(1,nc),icld(2,nc)
<         ktd(nc)=icld(1,nc)   ! k value for cloud top
<         kbd(nc)=icld(2,nc)   ! k value for cloud bottom
<         nc=3       ! low
<         cf(nc)=0.  ! cloud frac = 0.
<         do k=icld(1,nc),icld(2,nc)
<          cld=max(0.,min(.01*rhum(k),1.))
<          cf(nc)=max(cf(nc),.3*cld+.4*cld**16 )   ! low*** 
<         enddo ! k=icld(1,nc),icld(2,nc)
<         ktd(nc)=icld(1,nc)   ! k value for cloud top
<         kbd(nc)=icld(2,nc)   ! k value for cloud bottom
<       endif   !   (nrhcrit.eq.10) 
=====================================
 
cldset.f
=====================================
=====================================
 
clo89.f
=====================================
23c23
<       parameter (ndum=5*ijk- imax*(lp1*lp1) -lp1*lp1) !jlm for 64-bit machine
---
>       parameter (ndum=4*ijk- imax*(lp1*lp1) -lp1*lp1) !jlm for 64-bit machine
=====================================
 
cloud2.f
=====================================
=====================================
 
cloud.f
=====================================
=====================================
 
co2blk.f
=====================================
1a2,4
> c Revision 1.1.1.1  2002/12/18 23:02:17  dix043
> c Source imported from farrer:~cslm/ccam
> c
=====================================
 
co2dta.f
=====================================
1c1,4
< c $Log$
< c Revision 1.1  2003/08/13 01:24:20  dix043
< c Initial revision
< c
---
> c $Log$
> c Revision 1.1  2003/08/13 01:24:20  dix043
> c Initial revision
> c
> c Revision 1.1.1.1  2002/12/18 23:02:17  dix043
> c Source imported from farrer:~cslm/ccam
> c
=====================================
 
co2.f
=====================================
3c3
<       subroutine co2sflux
---
>       subroutine CO2SFlux
12a13
>       include 'scamco2.h'   ! net CO2 flux by scam
19,20c20,21
<       parameter (ftcrit = 293.1, fco2const =3.17097e-7*1.5)
< c     parameter (ftcrit = 293.1, fco2const = 3.1536e-6)
---
>       parameter (fTCRIT = 293.1, fCO2CONST =3.17097e-7*1.5)
> c     parameter (fTCRIT = 293.1, fCO2CONST = 3.1536e-6)
24c25
<       common/work3/vmixarrs(ifull,kl,3),trsrc(ifull,kl),spare(ifull,kl)
---
>       common/work3/vmixarrs(ifull,kl,3),trsrc(ifull,kl)
27c28
< c      real rco2(ifull),                            ! co2 respiration
---
> c      real rco2(ifull),                            ! CO2 respiration
53c54
< c     ico2em(19,65)=0.  ! for no sydney emissions c20
---
> c     ico2em(19,65)=0.  ! for no Sydney emissions C20
56,57c57,58
< !      n.b. c-c model doesn't mind industrial sources over the sea
<        co2inem=ico2em(iq)*fco2const
---
> !      N.B. C-C model doesn't mind industrial sources over the sea
>        co2inem=ico2em(iq)*fCO2CONST
68c69
< !          co2inem=ico2em(iq)*fco2const*4./3.
---
> !          co2inem=ico2em(iq)*fCO2CONST*4./3.
70c71
< !          co2inem=ico2em(iq)*fco2const*2.
---
> !          co2inem=ico2em(iq)*fCO2CONST*2.
74c75
< !          co2inem=ico2em(iq)*fco2const*2./3.
---
> !          co2inem=ico2em(iq)*fCO2CONST*2./3.
84c85
<           if(t(iq,1).lt. ftcrit) coef=.05
---
>           if(t(iq,1).lt. fTCRIT) coef=.05
86c87
<      -             (1.+(t(iq,1)-ftcrit)*coef) ,0.)
---
>      -             (1.+(t(iq,1)-fTCRIT)*coef) ,0.)
88c89
<      -               (1.+(t(iq,1)-ftcrit)*coef) ,0.)
---
>      -               (1.+(t(iq,1)-fTCRIT)*coef) ,0.)
91,92c92,99
<             pnfco2=tsigmf(iq) *(rco2  -phsco2  ) +
<      .             (1.-tsigmf(iq))*(rco2bg-phsco2bg)
---
>           if(nsib.eq.2)then
>             pnfco2= 12./44.*fco2sc(iq)*1000.
> c           ! scam co2 flux kgCO2/m^2/s, pnfco2 in gC/m^2/s
> c             check magnitude !!
>           else
>             pnfco2=tsigmF(iq) *(rco2  -phsco2  ) +
>      .             (1.-tsigmF(iq))*(rco2bg-phsco2bg)
>           endif                       !  (nsib.eq.2)
96c103
<           pco2=abs(alat(iq))*4./3.     ! not used in c-c runs
---
>           pco2=abs(alat(iq))*4./3.     ! not used in C-C runs
99c106
< c           tk=5.9*wspeed(iq)-49.3
---
> c           tK=5.9*wspeed(iq)-49.3
101c108
< c           tk=2.85*wspeed(iq)-9.65
---
> c           tK=2.85*wspeed(iq)-9.65
103c110
< c           tk=.17*wspeed(iq)
---
> c           tK=.17*wspeed(iq)
105c112
< c         rco2=-2.e-9*tk*pco2
---
> c         rco2=-2.e-9*tK*pco2
131a139,144
> !     if(mod(ktau,40).eq.0)then
> !       print *,'tr(1),srcmax1,srcmin1 ',
> !    .           tr(il/2,jl/2,1,iCO2),srcmax1,srcmin1
> !       print *,'tr(2),srcmax2,srcmin2 ',
> !    .           tr(il/2,jl/2,2,iCO2),srcmax2,srcmin2
> !     endif
134c147
<       subroutine o2sflux
---
>       subroutine O2Sflux
138c151
<       common/work3/vmixarrs(il,jl,kl,3),trsrc(il,jl,kl),spare(ifull,kl)
---
>       common/work3/vmixarrs(il,jl,kl,3),trsrc(il,jl,kl)
140,142c153,155
< c --- o2 surface flux is computed in co2sflux() and returned in trsrc(i,j,2), so it must
< c       be called before the o2 routines
<       if( ico2.eq.0) then
---
> c --- O2 surface flux is computed in CO2Sflux() and returned in trsrc(i,j,2), so it must
> c       be called before the O2 routines
>       if( iCO2.eq.0) then
144,145c157,158
<      . ' o2sflux: co2 must be present for o2 calculations, fatal error'
<          stop ' ... terminating in o2sflux'
---
>      . ' O2Sflux: CO2 must be present for O2 calculations, fatal error'
>          stop ' ... terminating in O2Sflux'
150c163
<       subroutine radonsflux
---
>       subroutine RadonSFlux
165c178
<       common/work3/vmixarrs(ifull,kl,3),trsrc(ifull,kl),spare(ifull,kl)
---
>       common/work3/vmixarrs(ifull,kl,3),trsrc(ifull,kl)
169,171c182,184
<       logical firstcall
<       save    firstcall
<       data    firstcall/.true./
---
>       logical firstCall
>       save    FirstCall
>       data    firstCall/.TRUE./
193c206
<       else   ! i.e. for eva's 125 km darlam runs
---
>       else   ! i.e. for Eva's 125 km DARLAM runs
195,196c208,209
<         if( firstcall ) then
< !         for darlam iauste etc defined in indata
---
>         if( firstCall ) then
> !         for DARLAM iauste etc defined in indata
200a214
>           stop 'radonsflux not yet ready for DARLAM'
203c217
<           firstcall = .not.firstcall
---
>           firstCall = .NOT.firstCall
206,210c220,224
<         endif
<         do j=1,jl
<          do i=1,il
< 	   iq=i+(j-1)*il
<           if( land(iq) ) then
---
>        endif
>        do j=1,jl
>         do i=1,il
> 	  iq=i+(j-1)*il
>          if( land(iq) ) then
221c235
<           else
---
>          else
223,226c237,239
<           endif
<          enddo ! i=1,il
<         enddo  ! j=1,jl
<         stop 'radonsflux not yet ready for darlam'
---
>          endif
>         enddo ! i=1,il
>        enddo  ! j=1,jl
231c244
<       subroutine co2vmix(updtr, fluxfact )
---
>       Subroutine CO2vmix(updTr, fluxfact )
235,236c248,249
<       common/work3/vmixarrs(ifull,kl,3),trsrc(ifull,kl),spare(ifull,kl)
<       real updtr(ilt*jlt,klt)
---
>       common/work3/vmixarrs(ifull,kl,3),trsrc(ifull,kl)
>       real updTr(ijk)
239c252
<         updtr(iq,1)=tr(iq,1,max(1,ico2)) -
---
>         updTr(iq)=tr(iq,1,iCO2) -
243,247c256,258
<       do k=2,klt     
<        do iq=1,ilt*jlt
<         updtr(iq,k)=tr(iq,k,max(1,ico2))
<        enddo
<       enddo
---
>       do iq=ifull+1,ijk
>         updTr(iq)=tr(iq,1,iCO2)
>       end do
251c262
<       subroutine radonvmix(updtr, fluxfact )
---
>       Subroutine RadonVMix(updTr, fluxfact )
257,260c268,271
<       common/work3/vmixarrs(ifull,kl,3),trsrc(ifull,kl),spare(ifull,kl)
<       real updtr(ilt*jlt,klt)
<       parameter ( fhalflife_ra = 60.*60.*24.*3.8, flog2 = 0.693147 )
<       parameter ( flife_ra = fhalflife_ra/flog2 )
---
>       common/work3/vmixarrs(ifull,kl,3),trsrc(ifull,kl)
>       real updTr(ilt*jlt,kl)
>       Parameter ( fHALFLIFE_Ra = 60.*60.*24.*3.8, fLOG2 = 0.693147 )
>       Parameter ( fLIFE_Ra = fHALFLIFE_Ra/fLOG2 )
262c273
<       decay=exp(-dt/flife_ra)
---
>       decay=exp(-dt/fLIFE_Ra)
264c275
<         updtr(iq,1)=tr(iq,1,max(1,iradon))*decay -
---
>         updTr(iq,1)=tr(iq,1,iRADON)*decay -
268c279
<       do k=2,klt     
---
>       do k=2,kl     
270c281
<         updtr(iq,k)=tr(iq,k,max(1,iradon))*decay            ! wed  01-04-1995
---
>         updTr(iq,k)=tr(iq,1,iRADON)*decay            ! Wed  01-04-1995
276c287
<       subroutine o2vmix(updtr, fluxfact )
---
>       Subroutine O2vmix(updTr, fluxfact )
280,281c291,292
<       common/work3/vmixarrs(ifull,kl,3),trsrc(ifull,kl),spare(ifull,kl)
<       real updtr(ilt*jlt,klt)
---
>       common/work3/vmixarrs(ifull,kl,3),trsrc(ifull,kl)
>       real updTr(ilt*jlt,kl)
283c294
<         updtr(iq,1)=tr(iq,1,max(1,io2)) -
---
>         updTr(iq,1)=tr(iq,1,iO2) -
286c297
<       do k=2,klt     
---
>       do k=2,kl     
288c299
<         updtr(iq,k)=tr(iq,k,max(1,io2))
---
>         updTr(iq,k)=tr(iq,1,iO2)
=====================================
 
co2_read.f
=====================================
=====================================
 
co2trn.f
=====================================
1a2,4
> c Revision 1.1.1.1  2002/12/18 23:02:17  dix043
> c Source imported from farrer:~cslm/ccam
> c
=====================================
 
conjob.f
=====================================
17a18
>       include 'comhtg.h'   ! for compare3 or heating diagnostics
35d35
<      .  ,spare(ifull,kl)
119a120,123
>           if(ncomp.eq.1)then
>             dtl(iq,k)=dtl(iq,k)+hlcp*dqrx
>             dql(iq,k)=dql(iq,k)-dqrx
>           endif ! (ncomp.eq.1)
151a156,159
>             if(ncomp.eq.1)then
>               dtl(iq,k)=dtl(iq,k)-revq*hlcp
>               dql(iq,k)=dql(iq,k)+revq
>             endif ! (ncomp.eq.1)
168a177,180
>             if(ncomp.eq.1)then
>               dtl(iq,k)=dtl(iq,k)-revq*hlcp
>               dql(iq,k)=dql(iq,k)+revq
>             endif ! (ncomp.eq.1)
193a206,209
>             if(ncomp.eq.1)then
>               dtl(iq,k)=dtl(iq,k)-revq*hlcp
>               dql(iq,k)=dql(iq,k)+revq
>             endif ! (ncomp.eq.1)
222a239,242
>             if(ncomp.eq.1)then
>               dtl(iq,k)=dtl(iq,k)-revq*hlcp
>               dql(iq,k)=dql(iq,k)+revq
>             endif ! (ncomp.eq.1)
268a289,292
>             if(ncomp.eq.1)then
>               dtl(iq,k)=dtl(iq,k)-revq*hlcp
>               dql(iq,k)=dql(iq,k)+revq
>             endif ! (ncomp.eq.1)
612a637,640
>           if(ncomp.eq.1)then
>              dtc(iq,k)=dtc(iq,k)+dsh(iq,k)
>              dqc(iq,k)=dqc(iq,k)-dq(iq,k)
>           endif ! (ncomp.eq.1)
670a699,702
>             if(ncomp.eq.1)then
>               dtc(iq,k)=dtc(iq,k)-revq*hlcp
>               dqc(iq,k)=dqc(iq,k)+revq
>             endif ! (ncomp.eq.1)
687a720,723
>             if(ncomp.eq.1)then
>               dtc(iq,k)=dtc(iq,k)-revq*hlcp
>               dqc(iq,k)=dqc(iq,k)+revq
>             endif ! (ncomp.eq.1)
704a741,744
>             if(ncomp.eq.1)then
>               dtc(iq,k)=dtc(iq,k)-revq*hlcp
>               dqc(iq,k)=dqc(iq,k)+revq
>             endif ! (ncomp.eq.1)
726a767,770
>             if(ncomp.eq.1)then
>               dtc(iq,k)=dtc(iq,k)-revq*hlcp
>               dqc(iq,k)=dqc(iq,k)+revq
>             endif ! (ncomp.eq.1)
731a776,779
>             if(ncomp.eq.1)then
>               dtc(iq,k)=dtc(iq,k)-revq*hlcp
>               dqc(iq,k)=dqc(iq,k)+revq
>             endif ! (ncomp.eq.1)
754,757c802,803
< 	  do k=1,klt
< 	   do iq=1,ilt*jlt
<            ss(iq,k)=tr(iq,k,ntr)
<           enddo
---
>          do kq=1,ijk
>           ss(kq,1)=tr(kq,1,ntr)
759c805
<          do iq=1,ilt*jlt
---
>          do iq=1,ifull
851c897,899
<         qg(:,:)=qq(:,:)
---
>         do kq=1,ijk
>          qg(kq,1)=qq(kq,1)
>         enddo   !  kq loop
863c911,913
<            tx(:,:)=tx(:,:)+tt(:,:)-t(:,:)
---
>            do kq=1,ijk
>             tx(kq,1)=tx(kq,1)+tt(kq,1)-t(kq,1)
>            enddo   !  kq loop
865c915,917
<            tn(:,:)=tn(:,:)+(tt(:,:)-t(:,:))/dt
---
>            do kq=1,ijk
>             tn(kq,1)=tn(kq,1)+(tt(kq,1)-t(kq,1))/dt
>            enddo   !  kq loop
=====================================
 
convjlm.f
=====================================
1c1,2
<       subroutine convjlm      ! jlm convective scheme - Version v3
---
>       subroutine convjlm      ! jlm convective scheme - Version 2b
> !     with nkuo<0 does large-scale first
13c14
<       parameter (nalfs=0)      ! 1: was usual, 0: off
---
>       parameter (nalfs=0)      ! 1: usual, 0: off, -1: for omgf effect
23c24,25
< c     nevapls:  turn off/on ls evap - through parm.h; 0 off, 5 newer UK
---
> c     nevapls, nevapcc:  turn off/on evap of ls or cc --- now through parm.h
> c        0 off, 1 for Hal's evap, 2 for jlm, 3 for UK (ls only), 4 & 5 newer UK
27,30c29,31
<       include 'dava.h'     ! davt
<       include 'kuocom.h'   ! kbsav,ktsav,convfact,convpsav,ndavconv
<       include 'liqwpar.h'  ! ifullw
<       include 'map.h'      ! land
---
>       include 'dava.h'    ! davt
>       include 'kuocom.h'  ! kbsav,ktsav,convfact,convpsav,ndavconv
>       include 'map.h'     ! land
41c42
<      .  ,fluxb(ifull),kbsav_b(ifull),kbsav_ls(ifull)
---
>      .  ,fluxb(ifull),fluxt(ifull),kbsav_b(ifull),sumd(ifull)
43,46c44,46
<      .  ,sumss(ifull),factdav(ifull),qbase(ifull),fldow(ifull)
<      .  ,qxcess(ifull),fluxq(ifull),dum2(ifull,2)
<       common/work2b/sbase(ifull),alfqarr(ifull),alfsarr(ifull)
<       common/work2c/rnrtcn(ifull),kb_sav(ifull),kt_sav(ifull)
---
>      .  ,sumss(ifull),factdav(ifull),kbsav_ls(ifull)
>      .  ,qbase(ifull),fldow(ifull),qxcess(ifull),fluxq(ifull)
>       real sbase(ifull),alfqarr(ifull),alfsarr(ifull)
48c48
<      .  ,dqsdt(ifull,kl),es(ifull,kl)  ! es array mainly for diag prints
---
>      .  ,dqsdt(ifull,kl)
50,51c50,52
<       common/work3d/fluxt(ifull,kl)   ! 3d for diags
<       common/work3f/delq(ifull,kl),dels(ifull,kl),qliqw(ifull,kl)
---
>       common/work3c/rnrt3(ifull,kl)
>       common/work3d/qliqw(ifull,kl)
>       common/work3f/delq(ifull,kl),dels(ifull,kl),rnrt3d(ifull,kl)
75c76
<         if(nalfs.eq.0)alfss(k)=1.  ! for no alf effect
---
> 	if(nalfs.eq.0)alfss(k)=1.  ! for no alf effect
102,111c103,112
<       qliqw(:,:)=0.  
<       conrev(:)=1000.*ps(:)/(grav*dt) ! factor to convert precip to g/m2/s
<       rnrt(:)=0.       ! initialize large-scale rainfall array
<       rnrtc(:)=0.      ! initialize convective  rainfall array
<       ktmax(:)=kl      ! preset 1 level above current topmost-permitted ktsav
<       kbsav_ls(:)=0    ! for L/S
< 
<       tt(:,:)=t(:,:)       
<       qq(:,:)=qg(:,:)      
<       factr=dt/max(dt,convtime*3600.)  ! to re-scale convpsav
---
>       qliqw=0.  ! 3D   next ones are 2D
>       conrev=1000.*ps/(grav*dt) ! factor to conv. precip to g/m2/s
>       rnrt=0.     ! initialize large-scale rainfall array
>       ktmax=kl      ! preset 1 level above current topmost-permitted ktsav
>       kbsav_ls=0    ! for L/S
> 
>       tt=t       !3D
>       qq=qg      !3D
>       rnrt3d=0.  !3D initialize vertically accum. 3d convective rainfall 
>       if(nkuo.lt.0)go to 5
114c115,116
<       do itn=1,iterconv
---
> 
> 2     do itn=1,iterconv
116,124c118,125
<       kb_sav(:)=kl     ! preset value for no convection
<       kbsav_b(:)=kl    ! preset value for no convection
<       kt_sav(:)=kl     ! preset value for no convection
<       rnrtcn(:)=0.     ! initialize convective rainfall array (pre convpsav)
<       convpsav(:)=0.
<       dels(:,:)=1.e-20
<       delq(:,:)=0.
<       phi(:,1)=bet(1)*tt(:,1)
<  
---
>       do iq=1,ifull
>        kbsav(iq)=kl     ! preset value for no convection
>        kbsav_b(iq)=kl   ! preset value for no convection
>        ktsav(iq)=kl     ! preset value for no convection
>        convpsav(iq)=0.
>        phi(iq,1)=bet(1)*tt(iq,1)
>       enddo     ! iq loop
> 
132,145c133,145
<        do iq=1,ifull
<         es(iq,k)=establ(tt(iq,k))
<        enddo  ! iq loop
<       enddo   ! k loop
<       do k=1,kl   
<        do iq=1,ifull
<         pk=ps(iq)*sig(k)
<         qs(iq,k)=max(.622*es(iq,k)/(pk-es(iq,k)),1.5e-6)  
<         dqsdt(iq,k)=qs(iq,k)*pk*hlars/(tt(iq,k)**2*(pk-es(iq,k)))
<         s(iq,k)=cp*tt(iq,k)+phi(iq,k)  ! dry static energy
< c       calculate hs
<         hs(iq,k)=s(iq,k)+hl*qs(iq,k)   ! saturated moist static energy
<        enddo  ! iq loop
<       enddo   ! k loop
---
>          do iq=1,ifull
>           dels(iq,k)=0.
>           delq(iq,k)=0.
>           rnrt3(iq,k)=0.  ! initialize iter. 3d convective rainfall array
>           es=establ(tt(iq,k))
>           pk=ps(iq)*sig(k)
>           qs(iq,k)=max(.622*es/(pk-es),1.5e-6)  
>           dqsdt(iq,k)=qs(iq,k)*pk*hlars/(tt(iq,k)**2*(pk-es))
>           s(iq,k)=cp*tt(iq,k)+phi(iq,k)  ! dry static energy
> c         calculate hs
>           hs(iq,k)=s(iq,k)+hl*qs(iq,k) ! saturated moist static energy
>          enddo  ! iq loop
>       enddo     ! k loop
172,173c172,173
<         do k=1,kl
<          iq=idjd
---
> 	 do k=1,kl
> 	  iq=idjd
175,181c175,182
<          if(land(iq))then
<            qbass(k)=alfqq_l(k)*qq(iq,k)+alfqq1_l(k)*qq(iq,1) 
<          else
<            qbass(k)=alfqq_s(k)*qq(iq,k)+alfqq1_s(k)*qq(iq,1) 
<          endif
< 	  qbass(k)=min(qbass(k),max(qq(iq,k),qs(iq,k)))  ! added 3/6/03
<         enddo
---
> 	  if(land(iq))then
> c*	    qbass(k)=alfqq_l(k)*qq(iq,k)+(1.-alfqq_l(k))*qq(iq,1) 
> 	    qbass(k)=alfqq_l(k)*qq(iq,k)+alfqq1_l(k)*qq(iq,1) 
> 	  else
> c*	    qbass(k)=alfqq_s(k)*qq(iq,k)+(1.-alfqq_s(k))*qq(iq,1) 
> 	    qbass(k)=alfqq_s(k)*qq(iq,k)+alfqq1_s(k)*qq(iq,1) 
> 	  endif
> 	 enddo
194,195d194
<         print *,'es ',(es(idjd,k),k=1,kl)
<         print *,'dqsdt ',(dqsdt(idjd,k),k=1,kl)
198,199d196
<       sbase(:)=0.
<       qbase(:)=0.
201,236c198,231
<        do iq=1,ifull
< !       find tentative cloud base, and bottom of below-cloud layer
<         if(qq(iq,k-1).gt.rhcv*qs(iq,k-1))then
< !         next line ensures sub-cloud layer moist and contiguous 
<           if(kbsav_b(iq).eq.k.and.sig(kb_sav(iq)).gt..8)kbsav_b(iq)=k-1 
< !         if(kbsav_b(iq).eq.k)kbsav_b(iq)=k-1 
<           if(land(iq))then
<             qbas=alfqq_l(k-1)*qq(iq,k-1)+alfqq1_l(k-1)*qq(iq,1) 
<             alfq=alfqq_l(k-1)   
<           else
<             qbas=alfqq_s(k-1)*qq(iq,k-1)+alfqq1_s(k-1)*qq(iq,1) 
<             alfq=alfqq_s(k-1)   
<           endif  ! (land(iq)) .. else ..
< 	   qbas=min(qbas,max(qs(iq,k-1),qq(iq,k-1)))    ! added 3/6/03
<           alfs=alfss(k-1)  ! simple one
<           sbas=alfs*s(iq,k-1)+(1.-alfs)*s(iq,1) ! e.g. alfs=1.
< !         now choose base layer to also have local max of qbase      
<           if(sbas+hl*qbas.gt.max(hs(iq,k),sbase(iq)+hl*qbase(iq)))then
<             if(qbas.gt.max(qs(iq,k),qq(iq,k)))then  ! newer qbas test 
<               kb_sav(iq)=k-1
<                 qbase(iq)=qbas
<                 sbase(iq)=sbas
<               kbsav_b(iq)=k-1
<               kt_sav(iq)=k
<               alfqarr(iq)=alfq    ! for use in flux calc
<               alfsarr(iq)=alfs    ! for use in flux calc
<             endif ! (qbas.gt.max(qs(iq,k),qq(iq,k)))
<           endif   ! (sbas+hl*qbas.gt.hs(iq,k))
< c           if(ntest.eq.1.and.iq.eq.idjd)then   ! needs sopt
< c             print *,'k,(sbas+hl*qbas)/cp,hs(iq,k)/cp ',
< c     .          k,(sbas+hl*qbas)/cp,hs(iq,k)/cp
< c             print *,'kbsav,qbas,qs(.,k),qq(.,k) ',
< c     .          kb_sav(iq),qbas,qs(iq,k),qq(iq,k)
< c           endif ! (ntest.eq.1.and.iq.eq.idjd)
<         endif   ! (qq(iq,k-1).gt.rhcv*qs(iq,k-1))
<        enddo    ! iq loop
---
>          do iq=1,ifull
> c         find tentative cloud base, and bottom of below-cloud layer
>           if(qq(iq,k-1).gt.rhcv*qs(iq,k-1))then
> !           next line ensures sub-cloud layer moist and contiguous 
>             if(kbsav_b(iq).eq.k.and.sig(kbsav(iq)).gt..8)kbsav_b(iq)=k-1 
> 	     if(land(iq))then
> 		qbas=alfqq_l(k-1)*qq(iq,k-1)+alfqq1_l(k-1)*qq(iq,1) 
>               alfq=alfqq_l(k-1)   
>             else
> 		qbas=alfqq_s(k-1)*qq(iq,k-1)+alfqq1_s(k-1)*qq(iq,1) 
>               alfq=alfqq_s(k-1)   
> 	     endif
> 	     alfs=alfss(k-1)  ! simple one
> !           following  gives alfs=1. for omgf +ve	     
>             sbas=alfs*s(iq,k-1)+(1.-alfs)*s(iq,1) ! e.g. alfs=1.
>             if(sbas+hl*qbas.gt.hs(iq,k))then 
>               if(qbas.gt.max(qs(iq,k),qq(iq,k)))then  ! newer test 
>                 kbsav(iq)=k-1
> 	         qbase(iq)=qbas
> 	         sbase(iq)=sbas
>                 kbsav_b(iq)=k-1
>                 ktsav(iq)=k
>                 alfqarr(iq)=alfq    ! for use in flux calc
>                 alfsarr(iq)=alfs    ! for use in flux calc
>               endif
>             endif
> c	     if(ntest.eq.1.and.iq.eq.idjd)then   ! needs sopt
> c	       print *,'k,(sbas+hl*qbas)/cp,hs(iq,k)/cp ',
> c     .	         k,(sbas+hl*qbas)/cp,hs(iq,k)/cp
> c		print *,'kbsav,qbas,qs(.,k),qq(.,k) ',
> c     .	         kbsav(iq),qbas,qs(iq,k),qq(iq,k)
> c	     endif
>           endif
>          enddo  ! iq loop
241c236
<         if(kt_sav(iq).eq.k-1.and.k.lt.ktmax(iq))then ! ktmax allows for itn
---
>         if(ktsav(iq).eq.k-1.and.k.lt.ktmax(iq))then ! ktmax allows for itn
243c238
<           if(hbase.gt.hs(iq,k))kt_sav(iq)=k
---
>           if(hbase.gt.hs(iq,k))ktsav(iq)=k
249,259d243
< !       present scheme does not properly handle 1- or 2-layer clouds
<         do iq=1,ifull
<          if(kt_sav(iq)-kb_sav(iq).le.no2layer)then
<             kb_sav(iq)=kl
<          endif
<         enddo  ! iq loop
<       endif
< 
<       if(no2layer.lt.0)then
< !       present scheme does not properly handle 1- or 2-layer clouds,
< !       so leave them to shallow convection scheme
261,263c245,246
<          if(sig(kt_sav(iq)).gt.sigksct)then
< c        if(sig(kt_sav(iq)).gt..8)then
<             kb_sav(iq)=kl
---
>          if(ktsav(iq).eq.kbsav(iq)+1)then
>             ktsav(iq)=kl
265c248
<         enddo  ! iq loop
---
>         enddo
271,273c254,256
<        kdown=min(kl,kb_sav(iq)+nint(.6+.75*(kt_sav(iq)-kb_sav(iq))))
<        print *,"ktau,itn,kbsav_b,kbsav,ktsav,kdown ",
<      .    ktau,itn,kbsav_b(idjd),kb_sav(idjd),kt_sav(idjd),kdown
---
>        kdown=min(kl,kbsav(iq)+nint(.6+.75*(ktsav(iq)-kbsav(iq))))
>        print *,"ktau,kbsav_b,kbsav,ktsav,kdown ",
>      .    ktau,kbsav_b(idjd),kbsav(idjd),ktsav(idjd),kdown
276d258
< !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
283,287c265,269
<        qsk=max(qs(iq,kt_sav(iq)),qq(iq,kt_sav(iq)))  
<        qprec=max(0.,qbase(iq)-qsk)             
<        dels(iq,kt_sav(iq))=dels(iq,kt_sav(iq))+hl*qprec        ! precip. heating
<        dels(iq,kt_sav(iq))=dels(iq,kt_sav(iq))+sbase(iq)   ! s flux
<        delq(iq,kt_sav(iq))=delq(iq,kt_sav(iq))+qsk  
---
>        qsk=max(qs(iq,ktsav(iq)),qq(iq,ktsav(iq)))  
>        qprec=max(0.,qbase(iq)-qsk)               ! tempry for Himalaya problem
>        dels(iq,ktsav(iq))=dels(iq,ktsav(iq))+hl*qprec        ! precip. heating
>        dels(iq,ktsav(iq))=dels(iq,ktsav(iq))+sbase(iq)       ! s flux
>        delq(iq,ktsav(iq))=delq(iq,ktsav(iq))+qsk         ! moistening done later
289c271
<        kdown=min(kl , kb_sav(iq)+nint(.6+.75*(kt_sav(iq)-kb_sav(iq))))
---
>        kdown=min(kl , kbsav(iq)+nint(.6+.75*(ktsav(iq)-kbsav(iq))))
291,292c273,274
<        tdown=t(iq,kb_sav(iq))+(s(iq,kdown)-s(iq,kb_sav(iq))
<      .      +hl*(qsk-qs(iq,kb_sav(iq))))/(cp+hl*dqsdt(iq,kb_sav(iq)))
---
>        tdown=t(iq,kbsav(iq))+(s(iq,kdown)-s(iq,kbsav(iq))
>      .      +hl*(qsk-qs(iq,kbsav(iq))))/(cp+hl*dqsdt(iq,kbsav(iq)))
294,297c276,279
< c      qdown=min( qq(iq,kb_sav(iq)) , qs(iq,kb_sav(iq))+
< c    .           (tdown-t(iq,kb_sav(iq)))*dqsdt(iq,kb_sav(iq)) )
<        qdown= qs(iq,kb_sav(iq))+
<      .           (tdown-t(iq,kb_sav(iq)))*dqsdt(iq,kb_sav(iq)) 
---
> c      qdown=min( qq(iq,kbsav(iq)) , qs(iq,kbsav(iq))+
> c    .           (tdown-t(iq,kbsav(iq)))*dqsdt(iq,kbsav(iq)) )
>        qdown= qs(iq,kbsav(iq))+
>      .           (tdown-t(iq,kbsav(iq)))*dqsdt(iq,kbsav(iq)) 
299,302c281,285
<        fldownn=fldown*(sig(kb_sav(iq))-sig(kt_sav(iq))) ! fldown=.66 say        
<        totprec=qprec-fldownn*dprec 
<        fldow(iq)=(.5+sign(.5,totprec))*fldownn ! suppr. downdraft for totprec<0
<        rnrtcn(iq)=qprec-fldow(iq)*dprec        ! already has dsk factor
---
> !      fldownn=fldown   ! up till 27/11/01 fldown=.2 say	
>        fldownn=fldown*(sig(kbsav(iq))-sig(ktsav(iq))) ! fldown=.66 say	
> 	totprec=qprec-fldownn*dprec 
> 	fldow(iq)=(.5+sign(.5,totprec))*fldownn ! suppr. downdraft for totprec<0
>        rnrtc(iq)=qprec-fldow(iq)*dprec         ! already has dsk factor
304,306c287,291
<          print *,'kdown,tdown,qdown ',kdown,tdown,qdown
<          print *,'qsk,qprec,dels0 ',qsk,qprec,hl*qprec 
<          print *,'fldow,dprec,rnrtcn ',fldow(iq),dprec,rnrtcn(iq)
---
>         print *,'kdown,tdown,qdown ',
>      .           kdown,tdown,qdown
>         print *,'qsk,qprec,dels0 ',qsk,qprec,hl*qprec 
>         print *,'fldow,dprec,rnrtc ',
>      .           fldow(iq),dprec,rnrtc(iq)
312,317c297,302
<        delq(iq,kb_sav(iq))=delq(iq,kb_sav(iq))+fldow(iq)*qdown
<        dels(iq,kb_sav(iq))=dels(iq,kb_sav(iq))+fldow(iq)*
<      .        (s(iq,kb_sav(iq))+cp*(tdown-t(iq,kb_sav(iq))))
< !      add contrib to cloud base layer (unit flux this one)
<        delq(iq,kb_sav(iq))=delq(iq,kb_sav(iq))-qbase(iq)
<        dels(iq,kb_sav(iq))=dels(iq,kb_sav(iq))-sbase(iq)
---
>        delq(iq,kbsav(iq))=delq(iq,kbsav(iq))+fldow(iq)*qdown
>        dels(iq,kbsav(iq))=dels(iq,kbsav(iq))+fldow(iq)*
>      .        (s(iq,kbsav(iq))+cp*(tdown-t(iq,kbsav(iq))))
> !      add contrib to cloud base layer
>        delq(iq,kbsav(iq))=delq(iq,kbsav(iq))-qbase(iq)
>        dels(iq,kbsav(iq))=dels(iq,kbsav(iq))-sbase(iq)
319,342d303
<       if(ntest.ne.0.or.diag)then
<        print *,"delsa ",(dels(idjd,k),k=1,kt_sav(idjd))
<        print *,"delqa ",(delq(idjd,k),k=1,kt_sav(idjd))
<       endif
< 
< !     subsidence and (possible) "shallow" detrainment
<       do k=kuocb+1,kl-1
<        do iq=1,ifull
<         if(k.gt.kb_sav(iq).and.k.le.kt_sav(iq))then
< c         savg=.5*(s(iq,k)+s(iq,k-1))
< c         qavg=.5*(qq(iq,k)+qq(iq,k-1))   
<           savg=s(iq,k)   ! 23/5/03
<           qavg=qq(iq,k)  ! 23/5/03 to avoid giving -ve qg for the layer
<           dels(iq,k)=dels(iq,k)-savg             ! subsidence 
<           dels(iq,k-1)=dels(iq,k-1)+savg         ! subsidence into lower layer
<           delq(iq,k)=delq(iq,k)-qavg             ! subsidence 
<           delq(iq,k-1)=delq(iq,k-1)+qavg         ! subsidence into lower layer
<         endif  ! (k.gt.kb_sav(iq).and.k.le.kt_sav(iq))
<        enddo   ! iq loop
<       enddo    ! k loop
<       if(ntest.ne.0.or.diag)then
<        print *,"delsb ",(dels(idjd,k),k=1,kt_sav(idjd))
<        print *,"delqb ",(delq(idjd,k),k=1,kt_sav(idjd))
<       endif
344c305
< !     modify calculated subsidence for downdraft effects
---
> c     do k=kl-1,kuocb+1,-1
347,356c308,328
<         kdown=min(kl , kb_sav(iq)+nint(.6+.75*(kt_sav(iq)-kb_sav(iq))))
<         if(k.le.kdown.and.k.gt.kb_sav(iq))then
< c        savgb=.5*(s(iq,k)+s(iq,k-1))       
< c        qavgb=.5*(qq(iq,k)+qq(iq,k-1))   
<          savgb=s(iq,k)   ! 23/5/03
<          qavgb=qq(iq,k)  ! 23/5/03
<          dels(iq,k)=dels(iq,k)+fldow(iq)*savgb     ! anti-subsidence 
<          dels(iq,k-1)=dels(iq,k-1)-fldow(iq)*savgb ! anti-subsidence into l-l
<          delq(iq,k)=delq(iq,k)+fldow(iq)*qavgb     ! anti-subsidence 
<          delq(iq,k-1)=delq(iq,k-1)-fldow(iq)*qavgb ! anti-subsidence into l-l
---
>         kdown=min(kl , kbsav(iq)+nint(.6+.75*(ktsav(iq)-kbsav(iq))))
>         if(k.ge.kdown+1.and.k.le.ktsav(iq))then
>          savg=.5*(s(iq,k)+s(iq,k-1))
>          qavg=.5*(qq(iq,k)+qq(iq,k-1))   
>          dels(iq,k)=dels(iq,k)-savg      ! subsidence 
>          dels(iq,k-1)=dels(iq,k-1)+savg  ! subsidence into lower layer
>          delq(iq,k)=delq(iq,k)-qavg      ! subsidence 
>          delq(iq,k-1)=delq(iq,k-1)+qavg  ! subsidence into lower layer
>          if(ntest.eq.1.and.iq.eq.idjd)then
>            print *,'in top loop; savg,qavg ',savg,qavg
>          endif
>         endif  ! (k.ge.kdown+1.and.k.le.ktsav(iq))
> 	 
>         flm=1.-fldow(iq)
>         if(k.le.kdown.and.k.gt.kbsav(iq))then
>          savgb=.5*(s(iq,k)+s(iq,k-1))       
>          qavgb=.5*(qq(iq,k)+qq(iq,k-1))   
>          dels(iq,k)=dels(iq,k)-flm*savgb       ! subsidence 
>          dels(iq,k-1)=dels(iq,k-1)+flm*savgb   ! subsidence into lower layer
>          delq(iq,k)=delq(iq,k)-flm*qavgb       ! subsidence 
>          delq(iq,k-1)=delq(iq,k-1)+flm*qavgb   ! subsidence into lower layer
358,420c330,332
<        enddo   ! iq loop
<       enddo    ! k loop
<       if(ntest.ne.0.or.diag)then
<        print *,"delsc ",(dels(idjd,k),k=1,kt_sav(idjd))
<        print *,"delqc ",(delq(idjd,k),k=1,kt_sav(idjd))
<       endif
< 
< !!!!!!!!! "shallow" detrainment using detrainx, dsig2, dsig4 !!!!!v3!!!!!! 
<       if(detrainx.gt.0.)then   
<        do iq=1,ifull  
<         detr=min(detrainx,max( 0.,
<      .  (dsig4-sig(kb_sav(iq))+sig(kt_sav(iq)))*detrainx/(dsig4-dsig2)))
<         qxcess(iq)=detr*rnrtcn(iq)              ! e.g. .2* gives 20% detrainment
<         rnrtcn(iq)=rnrtcn(iq)-qxcess(iq)
<        enddo   ! iq loop
<      
< !      N.B. pre convpsav & dsk
<        if(methdetr.eq.1)then                    ! moisten top layer only 
<          do iq=1,ifull  
<           k=kt_sav(iq)
<           deltaq1=qxcess(iq)                    ! moistening
<           delq(iq,k)=delq(iq,k)+deltaq1
<           dels(iq,k)=dels(iq,k)-deltaq1*hl
<          enddo  ! iq loop
<        elseif(methdetr.eq.-1)then               ! moisten bottom layer only 
<          do iq=1,ifull  
<           k=kb_sav(iq)+1
<           deltaq1=qxcess(iq)                    ! moistening
<           delq(iq,k)=delq(iq,k)+deltaq1
<           dels(iq,k)=dels(iq,k)-deltaq1*hl
<          enddo  ! iq loop
<        elseif(methdetr.eq.8)then        ! moisten all cloud layers, top most
<          do iq=1,ifull  
<           nlayers=kt_sav(iq)-kb_sav(iq)
<           sum=.5*nlayers*(nlayers+1)
<           do k=kb_sav(iq)+1,kt_sav(iq)
<           deltaq8=qxcess(iq)*(k-kb_sav(iq))/sum ! moistening
<           delq(iq,k)=delq(iq,k)+deltaq8
<           dels(iq,k)=dels(iq,k)-deltaq8*hl
<           enddo  
<          enddo   ! iq loop
<        elseif(methdetr.eq.-8)then ! moisten all cloud layers, bottom most
<         do iq=1,ifull  
<          nlayers=kt_sav(iq)-kb_sav(iq)
<          sum=.5*nlayers*(nlayers+1)
<          do k=kb_sav(iq)+1,kt_sav(iq)
< 	   deltaq8=qxcess(iq)*(kt_sav(iq)+1-k)/sum ! moistening
<           delq(iq,k)=delq(iq,k)+deltaq8
<           dels(iq,k)=dels(iq,k)-deltaq8*hl
<          enddo  
<         enddo   ! iq loop
<        elseif(methdetr.eq.9)then                ! moisten all cloud layers
<          do iq=1,ifull  
<           nlayers=kt_sav(iq)-kb_sav(iq)
<           do k=kb_sav(iq)+1,kt_sav(iq)
<            deltaq9=qxcess(iq)/nlayers           ! moistening
<            delq(iq,k)=delq(iq,k)+deltaq9
<            dels(iq,k)=dels(iq,k)-deltaq9*hl
<           enddo  
<          enddo   ! iq loop
<        endif     ! (methdetr.eq.1)  .. else ..
<       endif  ! (detrainx.gt.0.)
< 
---
>        enddo  ! iq loop
>       enddo   ! k loop
>       
423,434c335,342
<         iq=idjd
<         nlayersd=max(1,nint((kt_sav(iq)-kb_sav(iq)-.1)/
<      .           max(1,methdetr))) ! round down
<         khalfd=kt_sav(iq)+1-nlayersd
<         nlayersp=max(1,nint((kt_sav(iq)-kb_sav(iq)-.1)/methprec)) ! round down
<         khalfp=kt_sav(iq)+1-nlayersp
<         print *,'kbsav,ktsav,khalfd ',
<      .           kb_sav(iq),kt_sav(iq),khalfd 
<         print *,'nlayersd,khalfp,nlayersp ',
<      .           nlayersd,khalfp,nlayersp 
<         print *,"delsd ",(dels(idjd,k),k=1,kt_sav(idjd))
<         print *,"delqd ",(delq(idjd,k),k=1,kt_sav(idjd))
---
> 	 iq=idjd
>         nlayersd=max(1,nint((ktsav(iq)-kbsav(iq)-.1)/methdetr)) ! round down
>         khalfd=ktsav(iq)+1-nlayersd
>         nlayersp=max(1,nint((ktsav(iq)-kbsav(iq)-.1)/methprec)) ! round down
>         khalfp=ktsav(iq)+1-nlayersp
> 	 print *,'kbsav,ktsav,khalfd,nlayersd,khalfp,nlayersp ',
>      .           kbsav(iq),ktsav(iq),khalfd,nlayersd,khalfp,nlayersp 
>         print *,'dels1 ',(dels(idjd,k),k=1,kl)
436d343
<         print *,'delhb',(dels(iq,k)+alfqarr(iq)*hl*delq(iq,k),k=1,kl)
438c345
<         do k=kb_sav(idjd),kt_sav(idjd)
---
>         do k=kbsav(idjd),ktsav(idjd)
447c354
<         if(k.gt.kb_sav(iq))then
---
>         if(k.gt.kbsav(iq))then
453,459c360,366
< c           delq(iq,k)=delq(iq,kb_sav(iq))/(1.-sigmh(kb_sav(iq)+1))
< c           dels(iq,k)=dels(iq,kb_sav(iq))/(1.-sigmh(kb_sav(iq)+1))
<             delq(iq,k)=delq(iq,kb_sav(iq))/
<      .                          (sigmh(kbsav_b(iq))-sigmh(kb_sav(iq)+1))
<             dels(iq,k)=dels(iq,kb_sav(iq))/
<      .                          (sigmh(kbsav_b(iq))-sigmh(kb_sav(iq)+1))
<           elseif(k.eq.kb_sav(iq))then  ! s and qg only from kb layer
---
> c           delq(iq,k)=delq(iq,kbsav(iq))/(1.-sigmh(kbsav(iq)+1))
> c           dels(iq,k)=dels(iq,kbsav(iq))/(1.-sigmh(kbsav(iq)+1))
>             delq(iq,k)=delq(iq,kbsav(iq))/
>      .                           (sigmh(kbsav_b(iq))-sigmh(kbsav(iq)+1))
>             dels(iq,k)=dels(iq,kbsav(iq))/
>      .                           (sigmh(kbsav_b(iq))-sigmh(kbsav(iq)+1))
>           elseif(k.eq.kbsav(iq))then  ! s and qg only from kb layer
463c370
<         endif    ! (k.gt.kb_sav(iq)) .. else ..
---
>         endif    ! (k.gt.kbsav(iq)) .. else ..
468,470c375,377
<         print *,"before convpsav calc, after division by dsk"
<         print *,"dels ",(dels(idjd,k),k=1,kt_sav(idjd))
<         print *,"delq ",(delq(idjd,k),k=1,kt_sav(idjd))
---
>         print *,"before convpsav calc "
>         print *,'delq ',(delq(idjd,k),k=1,kl)
>         print *,'dels ',(dels(idjd,k),k=1,kl)
475c382
<        if(kt_sav(iq).lt.kl)then 
---
>        if(ktsav(iq).lt.kl)then 
478,480c385,387
<          fluxb(iq)=max(0.,(rhcv*qs(iq,kb_sav(iq))-qq(iq,kb_sav(iq)))/ ! with dqsdt term
<      .            ( delq(iq,kb_sav(iq))
<      .             -rhcv*dqsdt(iq,kb_sav(iq))*dels(iq,kb_sav(iq))/cp ) ) 
---
>          fluxb(iq)=max(0.,(rhcv*qs(iq,kbsav(iq))-qq(iq,kbsav(iq)))/ ! with dqsdt term
>      .              ( delq(iq,kbsav(iq))
>      .               -rhcv*dqsdt(iq,kbsav(iq))*dels(iq,kbsav(iq))/cp ) ) 
482c389
<          if(nfluxq.eq.1)then  ! does little cf flux_dsk
---
> 	  if(nfluxq.eq.1)then  ! does little cf flux_dsk
485,486c392,393
<            fluxq(iq)=max(0.,(qq(iq,kb_sav(iq))-qq(iq,kt_sav(iq)))/ 
<      .                      (delq(iq,kt_sav(iq)) - delq(iq,kb_sav(iq))))
---
>            fluxq(iq)=max(0.,(qq(iq,kbsav(iq))-qq(iq,ktsav(iq)))/ 
>      .                      (delq(iq,ktsav(iq)) - delq(iq,kbsav(iq))))
488,495c395,401
<          endif  ! (nfluxq.eq.1)
<          if(nfluxdsk.eq.1)convpsav(iq)=
<      .                     min(convpsav(iq),dsk(kb_sav(iq)))
<          if(nfluxdsk.eq.2)convpsav(iq)=
<      .                     min(convpsav(iq),.5*dsk(kb_sav(iq)))
<          if(nfluxdsk.eq.-2)convpsav(iq)=
<      .                    min(convpsav(iq),dsk(kb_sav(iq))/(2*iterconv))
<        endif    ! (kt_sav(iq).lt.kl)
---
> 	  endif  ! (nfluxq.eq.1)
> 	  if(nfluxdsk.eq.1)convpsav(iq)=min(convpsav(iq),dsk(kbsav(iq)))
> 	  if(nfluxdsk.eq.2)convpsav(iq)=
>      .                     min(convpsav(iq),.5*dsk(kbsav(iq)))
> 	  if(nfluxdsk.eq.-2)convpsav(iq)=
>      .                     min(convpsav(iq),dsk(kbsav(iq))/(2*iterconv))
>        endif    ! (ktsav(iq).lt.kl)
500,501c406,408
< !       want: new_hbas>=new_hs(k), i.e. in limiting case:
< !       [h+alfsarr*M*dels+alfqarr*M*hl*delq]_base 
---
>         if(k.gt.kbsav(iq).and.k.le.ktsav(iq).and.ktsav(iq).lt.kl)then
> !         want: new_hbas>=new_hs(k), i.e. in limiting case:
> !         [h+alfsarr*M*dels+alfqarr*M*hl*delq]_base 
503,514c410,415
<         fluxt(iq,k)=(sbase(iq)+hl*qbase(iq)-hs(iq,k))/
<      .              (dels(iq,k)*(1.+hlcp*dqsdt(iq,k))
<      .              -alfsarr(iq)*dels(iq,kb_sav(iq))
<      .              -alfqarr(iq)*hl*delq(iq,kb_sav(iq)) ) 
< c        if(k.eq.kt_sav(iq))then
< c          convpsav(iq)=min(convpsav(iq),max(0.,fluxt(iq,k)))
< c        endif   ! (k.eq.kt_sav(iq))
< c        if(k.gt.kb_sav(iq).and.k.lt.kt_sav(iq).and.
<         if(k.gt.kb_sav(iq).and.k.le.kt_sav(iq).and.
<      .     fluxt(iq,k).gt.0.)then
<            convpsav(iq)=min(convpsav(iq),fluxt(iq,k))
<         endif   ! (k.gt.kb_sav(iq).and.k.lt.kt_sav(iq).and.fluxt(iq,k).gt.0.)
---
>           fluxt(iq)=max(0., (sbase(iq)+hl*qbase(iq)-hs(iq,k))/
>      .     (dels(iq,k)*(1.+hlcp*dqsdt(iq,k))
>      .        -alfsarr(iq)*dels(iq,kbsav(iq))
>      .        -alfqarr(iq)*hl*delq(iq,kbsav(iq)) ) )
>           convpsav(iq)=min(convpsav(iq),fluxt(iq))
>         endif   ! (k.gt.kbsav(iq).and.k.le.ktsav(iq).and.ktsav(iq).lt.kl)
515a417,432
>        if(ntest.ne.0)then
> 	 iq=idjd
>         if(k.gt.kbsav(iq).and.k.le.ktsav(iq).and.ktsav(iq).lt.kl)then
> 	   print *,'k,fluxt,convpsav,top,bott ',k,fluxt(iq),convpsav(iq),
>      .     (sbase(iq)+hl*qbase(iq)-hs(iq,k)),
>      .     ( dels(iq,k)*(1.+hlcp*dqsdt(iq,k))
>      .         -dels(iq,kbsav(iq))-alfqarr(iq)*hl*delq(iq,kbsav(iq)) )
>          if(itn.gt.1.and.ktsav(iq)-kbsav(iq).gt.6.
>      .                    and.fluxt(iq).eq.0.)then
>            print *,'ktau,itn,iq,kbsav,ktsav,ktmax ',
>      .              ktau,itn,iq,kbsav(iq),ktsav(iq),ktmax(iq)
>            print *,'hsdiff,fluxb ',
>      .              hs(iq,kbsav(iq))-hs(iq,ktsav(iq)),fluxb(iq)
>          endif
>         endif   ! (k.gt.kbsav(iq).and.k.le.ktsav(iq).and.ktsav(iq).lt.kl)
>        endif    ! (ntest.ne.0)
516a434,453
>       
>       if(iterconv.gt.1)then 
>         if(convfact.le.1.001)then 
> !         not needed if cloud base rising (19/7/02)
>           ktmax=ktsav   !2D ready for next itn iteration
>         else
>           convpsav=convfact*convpsav !2D typically convfact=1.02  
>         endif    ! (convfact.le.1.001)
>       endif      ! (iterconv.gt.1)
>       factr=dt/max(dt,convtime*3600.) ! was using 1.01 till 29/3/01
>       convpsav=factr*convpsav  !2D
> 
> !!!!!!!!!!!!!!!!!!!!! precip distribution now here !!!!!v2!!!!!!      
>       do iq=1,ifull  
>        detr=max( detrain,detrain+(dsig4-sig(kbsav(iq))+sig(ktsav(iq)))*
>      .                 (detrainx-detrain)/(dsig4-dsig2) )
>        detr=min(detr,detrainx)
>        qxcess(iq)=detr*rnrtc(iq) ! e.g. .2* gives 20% detrainment
>        rnrtc(iq)=rnrtc(iq)-qxcess(iq)
>       enddo   ! iq loop
518,528c455,475
<       if(abs(ksc).gt.90)then  ! will do shallow clouds in vertmix
<         do iq=1,ifull
< c        if(sig(kt_sav(iq)).gt.sigksct)then
<          if(sig(kt_sav(iq)).gt..8)then
<            convpsav(iq)=0.
<          endif
<         enddo  ! iq loop
<       elseif(ksc.eq.22)then  ! will do shallow clouds in vertmix
<         do iq=1,ifull
<          if(sig(kt_sav(iq)).gt..01*ksc)then  ! e.g. ksc=80
<            convpsav(iq)=0.
---
>       if(methprec.eq.1)then     ! expel rain from top layer only
>        do iq=1,ifull  
>         rnrt3(iq,ktsav(iq))=rnrtc(iq)
>        enddo  ! iq loop
>       elseif(methprec.eq.9)then ! expel rain from all cloud layers
>        do iq=1,ifull  
>         nlayers=ktsav(iq)-kbsav(iq)
>         do k=kbsav(iq)+1,ktsav(iq)
>          rnrt3(iq,k)=rnrtc(iq)/nlayers
>         enddo  
>        enddo   ! iq loop
>       else                      ! expel rain from upper layers - usual
>        do k=kuocb+1,kl-1 
>         do iq=1,ifull  
> c        khalf=min( ktsav(iq) , max( (2-methprec)*ktsav(iq),
> c    .         nint((kbsav(iq)+(methprec-1.)*ktsav(iq))/methprec+1.1) ))
> c        nlayers=ktsav(iq)+1-khalf
>          nlayers=max(1,nint((ktsav(iq)-kbsav(iq)-.1)/methprec)) ! round down
>          khalf=ktsav(iq)+1-nlayers
>          if(k.ge.khalf.and.k.le.ktsav(iq))then
>           rnrt3(iq,k)=rnrtc(iq)/nlayers
531,539c478,480
<       endif
<       
<       if(itn.eq.1)then 
<         kbsav(:)=kb_sav(:) 
<         ktsav(:)=kt_sav(:) 
<       endif                              ! (itn.eq.1)
<       if(itn.lt.iterconv)then 
<         convpsav(:)=convfact*convpsav(:) ! typically convfact=1.02  
<       endif                              ! (itn.lt.iterconv)
---
>        enddo   ! k loop
>       endif    ! (methprec.eq.1)  .. else ..
> 
544,545c485,486
<         detr=max( detrain,detrain+(dsig4-sig(kb_sav(iq))+
<      .            sig(kt_sav(iq)))*(detrainx-detrain)/(dsig4-dsig2) )
---
>         detr=max( detrain,detrain+(dsig4-sig(kbsav(iq))+sig(ktsav(iq)))*
>      .                 (detrainx-detrain)/(dsig4-dsig2) )
548,553c489,493
<      .           detr,sig(kb_sav(iq))-sig(kt_sav(iq)),qxcess(iq)
<         flux_dsk=dsk(kb_sav(idjd))*convfact
<         if(nfluxdsk.eq.2)flux_dsk=.5*dsk(kb_sav(idjd))*convfact
<         write(6,"('flux_dsk,fluxq,fluxb,convpsav',5f8.5)")
<      .       flux_dsk,fluxq(idjd),fluxb(idjd),convpsav(idjd)
<         write(6,"('fluxt',9f8.5/9f8.5)") (fluxt(iq,k),k=1,kt_sav(iq))
---
>      .           detr,sig(kbsav(iq))-sig(ktsav(iq)),qxcess(iq)
>         flux_dsk=dsk(kbsav(idjd))*convfact
> 	 if(nfluxdsk.eq.2)flux_dsk=.5*dsk(kbsav(idjd))*convfact
>         write(6,"('flux_dsk,fluxq,fluxb,fluxt,convpsav',5f6.3)")
>      .       flux_dsk,fluxq(idjd),fluxb(idjd),fluxt(idjd),convpsav(idjd)
555c495
<      .   (1000.*convpsav(idjd)*delq(idjd,k),k=1,kl)
---
>      .	 (1000.*convpsav(idjd)*delq(idjd,k),k=1,kl)
557c497
<      .   (convpsav(idjd)*dels(idjd,k)/cp,k=1,kl)
---
>      .	 (convpsav(idjd)*dels(idjd,k)/cp,k=1,kl)
559c499
<      .   (1000.*convpsav(idjd)*delq(idjd,k)*dsk(k),k=1,kl)
---
>      .	 (1000.*convpsav(idjd)*delq(idjd,k)*dsk(k),k=1,kl)
561,563c501,503
<      .   (convpsav(idjd)*dels(idjd,k)*dsk(k)/cp,k=1,kl)
<         convmax=0.
<         nums=0
---
>      .	 (convpsav(idjd)*dels(idjd,k)*dsk(k)/cp,k=1,kl)
> 	 convmax=0.
> 	 nums=0
565,569c505,508
<          if(kt_sav(iq)-kb_sav(iq).eq.1)then
<            nums=nums+1
<            if(convpsav(iq).gt.convmax)then
< c          if(nums.lt.20)then
<              convmax=convpsav(iq)
---
> 	  if(ktsav(iq)-kbsav(iq).eq.1)then
> 	    nums=nums+1
> 	    if(convpsav(iq).gt.convmax)then
> 	      convmax=convpsav(iq)
571,575c510,513
<      .       iq,nums,kb_sav(iq),kt_sav(iq),
<      .       dsk(kb_sav(iq)),fluxq(iq),fluxb(iq),
<      .       fluxt(iq,kt_sav(iq)),convpsav(iq),
<      .       qq(iq,kb_sav(iq))/qs(iq,kb_sav(iq)),
<      .       qq(iq,kt_sav(iq))/qs(iq,kt_sav(iq))
---
>      .       iq,nums,kbsav(iq),ktsav(iq),
>      .       dsk(kbsav(iq)),fluxq(iq),fluxb(iq),fluxt(iq),convpsav(iq),
>      .       qq(iq,kbsav(iq))/qs(iq,kbsav(iq)),
>      .       qq(iq,ktsav(iq))/qs(iq,ktsav(iq))
579,580c517,518
<         convmax=0.
<         nums=0
---
> 	 convmax=0.
> 	 nums=0
582,586c520,523
<          if(kt_sav(iq)-kb_sav(iq).eq.2)then
<            nums=nums+1
<            if(convpsav(iq).gt.convmax)then
< c          if(nums.lt.20)then
<              convmax=convpsav(iq)
---
> 	  if(ktsav(iq)-kbsav(iq).eq.2)then
> 	    nums=nums+1
> 	    if(convpsav(iq).gt.convmax)then
> 	      convmax=convpsav(iq)
588,592c525,528
<      .       iq,nums,kb_sav(iq),kt_sav(iq),
<      .       dsk(kb_sav(iq)),fluxq(iq),fluxb(iq),
<      .       fluxt(iq,kt_sav(iq)),convpsav(iq),
<      .       qq(iq,kb_sav(iq))/qs(iq,kb_sav(iq)),
<      .       qq(iq,kt_sav(iq))/qs(iq,kt_sav(iq))
---
>      .       iq,nums,kbsav(iq),ktsav(iq),
>      .       dsk(kbsav(iq)),fluxq(iq),fluxb(iq),fluxt(iq),convpsav(iq),
>      .       qq(iq,kbsav(iq))/qs(iq,kbsav(iq)),
>      .       qq(iq,ktsav(iq))/qs(iq,ktsav(iq))
596,597c532,533
<         convmax=0.
<         nums=0
---
> 	 convmax=0.
> 	 nums=0
599,603c535,538
<          if(kt_sav(iq)-kb_sav(iq).eq.3)then
<            nums=nums+1
<            if(convpsav(iq).gt.convmax)then
< c          if(nums.lt.20)then
<              convmax=convpsav(iq)
---
> 	  if(ktsav(iq)-kbsav(iq).eq.3)then
> 	    nums=nums+1
> 	    if(convpsav(iq).gt.convmax)then
> 	      convmax=convpsav(iq)
605,609c540,543
<      .       iq,nums,kb_sav(iq),kt_sav(iq),
<      .       dsk(kb_sav(iq)),fluxq(iq),fluxb(iq),
<      .       fluxt(iq,kt_sav(iq)),convpsav(iq),
<      .       qq(iq,kb_sav(iq))/qs(iq,kb_sav(iq)),
<      .       qq(iq,kt_sav(iq))/qs(iq,kt_sav(iq))
---
>      .       iq,nums,kbsav(iq),ktsav(iq),
>      .       dsk(kbsav(iq)),fluxq(iq),fluxb(iq),fluxt(iq),convpsav(iq),
>      .       qq(iq,kbsav(iq))/qs(iq,kbsav(iq)),
>      .       qq(iq,ktsav(iq))/qs(iq,ktsav(iq))
616d549
<       rnrtc(:)=rnrtc(:)+convpsav(:)*rnrtcn(:)*conrev(:) ! g/m**2/s
620a554
>         rnrt3d(iq,k)=rnrt3d(iq,k)+convpsav(iq)*rnrt3(iq,k)*conrev(iq) !  gm/m**2/sec
624,628c558,559
< !!!!!!!!!!!!!!!!!!!!! "deep" detrainment using detrain !!!!!v3!!!!!!    
< !     N.B. convpsav has been updated here, but without factr term  
<       qxcess(:)=detrain*rnrtcn(:)             ! e.g. .2* gives 20% detrainment
<       rnrtcn(:)=rnrtcn(:)-qxcess(:)
<       if(methprec.eq.1)then                   ! moisten top layer only 
---
> !!!!!!!!!!!!!!!!!!!!! moistening now here !!!!!v2!!!!!!      
>       if(methdetr.eq.1)then     ! moisten top layer only - usual
630,631c561,562
<         deltaq1=convpsav(iq)*qxcess(iq)/dsk(kt_sav(iq))             
<         qliqw(iq,kt_sav(iq))=qliqw(iq,kt_sav(iq))+deltaq1
---
>         deltaq1=convpsav(iq)*qxcess(iq)/dsk(ktsav(iq))   ! moistening
>         qliqw(iq,ktsav(iq))=qliqw(iq,ktsav(iq))+deltaq1
633c564
<       elseif(methprec.eq.8)then               ! moisten all cloud layers, top most
---
>       elseif(methdetr.eq.8)then ! moisten all cloud layers, top most
635c566
<         nlayers=kt_sav(iq)-kb_sav(iq)
---
>         nlayers=ktsav(iq)-kbsav(iq)
637,638c568,569
<         do k=kb_sav(iq)+1,kt_sav(iq)
<            deltaq8=convpsav(iq)*qxcess(iq)*(k-kb_sav(iq))/(sum*dsk(k)) 
---
>         do k=kbsav(iq)+1,ktsav(iq)
> 	  deltaq8=convpsav(iq)*qxcess(iq)*(k-kbsav(iq))/(sum*dsk(k))   ! moistening
642c573
<       elseif(methprec.eq.9)then               ! moisten all cloud layers
---
>       elseif(methdetr.eq.9)then ! moisten all cloud layers
644,646c575,577
<         nlayers=kt_sav(iq)-kb_sav(iq)
<         do k=kb_sav(iq)+1,kt_sav(iq)
<          deltaq9=convpsav(iq)*qxcess(iq)/(nlayers*dsk(k))       
---
>         nlayers=ktsav(iq)-kbsav(iq)
>         do k=kbsav(iq)+1,ktsav(iq)
>          deltaq9=convpsav(iq)*qxcess(iq)/(nlayers*dsk(k))   ! moistening
650c581
<       else                                    ! moisten upper layers
---
>       else                      ! moisten upper layers
653,656c584,587
<          nlayers=max(1,nint((kt_sav(iq)-kb_sav(iq)-.1)/methdetr))   ! round down
<          khalf=kt_sav(iq)+1-nlayers
<          if(k.ge.khalf.and.k.le.kt_sav(iq))then
<            deltaq=convpsav(iq)*qxcess(iq)/(nlayers*dsk(k))         
---
>          nlayers=max(1,nint((ktsav(iq)-kbsav(iq)-.1)/methdetr)) ! round down
>          khalf=ktsav(iq)+1-nlayers
>          if(k.ge.khalf.and.k.le.ktsav(iq))then
>            deltaq=convpsav(iq)*qxcess(iq)/(nlayers*dsk(k))  ! moistening
661c592
<       endif    ! (methprec.eq.1)  .. else ..
---
>       endif    ! (methdetr.eq.1)  .. else ..
667c598
<      .                 ktau,itn,kb_sav(idjd),kt_sav(idjd)
---
>      .                 ktau,itn,kbsav(idjd),ktsav(idjd)
673,675c604,610
<         print *,'ktsav,qbase,qs_ktsav,qq_ktsav ',
<      .          kt_sav(iq),qbase(iq),qs(iq,kt_sav(iq)),qq(iq,kt_sav(iq)) 
<         iq=idjd
---
> 	 print *,'ktsav,qbase,qs_ktsav,qq_ktsav ',
>      .	          ktsav(iq),qbase(iq),qs(iq,ktsav(iq)),qq(iq,ktsav(iq)) 
>         write (6,"('rnrt3 ',19f7.5/(8x,19f7.5))") 
>      .             (rnrt3(idjd,k),k=1,kl)
>         write (6,"('rnrt3d_c',19f7.3/(8x,19f7.3))") 
>      .             (rnrt3d(idjd,k),k=1,kl)
> 	 iq=idjd
678c613
<         rnd_av=rnd_av+rnrtc(iq)
---
>         rnd_av=0.
683a619
>          rnd_av=rnd_av+convpsav(iq)*rnrt3(iq,k)*conrev(iq)
688c624
<      .        ktau,itn,kb_sav(idjd),kt_sav(idjd),delt_av,heatlev/delt_av
---
>      .          ktau,itn,kbsav(idjd),ktsav(idjd),delt_av,heatlev/delt_av
692,697c628
<         do k=1,kl   
<          do iq=1,ifull
<           delu(iq,k)=0.
<           delv(iq,k)=0.
<          enddo   ! iq loop
<         enddo    ! k loop
---
>        do k=1,kl   
699,740c630,678
<          k=kt_sav(iq)                        ! dels and delq for top layer
<          delu(iq,k)=delu(iq,k)+(u(iq,kb_sav(iq))-u(iq,k)) 
<          delu(iq,k-1)=u(iq,k)                ! subsidence into lower layer
<          delv(iq,k)=delv(iq,k)+(v(iq,kb_sav(iq))-v(iq,k))
<          delv(iq,k-1)=v(iq,k)                ! subsidence into lower layer
<          do k=kt_sav(iq)-1,kb_sav(iq)+1,-1
<           delu(iq,k)=delu(iq,k)-u(iq,k)      ! subs.
<           delu(iq,k-1)=u(iq,k)               ! subsidence into lower layer
<           delv(iq,k)=delv(iq,k)-v(iq,k)      ! subs.
<           delv(iq,k-1)=v(iq,k)               ! subsidence into lower layer
<          enddo
< !        assume cloud base layer, and those below it, are mixed well
<          delu(iq,kb_sav(iq))=delu(iq,kb_sav(iq))-u(iq,kb_sav(iq))
<          delv(iq,kb_sav(iq))=delv(iq,kb_sav(iq))-v(iq,kb_sav(iq))
<         enddo  ! iq loop
< !       calculate actual delu and delv
<         do k=1,kl-1   
<          do iq=1,ifull
<           if(k.gt.kb_sav(iq))then
<             delu(iq,k)=delu(iq,k)/dsk(k)
<             delv(iq,k)=delv(iq,k)/dsk(k)
<           else
<             if(nbase.eq.0.and.k.ge.kbsav_b(iq))then
< !             assume cloud base layer, and those below it, are mixed well
<               delu(iq,k)=delu(iq,kb_sav(iq))/
<      .                   (sigmh(kbsav_b(iq))-sigmh(kb_sav(iq)+1))
<               delv(iq,k)=delv(iq,kb_sav(iq))/
<      .                   (sigmh(kbsav_b(iq))-sigmh(kb_sav(iq)+1))
<             elseif(k.eq.kb_sav(iq))then        ! u and v only from kb layer
<               delu(iq,k)=delu(iq,k)/dsk(k)
<               delv(iq,k)=delv(iq,k)/dsk(k)
<             endif  ! (nbase.eq.0)
<           endif    ! (k.gt.kb_sav(iq)) .. else ..
<          enddo     ! iq loop
<         enddo      ! k loop
< !       update u, v
<         do k=1,kl   
<          do iq=1,ifull
<           u(iq,k)=u(iq,k)+factr*convpsav(iq)*delu(iq,k)
<           v(iq,k)=v(iq,k)+factr*convpsav(iq)*delv(iq,k)
<          enddo    ! iq loop
<         enddo     ! k loop
---
>          delu(iq,k)=0.
>          delv(iq,k)=0.
>         enddo   ! iq loop
>        enddo    ! k loop
>        do iq=1,ifull
>         k=ktsav(iq)   ! dels and delq for top layer
>         delu(iq,k)=delu(iq,k)
>      .             +(u(iq,kbsav(iq))-u(iq,k)) 
>         delu(iq,k-1)=u(iq,k)    ! subsidence into lower layer
>         delv(iq,k)=delv(iq,k)
>      .             +(v(iq,kbsav(iq))-v(iq,k))
>          delv(iq,k-1)=v(iq,k)    ! subsidence into lower layer
>         do k=ktsav(iq)-1,kbsav(iq)+1,-1
>          delu(iq,k)=delu(iq,k)-u(iq,k) ! subs.
>          delu(iq,k-1)=u(iq,k)          ! subsidence into lower layer
>          delv(iq,k)=delv(iq,k)-v(iq,k) ! subs.
>          delv(iq,k-1)=v(iq,k)          ! subsidence into lower layer
>         enddo
> !       assume cloud base layer, and those below it, are mixed well
>         delu(iq,kbsav(iq))=delu(iq,kbsav(iq))-u(iq,kbsav(iq))
>         delv(iq,kbsav(iq))=delv(iq,kbsav(iq))-v(iq,kbsav(iq))
>        enddo  ! iq loop
> !      calculate actual delu and delv
>        do k=1,kl-1   
>         do iq=1,ifull
>          if(k.gt.kbsav(iq))then
>            delu(iq,k)=delu(iq,k)/dsk(k)
>            delv(iq,k)=delv(iq,k)/dsk(k)
>          else
>            if(nbase.eq.0.and.k.ge.kbsav_b(iq))then
> !            assume cloud base layer, and those below it, are mixed well
>              delu(iq,k)=delu(iq,kbsav(iq))/
>      .                           (sigmh(kbsav_b(iq))-sigmh(kbsav(iq)+1))
>              delv(iq,k)=delv(iq,kbsav(iq))/
>      .                           (sigmh(kbsav_b(iq))-sigmh(kbsav(iq)+1))
>            elseif(k.eq.kbsav(iq))then  ! u and v only from kb layer
>              delu(iq,k)=delu(iq,k)/dsk(k)
>              delv(iq,k)=delv(iq,k)/dsk(k)
>            endif  ! (nbase.eq.0)
>          endif    ! (k.gt.kbsav(iq)) .. else ..
>         enddo     ! iq loop
>        enddo      ! k loop
> !      update u, v
>        do k=1,kl   
>         do iq=1,ifull
>          u(iq,k)=u(iq,k)+convpsav(iq)*delu(iq,k)
>          v(iq,k)=v(iq,k)+convpsav(iq)*delv(iq,k)
>         enddo    ! iq loop
>        enddo     ! k loop
748c686
<            do iq=1,ifull
---
> 	   do iq=1,ifull
753,756c691,694
<           if(kt_sav(iq).lt.kl)then
<             kb=kb_sav(iq)
<             kt=kt_sav(iq)
<             veldt=factr*convpsav(iq)*(1.-fldow(iq))  ! simple treatment
---
>           if(ktsav(iq).lt.kl)then
>             kb=kbsav(iq)
>             kt=ktsav(iq)
>             veldt=convpsav(iq)*(1.-fldow(iq))  ! simple treatment
772,773c710,713
<         write (6,"('uuc ',19f6.1/(8x,19f6.1))") (u(idjd,k),k=1,kl)
<         write (6,"('vvc ',19f6.1/(8x,19f6.1))") (v(idjd,k),k=1,kl)
---
>         write (6,"('uuc ',19f6.1/(8x,19f6.1))") 
>      .             (u(idjd,k),k=1,kl)
>         write (6,"('vvc ',19f6.1/(8x,19f6.1))") 
>      .             (v(idjd,k),k=1,kl)
774a715
>  
777,782d717
<       if(factr.lt.1.)then
<         rnrtc(:)=factr*rnrtc(:)
<         qq(:,:)=qg(:,:)+factr*(qq(:,:)-qg(:,:))      
<         qliqw(:,:)=factr*qliqw(:,:)      
<         tt(:,:)= t(:,:)+factr*(tt(:,:)- t(:,:))      
<       endif  ! (factr.lt.1.)
785,795c720,726
<       if(ifullw.eq.ifull)then
< !       Leon's stuff here, e.g.
<         do k=1,kl
<           do iq=1,ifullw
<            qlg(iq,k)=qlg(iq,k)+qliqw(iq,k)
<           enddo
<          enddo
<       else
<         qq(:,:)=qq(:,:)+qliqw(:,:)         
<         tt(:,:)=tt(:,:)-hl*qliqw(:,:)/cp   
<       endif  ! (ifullw.eq.ifull)
---
>       do k=1,kl   
>        do iq=1,ifull
>         qq(iq,k)=qq(iq,k)+qliqw(iq,k)
>         tt(iq,k)=tt(iq,k)-hl*qliqw(iq,k)/cp
>        enddo    ! iq loop
>       enddo     ! k loop
> 
797c728
<      
---
> !     now evap of convective rainfall, and vertical accumulation of rnrt3d
799,801c730,800
<         print *,"after convection"
<         write (6,"('qge ',19f7.3/(8x,19f7.3))")(1000.*qq(idjd,k),k=1,kl)
<         write (6,"('tte ',19f6.1/(8x,19f6.1))")(tt(idjd,k),k=1,kl)
---
>         print *,"before nevapcc=5 section"
>         write (6,"('rnrt3d_d',19f7.3/(8x,19f7.3))") 
>      .             (rnrt3d(idjd,k),k=1,kl)
>       endif   ! (ntest.ne.0.or.diag)
> 
>       if(nevapcc.eq.5)then  !  like nevapls=5
>         rKa=2.4e-2
>         rvap=461.
>         Dva=2.21
> c       cfls=1.     ! cld frac
>         cfls=rhmois ! cld frac when using nevapcc=5
>         cflscon=4560.*cfls**.3125
>         do k=kl-2,1,-1
>          do iq=1,ifull
> !         fluxr(iq)=rnrt(iq)*1.e-3*dt ! kg/m2
>           fluxc=rnrt3d(iq,k+1)*1.e-3*dt ! kg/m2
>           rhodz=ps(iq)*dsk(k)/grav
>           qpf=fluxc/rhodz     ! Mix ratio of rain which falls into layer
>           pk=ps(iq)*sig(k)
>           es=qs(iq,k)*pk/.622
>           Apr=hl*hl/(rKa*tt(iq,k)*(rvap*tt(iq,k))-1.)
>           Bpr=rvap*tt(iq,k)*pk/(Dva*es)
>           Fr=fluxc/(cfls*dt)
> c	   if(Fr.lt.0.)then
> c	     print *,'negative flux for ktau,iq,k,cfls ',ktau,iq,k,cfls
> c           print *,'rnrt3d ',(rnrt3d(iq,kk),kk=1,kl)
> c	     print *,'kbsav,ktsav ',kbsav(iq),ktsav(iq)
> c	     stop
> c	   endif
>           rhoa=pk/(r*tt(iq,k))
>           dz=pk/(rhoa*grav)
>           Vr=max(.01 , 11.3*Fr**(1./9.)/sqrt(rhoa)) ! Actual fall speed
>           dtev=dz/Vr
>           qr=fluxc/(dt*rhoa*Vr)
>           qgdiff=qs(iq,k)-qq(iq,k)
>           Cev2=cflscon*qgdiff/(qs(iq,k)*(Apr+Bpr)) ! Ignore rhoa**0.12
>           qr2=max(0. , qr**.3125 - .3125*Cev2*dtev)**3.2
>           Cevx=(qr-qr2)/dtev  ! i.e. Cev*qgdiff
>           alphal=hl*qs(iq,k)/(ars*tt(iq,k)**2)
>           blx=qgdiff+Cevx*dt*(1.+hlcp*alphal)  ! i.e. bl*qgdiff
>           evapls=cfls*dt*Cevx*qgdiff/blx ! UKMO
>           evapls=max(0. , min(evapls,qpf))
>           revc(iq,k)=min(evapls , rnrt3d(iq,k+1)/(conrev(iq)*dsk(k)))
> !         max needed for roundoff
>           rnrt3d(iq,k)=rnrt3d(iq,k)
>      .        +max(0., rnrt3d(iq,k+1)-revc(iq,k)*dsk(k)*conrev(iq))
>           tt(iq,k)=tt(iq,k)-revc(iq,k)*hlcp
>           qq(iq,k)=qq(iq,k)+revc(iq,k)
>          enddo    ! iq loop
>         enddo     ! k loop
>       endif       ! (nevapcc.eq.5)
> 
>       if(nevapcc.eq.0)then
>         do k=2,kl-1
>          do iq=1,ifull
>           rnrt3d(iq,1)=rnrt3d(iq,1)+rnrt3d(iq,k)
>          enddo    ! iq loop
>         enddo     ! k loop
>       endif       ! (nevapcc.eq.0) .. else ..
>       do iq=1,ifull
>        rnrtc(iq)=rnrt3d(iq,1) ! save in convective rainfall array
>       enddo  ! iq loop
> 
>       if(ntest.ne.0.or.diag)then
>         print *,"after  convection & evap"
>         write (6,"('qge ',19f7.3/(8x,19f7.3))") 
>      .             (1000.*qq(idjd,k),k=1,kl)
>         write (6,"('tte ',19f6.1/(8x,19f6.1))") 
>      .             (tt(idjd,k),k=1,kl)
>         write (6,"('rnrt3d  ',19f7.3/(8x,19f7.3))") 
>      .             (rnrt3d(idjd,k),k=1,kl)
803,811c802,810
< !       following calc of total heatlev really needs iterconv=1  
<          do k=kl-2,1,-1
<           delt_av=delt_av-dsk(k)*revc(idjd,k)*hlcp
<           heatlev=heatlev-sig(k)*dsk(k)*revc(idjd,k)*hlcp
<           print *,'k,rh,delt_av, heatlev ',
<      .           k,100.*qq(idjd,k)/qs(idjd,k),delt_av,heatlev
<          enddo
<          if(delt_av.ne.0.)print *,'ktau,delt_av-net,heatlev_net ',
<      .                             ktau,delt_av,heatlev/delt_av
---
> !       following calc of total heatlev really needs iterconv=1	 
> 	 do k=kl-2,1,-1
> 	  delt_av=delt_av-dsk(k)*revc(idjd,k)*hlcp
> 	  heatlev=heatlev-sig(k)*dsk(k)*revc(idjd,k)*hlcp
> 	  print *,'k,rh,delt_av, heatlev ',
>      .            k,100.*qq(idjd,k)/qs(idjd,k),delt_av,heatlev
> 	 enddo
> 	 if(delt_av.ne.0.)print *,'ktau,delt_av-net,heatlev_net ',
>      .                            ktau,delt_av,heatlev/delt_av
813c812
<       if(ifullw.gt.1)go to 8
---
>       if(nkuo.lt.0)go to 8
816,822c815,816
< !     check for grid-scale rainfall 
< 5     do k=1,kl   
<        do iq=1,ifull
<         es(iq,k)=establ(tt(iq,k))
<        enddo  ! iq loop
<       enddo   ! k loop
<       do k=kl,1,-1    ! top down to end up with proper kbsav_ls
---
> c     check for grid-scale rainfall 
> 5     do k=kl,1,-1    ! top down to end up with proper kbsav_ls
823a818
>         es=establ(tt(iq,k))
825c820
<         qs(iq,k)=max(.622*es(iq,k)/(pk-es(iq,k)),1.5e-6)  
---
>         qs(iq,k)=max(.622*es/(pk-es),1.5e-6)  ! Sat  10-31-1998
828c823
<           gam=max(hlcp*qs(iq,k)*pk*hlars/(tt(iq,k)**2*(pk-es(iq,k))),0.) 
---
>           gam=max(hlcp*qs(iq,k)*pk*hlars/(tt(iq,k)**2*(pk-es)),0.) 
837,841c832,836
< !!!!!!!!!!!!!!!!  now do evaporation of L/S precip !!!!!!!!!!!!!!!!!!
< !     conrev(iq)=1000.*ps(iq)/(grav*dt)     
<       rnrt(:)=rnrt(:)*conrev(:)                 
< !     here the rainfall rate rnrt has been converted to g/m**2/sec
<       fluxr(:)=rnrt(:)*1.e-3*dt ! kg/m2      
---
> c     now do evaporation of L/S precip
> c      Here rnrt is the rainfall rate in gm/m**2/sec
> !      conrev(iq)=1000.*ps(iq)/(grav*dt)     
>        rnrt=rnrt*conrev                 !2D
>        fluxr=rnrt*1.e-3*dt ! kg/m2      !2D
851a847,862
>       if(nevapls.eq.1)then
>         do k=2*kl/3,1,-1
>          do iq=1,ifull
>           if(k.lt.kbsav_ls(iq))then
>             revq=dt*ecmwls*ecmwa1*max((qs(iq,k)-qq(iq,k)),0.)
>      .                     *sqrt(sqrt(sig(k))*rnrt(iq)/ecmwa2)
>             revq=min(revq,rnrt(iq)/(conrev(iq)*dsk(k)))
> !           max needed for roundoff
>             rnrt(iq)=max(1.e-10,rnrt(iq)-revq*dsk(k)*conrev(iq))
>             tt(iq,k)=tt(iq,k)-revq*hlcp
>             qq(iq,k)=qq(iq,k)+revq
>           endif   !  (k.lt.kbsav_ls(iq))
>          enddo    ! iq loop
>         enddo     ! k loop
>       endif       ! (nevapls.eq.1)
> 
864c875
< c           es(iq,k)=qs(iq,k)*pk/.622
---
>             es=qs(iq,k)*pk/.622
866c877
<             Bpr=rvap*tt(iq,k)*pk/(Dva*es(iq,k))
---
>             Bpr=rvap*tt(iq,k)*pk/(Dva*es)
874c885
<             Cev2=cflscon*qgdiff/(qs(iq,k)*(Apr+Bpr))  ! Ignore rhoa**0.12
---
>             Cev2=cflscon*qgdiff/(qs(iq,k)*(Apr+Bpr)) ! Ignore rhoa**0.12
881,882c892,893
< !           evapls= cfls*dt*qgdiff*Cev/bl        ! UKMO
<             evapls= cfls*dt*Cevx*qgdiff/blx      ! UKMO
---
> !           evapls= cfls*dt*qgdiff*Cev/bl ! UKMO
>             evapls= cfls*dt*Cevx*qgdiff/blx ! UKMO
893c904
<           endif   ! (k.lt.kbsav_ls(iq))
---
>           endif   !  (k.lt.kbsav_ls(iq))
897c908
< !__________________________end of large-scale calculations_____________________
---
>       if(nkuo.lt.0)go to 2
898a910
> !__________________________end of large-scale calculations_____________________
900,909c912,914
< 8     qg(:,:)=qq(:,:)                   
<       condc(:)=.001*dt*rnrtc(:)      ! convective precip for this timestep
<       precc(:)=precc(:)+condc(:)        
<       condx(:)=condc(:)+.001*dt*rnrt(:) ! total precip for this timestep
<       precip(:)=precip(:)+condx(:)      
<       t(:,:)=tt(:,:)             
< 
<       if(ntest.eq.1.or.diag)then
<         print *,'at end of convjlm: rnrt,rnrtc ',
<      .                              rnrt(idjd),rnrtc(idjd)
---
> 8     if(ntest.ne.0.or.diag)then
>         print *,'near end of convjlm: rnrt,rnrtc ',
>      .                                  rnrt(idjd),rnrtc(idjd)
914c919,940
<         pwater=0.   ! in mm     
---
>       endif
> 
>       if(npanels.eq.0)then     ! for DARLAM
>         i1=3       ! for DARLAM
>         j1=3       ! for DARLAM
>         imax=il-1  ! for DARLAM
>         jmax=jl-1  ! for DARLAM
>         do j=j1,jmax
>          do i=i1,imax
>           iq=i+(j-1)*il
>           condc(iq)=.001*dt*rnrtc(iq)    ! convective precip for this timestep
>           precc(iq)=precc(iq)+condc(iq)
>           condx(iq)=condc(iq)+.001*dt*rnrt(iq) ! total precip for this timestep
>           precip(iq)=precip(iq)+condx(iq)
>          enddo  !  i loop
>         enddo   !  j loop
>         if(ndavconv.eq.0)then  
>           factdav=1.  !2D
>         else          ! i.e. for ndavconv=1 or 2
>           factdav=1.-davt  !2D to reduce heating near boundaries
>         endif         ! (ndavconv.eq.0) .. else ..
>         if(ndavconv.eq.2)then     ! davies-style for qg near boundaries too
915a942,993
>            do j=j1,jmax
>             do i=i1,imax
>              iq=i+(j-1)*il
>              qg(iq,k)=qg(iq,k)+factdav(iq)*(qq(iq,k)-qg(iq,k))
>             enddo  !  i loop
>            enddo   !  j loop
>           enddo    !  k loop
>         else         ! i.e. for ndavconv=1 don't reduce moisture changes
>           do k=1,kl
>            do j=j1,jmax
>             do i=i1,imax
>              iq=i+(j-1)*il
>              qg(iq,k)=qq(iq,k)
>             enddo  !  i loop
>            enddo   !  j loop
>           enddo    !  k loop
>         endif      ! (ndavconv.eq.2)
>         if(abs(nkuo).eq.23)then  ! split T at end of timestep (tn not used)
>           do k=1,kl
>            do j=j1,jmax
>             do i=i1,imax
>              iq=i+(j-1)*il
>              t(iq,k)=tt(iq,k)
>             enddo  !  i loop
>            enddo   !  j loop
>           enddo    !  k loop
>         else
>           do k=1,kl
>            do j=j1,jmax
>             do i=i1,imax
>              iq=i+(j-1)*il
>              tn(iq,k)=tn(iq,k)+factdav(iq)*(tt(iq,k)-t(iq,k))/dt
>             enddo  !  i loop
>            enddo   !  j loop
>           enddo    !  k loop
>         endif      ! (abs(nkuo).eq.23)
>       else         ! usual conformal-cubic
>         qg=qq      ! 3D
>         condc=.001*dt*rnrtc      !2D convective precip for this timestep
>         precc=precc+condc        !2D
>         condx=condc+.001*dt*rnrt !2D total precip for this timestep
>         precip=precip+condx      !2D
>         if(abs(nkuo).eq.23)then  ! split T at end of timestep (tn not used)
>           t=tt             !3D
>         else
>           tn=tn+(tt-t)/dt  !3D
>         endif
>       endif        ! (npanels.eq.0)
> 
>       if(ntest.eq.1.or.diag)then
>         pwater=0.   ! in mm     
> 	 do k=1,kl
917,919c995,997
<           enddo
<           print *,'pwater0,pwater+condx,pwater ',
<      .           pwater0,pwater+condx(idjd),pwater
---
> 	 enddo
> 	 print *,'pwater0,pwater+condx,pwater ',
>      .	          pwater0,pwater+condx(idjd),pwater
=====================================
 
davies.f
=====================================
14,17c14,16
<         if(nmaxpr.eq.1.and.ktau.lt.5)then
< 	   print *,'davies in  uu,vv,qgg(kl) ',
<      .             uu(idjd,nlv),vv(idjd,nlv),qgg(idjd,kl)
<           print *,'davies in  u,v,qg(kl) ',
---
>         if(nmaxpr.eq.1)print *,'davies in  uu,vv,qgg(kl) ',
>      .           uu(idjd,nlv),vv(idjd,nlv),qgg(idjd,kl)
>         if(nmaxpr.eq.1)print *,'davies in  u,v,qg(kl) ',
19d17
<         endif
76,77c74
<         if(nmaxpr.eq.1.and.ktau.lt.5)then
<           print *,'davies out u,v,qg(kl) ',
---
>         if(nmaxpr.eq.1)print *,'davies out u,v,qg(kl) ',
79d75
<         endif
=====================================
 
depts.f
=====================================
1,72d0
<       subroutine depts1(k)  ! input ubar,vbar are unstaggered vels for level k
< c     modify toij5 for Cray
<       parameter (ntest=0)      
<       include 'newmpar.h'
<       include 'constant.h'   ! rearth
<       include 'indices.h' ! in,is,iw,ie,inn,iss,iww,iee
<       include 'map.h'
<       include 'parm.h'
<       include 'vecsuv.h'   ! vecsuv info
<       include 'xyzinfo.h'  ! x,y,z,wts
<       common/uvbar/ubar(ifull,kl),vbar(ifull,kl)
<       common/work3f/nface(ifull,kl),xg(ifull,kl),yg(ifull,kl) ! depts, upglobal
<       common/work2/uc(ifull),vc(ifull),wc(ifull)
<      .            ,temp(ifull),dum(ifull,14)
<       common/work2c/x3d(ifull),y3d(ifull),z3d(ifull)   ! upglobal depts 
<       do iq=1,ifull
< c      departure point x, y, z is called x3d, y3d, z3d
< c      first find corresponding cartesian vels
<        uc(iq)=(ax(iq)*ubar(iq,k) + bx(iq)*vbar(iq,k))*dt/rearth ! unit sphere 
<        vc(iq)=(ay(iq)*ubar(iq,k) + by(iq)*vbar(iq,k))*dt/rearth ! unit sphere 
<        wc(iq)=(az(iq)*ubar(iq,k) + bz(iq)*vbar(iq,k))*dt/rearth ! unit sphere 
<        x3d(iq)=x(iq)-uc(iq)  ! 1st guess
<        y3d(iq)=y(iq)-vc(iq)
<        z3d(iq)=z(iq)-wc(iq)
<       enddo   ! iq loop
< 
< c     convert to grid point numbering
<       call toij5 (k,x3d,y3d,z3d)   ! maybe remove k dependency
<       if(ntest.eq.1)then
<         print *,'ubar,vbar ',ubar(idjd,k),vbar(idjd,k)
<         print *,'uc,vc,wc ',uc(idjd),vc(idjd),wc(idjd)
<         print *,'1st guess for k = ',k
<         print *,'x3d,y3d,z3d ',x3d(idjd),y3d(idjd),z3d(idjd)
<         print *,'xg,yg,nface ',xg(idjd,k),yg(idjd,k),nface(idjd,k)
<       endif
<       intsch=mod(ktau,2)
<       temp=uc
<       call ints(temp,intsch,nface(1,k),xg(1,k),yg(1,k),2)
<       x3d=x-.5*(uc+temp)  ! 2nd guess
<       temp=vc
<       call ints(temp,intsch,nface(1,k),xg(1,k),yg(1,k),2)
<       y3d=y-.5*(vc+temp)  ! 2nd guess
<       temp=wc
<       call ints(temp,intsch,nface(1,k),xg(1,k),yg(1,k),2)
<       z3d=z-.5*(wc+temp)  ! 2nd guess
<       
<       call toij5 (k,x3d,y3d,z3d)   ! maybe remove k dependency
<       if(ntest.eq.1)then
<         print *,'2nd guess for k = ',k
<         print *,'x3d,y3d,z3d ',x3d(idjd),y3d(idjd),z3d(idjd)
<         print *,'xg,yg,nface ',xg(idjd,k),yg(idjd,k),nface(idjd,k)
<       endif
<       temp=uc
<       call ints(temp,intsch,nface(1,k),xg(1,k),yg(1,k),2)
<       x3d=x-.5*(uc+temp)  ! 3rd guess
<       temp=vc
<       call ints(temp,intsch,nface(1,k),xg(1,k),yg(1,k),2)
<       y3d=y-.5*(vc+temp)  ! 3rd guess
<       temp=wc
<       call ints(temp,intsch,nface(1,k),xg(1,k),yg(1,k),2)
<       z3d=z-.5*(wc+temp)  ! 3rd guess
< 
<       call toij5 (k,x3d,y3d,z3d)   ! maybe remove k dependency
<       if(ntest.eq.1)then
<         print *,'3rd guess for k = ',k
<         print *,'x3d,y3d,z3d ',x3d(idjd),y3d(idjd),z3d(idjd)
<         print *,'xg,yg,nface ',xg(idjd,k),yg(idjd,k),nface(idjd,k)
<       endif
< 
<       return
<       end
< 
75d2
<       parameter (ntest=0)      
84,87c11,16
<       common/work3f/nface(ifull,kl),xg(ifull,kl),yg(ifull,kl) ! depts, upglobal
<       common/work2/gx(ifull),gy(ifull),gz(ifull)
<      .            ,derx(ifull),dery(ifull),derz(ifull),dum(ifull,12)
<       common/work2c/x3d(ifull),y3d(ifull),z3d(ifull)   ! upglobal depts 
---
>       common/work3/nface(ifull,kl),xg(ifull,kl),yg(ifull,kl) ! depts, upglobal
>      .             ,dum3(ifull,kl)
>       common/work2/x3d(ifull),y3d(ifull),z3d(ifull)
>      .            ,gx(ifull),gy(ifull),gz(ifull)
>      .            ,derx(ifull),dery(ifull),derz(ifull)
>      .            ,dum(ifull,9)
89,92d17
<       if(ntest.eq.1)then
<         print *,'entering depts for k = ',k
<         print *,'ubar,vbar ',ubar(idjd,k),vbar(idjd,k)
<       endif
110,114c35,39
<        if(ntest.eq.1)then
<          print *,'itn,x3d,y3d,z3d,u,v: ',1,x3d(idjd),y3d(idjd),z3d(idjd)
<      .          ,ubar(idjd,k),vbar(idjd,k)
<          print *,'x,ax,bx,derx: ',x(idjd),ax(idjd),bx(idjd),derx(idjd)
<        endif
---
> c      if(diag)then
> c        print *,'itn,x3d,y3d,z3d,u,v: ',1,x3d(idjd),y3d(idjd),z3d(idjd)
> c    .          ,ubar(idjd,nlv),vbar(idjd,nlv)
> c        print *,'x,ax,bx,derx: ',x(idjd),ax(idjd),bx(idjd),derx(idjd)
> c      endif
125c50
< *cdir nodep
---
> *        vdir nodep
162,163c87,88
<       if(npanels.eq.5) call toij5 (k,x3d,y3d,z3d)   ! maybe remove k dependency
<       if(npanels.eq.13)call toij13(k,x3d,y3d,z3d)   ! maybe remove k dependency
---
>       if(npanels.eq.5) call toij5 (k)   ! maybe later remove k dependency
>       if(npanels.eq.13)call toij13(k)   ! maybe later remove k dependency
165,169d89
<       if(ntest.eq.1)then
<         print *,'at end of depts for k = ',k
<         print *,'x3d,y3d,z3d ',x3d(idjd),y3d(idjd),z3d(idjd)
<         print *,'xg,yg,nface ',xg(idjd,k),yg(idjd,k),nface(idjd,k)
<       endif
178c98
<       subroutine toij5(k,x3d,y3d,z3d)
---
>       subroutine toij5(k)
181d100
<       parameter (ntest=0)
185,187c104,109
<       common/work3f/nface(ifull,kl),xg(ifull,kl),yg(ifull,kl) ! depts, upglobal
<       real x3d(ifull),y3d(ifull),z3d(ifull)
<       common/work2b/xstr(ifull),ystr(ifull),zstr(ifull)
---
>       common/work3/nface(ifull,kl),xg(ifull,kl),yg(ifull,kl) ! depts, upglobal
>      .             ,dum3(ifull,kl)
>       common/work2/x3d(ifull),y3d(ifull),z3d(ifull)
>      .            ,gx(ifull),gy(ifull),gz(ifull)
>      .            ,derx(ifull),dery(ifull),derz(ifull)
>      .            ,xstr(ifull),ystr(ifull),zstr(ifull),dum(ifull,6)
193,206c115
<       data nmaploop/3/,ndiag/0/,num/0/
<       save num
<       if(num.eq.0.and.ncray.eq.0)then  ! check if divide by itself is working
< 	do iq=1,100
< 	 xstr(iq)=-1.+.0002*iq
< 	 ystr(iq)=min(abs(xstr(iq)),4.)
< 	 zstr(iq)=xstr(iq)/ystr(iq)
< 	enddo 
< 	do iq=1,100
< !       print *,'iq,xstr,ystr,zstr ',iq,xstr(iq),ystr(iq),zstr(iq)
< 	 if(zstr(iq).ne.-1.)stop 'must use ncray=1 on this PC'
< 	enddo     
<        num=1
<       endif
---
>       data nmaploop/3/,ndiag/0/
239c148
<           if(abs(xstr(iq)).eq.denxyz)then         ! Cray
---
>           if(abs(xstr(iq)).eq.denxyz)then        ! Cray
244c153
<             else                                  ! Cray
---
>             else                                ! Cray
281,296c190
<        enddo   ! iq loop   
< 	if(ntest.eq.1)then
< 	 iq=idjd
<         denxyz=max( abs(xstr(iq)),abs(ystr(iq)),abs(zstr(iq)) )
<         xd=xstr(iq)/denxyz
<         yd=ystr(iq)/denxyz
<         zd=zstr(iq)/denxyz
< 	 print *,'xstr,ystr,zstr,denxyz ',
<      .           xstr(iq),ystr(iq),zstr(iq),denxyz
<         write(6,'("xstr,ystr,zstr = ",3z20)') xstr(iq),ystr(iq),zstr(iq)
<         write(6,'("denxyz = ",z20)') denxyz
<         write(6,'("xd,yd,zd = ",3z20)') xd,yd,zd
< 	 print *,'abs(xstr,ystr,zstr) ',
<      .           abs(xstr(iq)),abs(ystr(iq)),abs(zstr(iq))
< 	 print *,'xd,yd,zd,nf ',xd,yd,zd,nf
<        endif
---
>        enddo   ! iq loop
335c229
<       subroutine toij13(k,x3d,y3d,z3d)  ! no Schmidt
---
>       subroutine toij13(k)
339,340c233,238
<       common/work3f/nface(ifull,kl),xg(ifull,kl),yg(ifull,kl) ! depts, upglobal
<       real x3d(ifull),y3d(ifull),z3d(ifull)
---
>       common/work3/nface(ifull,kl),xg(ifull,kl),yg(ifull,kl) ! depts, upglobal
>      .             ,dum3(ifull,kl)
>       common/work2/x3d(ifull),y3d(ifull),z3d(ifull)
>      .            ,gx(ifull),gy(ifull),gz(ifull)
>      .            ,derx(ifull),dery(ifull),derz(ifull)
>      .            ,dum(ifull,9)
=====================================
 
drive.f
=====================================
1a2,4
> c Revision 1.1.1.1  2002/12/18 23:02:17  dix043
> c Source imported from farrer:~cslm/ccam
> c
=====================================
 
e1e288.f
=====================================
41c41
<       parameter (ndum=5*ijk- imax*(ll3p*5 +11*lp1 +4*llp1 +2)) !jlm
---
>       parameter (ndum=4*ijk- imax*(ll3p*5 +11*lp1 +4*llp1 +2)) !jlm
=====================================
 
e3v88.f
=====================================
21c21
<       parameter (ndum=5*ijk- 10*imax*llp1) !jlm
---
>       parameter (ndum=4*ijk- 10*imax*llp1) !jlm
=====================================
 
esbda.f
=====================================
1a2,4
> c Revision 1.1.1.1  2002/12/18 23:02:17  dix043
> c Source imported from farrer:~cslm/ccam
> c
=====================================
 
esibda.f
=====================================
=====================================
 
establ.f
=====================================
1a2,4
> c Revision 1.1.1.1  2002/12/18 23:02:17  dix043
> c Source imported from farrer:~cslm/ccam
> c
=====================================
 
extractd.f
=====================================
=====================================
 
extras.f
=====================================
1a2,4
> c Revision 1.1.1.1  2002/12/18 23:02:17  dix043
> c Source imported from farrer:~cslm/ccam
> c
=====================================
 
findij.f
=====================================
=====================================
 
findll.f
=====================================
=====================================
 
findnear.f
=====================================
=====================================
 
fst88.f
=====================================
80c80
<       parameter (ndum=5*ijk- imax*(2*llp1 +8*lp1 +l +lp1m +8)) !jlm
---
>       parameter (ndum=4*ijk- imax*(2*llp1 +8*lp1 +l +lp1m +8)) !jlm
=====================================
 
getcoords.f
=====================================
=====================================
 
gettin.f
=====================================
10,11c10,15
<         savt(:,:)=t(:,:)
<         savpsl(:)=psl(:)
---
>         do kq=1,ijk
>          savt(kq,1)=t(kq,1)
>         enddo
>         do iq=1,ifull
>          savpsl(iq)=psl(iq)
>         enddo
13,14c17,22
<         t(:,:)=savt(:,:)   ! for n=1, n=2
<         psl(:)=savpsl(:)   ! for n=1, n=2
---
>         do kq=1,ijk
>          t(kq,1)=savt(kq,1)   ! for n=1, n=2
>         enddo
>         do iq=1,ifull
>          psl(iq)=savpsl(iq)   ! for n=1, n=2
>         enddo
19,20c27,30
<         u(:,:)=savu(:,:)  ! only for n=2 (VMI init)
<         v(:,:)=savv(:,:)
---
>         do kq=1,ijk
>          u(kq,1)=savu(kq,1)  ! only for n=2 (VMI init)
>          v(kq,1)=savv(kq,1)
>         enddo
=====================================
 
globpe.f
=====================================
1c1
<        Program globpe  
---
>        Program globpe  ! globpex version
3c3,4
< !      N.B. on a Cray, set ncray=1 in depts.f, latltoij
---
> c      sometime, can equivalence rtt & tn
> !      N.B. on a Cray, set ncray=1 in depts.f
15a17
> ! *   include 'astro.h'
24,25c26
<       include 'liqwpar.h'  ! ifullw
<       include 'map.h'      ! em, f, dpsldt, fu, fv, etc
---
>       include 'map.h'     ! em, f, dpsldt, fu, fv, etc
28c29
<       include 'nsibd.h'    ! sib, tsigmf, isoilm
---
>       include 'nsibd.h'   ! sib, tsigmf, isoilm
30,31c31,32
<       include 'parmdyn.h'  
<       include 'parmhor.h'  ! mhint, m_bs, mh_bs, nt_adv, ndept
---
>       include 'parmdyn.h'  ! morder,ntomg
>       include 'parmhor.h'  ! mhint, m_bs, morder, nt_adv
51c52
<      .    epot_ave(ifull),cbas_ave(ifull),ctop_ave(ifull),
---
>      .    epot_ave(ifull),
57,59c58,59
<      &               rgn_ave (ifull), rgc_ave (ifull), cld_ave (ifull), 
<      &               cll_ave (ifull), clm_ave (ifull), clh_ave (ifull), 
<      &               koundiag
---
>      &               rgn_ave (ifull), cld_ave (ifull), cll_ave (ifull),
>      &               clm_ave (ifull), clh_ave (ifull), koundiag
68c68
<      . ,factch(ifull),qsttg(ifull),rho(ifull),zo(ifull)
---
>      . ,factch(ifull),rsts(ifull),rho(ifull),zo(ifull)
75,76c75
<      . dum3(2*ijk-16*ifull),dum3a(ifull,kl),speed(ifull,kl),
<      . spare(ifull,kl)          
---
>      . dum3(2*ijk-16*ifull),dum3a(ifull,kl),speed(ifull,kl)
79,80d77
<       common/work3d/rtt(ifull,kl) ! just to pass between radriv90 & globpe
<       common/work3f/cfrac(ifull,kl),dum3f(ifull,kl,2) ! globpe,leoncld,radriv90
88c85
<       character comm*60,comment*60,rundate*10,header*47,text*2
---
>       character comment*60,rundate*10,header*47,text*2
90c87
<      1 ,ia,ib,ja,jb,iaero,khdif,khor
---
>      1 ,ia,ib,ja,jb,iaero,khdif,khor,kstart
92c89
<      3 ,nmaxpr,nmi,nmidiab,nonl,nrot,nps,nqg,nrad,nsd,ntsea
---
>      3 ,nmaxpr,nmi,nmidiab,nonl,nrot,nps,nqg,nqq,nrad,nsd,ntsea
95,98c92,95
<      6 ,lgwd,ngwd,kscreen,rhsat,sigcb
<      7 ,nextout,hdifmax,jalbfix
<      . ,nalpha,ndifbd,nqg_set
<      . ,nstag,nstagu,ntbar,nwt0,nwrite
---
>      6 ,lgwd,ngwd,nvadq,nvadt,kscreen,rhsat,sigcb,nzero
>      7 ,aleadfr,nextout,hdifmax,jalbfix
>      . ,morder,morder_r,mst_bs,mstu_bs,nalpha,ndifbd,nqg_set
>      . ,nstag,nstagu,ntbar,nunst,nuv,nwt0,nwrite
100,103c97,100
<      . ,nrungcm,nsib,slat,slon,iunp,slat2,slon2,iunp2,comment
<      . ,mexrest,ndept,nritch,nritch_t,nt_adv
<      . ,mfix,mfix_qg,namip,nhstest,nspecial
<      . ,newsnow,nsnowout,newsoilm,nglacier,newztsea
---
>      . ,nrungcm,nsib,slat,slon,iunp,slat2,slon2,iunp2,comment,nhstest
>      . ,mexrest,nritch,nritch_t,nt_adv
>      . ,namip,mfix,mfix_qg
>      . ,newsnow,nsiceup,nsnowout,newsoilm,nstabchk,newztsea
109,111c106,108
<      . ,io_clim ,io_in,io_nest,io_out,io_rest,io_spec,nfly             
<       data npc/40/,nmi/0/,io_nest/1/,iaero/0/ 
<       namelist/skyin/kountr,mins_rad,ndiur  ! kountr not used from here
---
>      . ,io_clim ,io_in,io_nest     ,io_out    ,io_rest   ,io_spec             ! freq
>       data npc/40/,nmi/0/,nrad/4/,io_nest/1/,iaero/0/ 
>       namelist/skyin/day,hourst,ndiur,kountr,albedo
126c123
<      .        ,sigkscb,sigksct,tied_con,tied_over,tied_rh,comm
---
>      .        ,sigkscb,sigksct,tied_con,tied_over,tied_rh
128c125
<       data kscreen/0/
---
>       data kscreen/0/,ndi/1/,ndi2/0/
130,132c127,129
<       data comment/' '/,comm/' '/,irest/0/,jalbfix/0/,nalpha/1/
<       data mexrest/6/,mins_rad/120/
<       data nwt0/0/,nwrite/0/
---
>       data irest/0/,jalbfix/0/,nalpha/1/
>       data mexrest/6/,nzero/24/
>       data nwt0/0/,nwrite/0/,nscrn3hr/0/
146,148c143,144
<       nperday =nint(24.*3600./dt)
<       if(nwt.eq.-99)nwt=nperday      ! set default nwt to 24 hours
<       if(nwrite.eq.0)nwrite=nperday  ! only used for outfile IEEE
---
>       if(nwt.eq.-99)nwt=nint(.5*86400./dt) ! set default nwt to 12 hours
>       if(nwrite.eq.0)nwrite=nint(86400./dt) ! set default nwrite to 24 hours
150,151c146
< !     if(kountr.eq.-99)kountr=7200./dt  ! set default radiation to < ~2 hours
<       kountr=mins_rad*60./dt  ! set default radiation to < ~2 hours
---
>       if(kountr.eq.-99)kountr=7200./dt  ! set default radiation to < ~2 hours
154c149
<       
---
> 
156,157c151,154
<       print *,'   m    mfix  mfix_qg  mup    nonl   nrot'
<       write (6,'(i5,8i7)')m,mfix,mfix_qg,mup,nonl,nrot
---
>       print *,'   m    mfix mfix_qg morder morder_r mup   nonl   nrot',
>      .        ' nstabchk'
>       write (6,'(i5,8i7)')m,mfix,mfix_qg,morder,morder_r,mup,nonl,nrot,
>      .          nstabchk
159,160c156,157
<       print *,'nritch nritch_t ntbar epsp   epsu   epsf '
<       write (6,'(i5,2i7,1x,4f7.3)')nritch,nritch_t,ntbar,
---
>       print *,'nritch nritch_t ntomg ntbar epsp   epsu   epsf '
>       write (6,'(i5,3i7,4f7.3)')nritch,nritch_t,ntomg,ntbar,
162d158
<       if(nritch.ge.404)nt_adv=nritch-400  ! for compatibility to nritch=407
164,165c160,161
<       print *,' ndept  nt_adv  m_bs  mh_bs  mhint '
<       write (6,'(i5,11i7)') ndept,nt_adv,m_bs,mh_bs,mhint
---
>       print *,' nt_adv  m_bs  mhint '
>       write (6,'(i5,11i7)') nt_adv,m_bs,mhint
167,168c163,165
<       print *,'mstagpt nstag nstagu'
<       write (6,'(i5,11i7)') mstagpt,nstag,nstagu
---
>       print *,'mstagpt nstag nstagu mst_bs mstu_bs nuv'
>       write (6,'(i5,11i7)') mstagpt,nstag,nstagu,mst_bs,mstu_bs,nuv
>       nspec_us=0   ! just default value for staguv
170,171c167,168
<       print *,'  nvad  nvadh  '
<       write (6,'(i5,11i7)') nvad,nvadh
---
>       print *,'  nqq   nvad   nvadh  '
>       write (6,'(i5,11i7)') nqq,nvad,nvadh
175a173,176
>       else
>         print *,'Vertical advection options for Vadv30 or L_W:'
>         print *,' n_bs   ntop   nvdep  nvint'
>         write (6,'(i5,11i7)') n_bs,ntop,nvdep,nvint
178c179
<       print *,' khdif  khor   nhor   nhorps'
---
>       print *,' khdif  khor  nhor   nhorps'
201c202
<       print *,'  ksc  kscsea ifullw sigkscb sigksct ',
---
>       print *,'  ksc  kscsea sigkscb sigksct ',
203c204
<       write (6,'(i5,2i7,1x,3f8.3,2f10.3,e10.2)')  ksc,kscsea,ifullw,
---
>       write (6,'(i5,i7,1x,3f8.3,2f10.3,e10.2)')  ksc,kscsea,
205,207d205
<       print *,'Radiation options:'
<       print *,' nrad  ndiur mins_rad kountr'
<       write (6,'(i5,5i7)') nrad,ndiur,mins_rad,kountr
211c209
<       print *,'Soil, canopy and PBL options A:'
---
>       print *,'Soil, canopy and PBL options:'
217,220d214
<       print *,'Soil, canopy and PBL options B:'
<       print *,' nglacier'
<       write (6,'(i5,7i7,5x,3f7.2)')
<      .          nglacier
228,234d221
<       print *,'Special and test options:'
<       print *,' namip nhstest nspecial'
<       write (6,'(i5,7i7)') namip,nhstest,nspecial 
<       print *,'I/O options:'
<       print *,' nfly  io_in io_nest io_out io_rest nwt'
<       write (6,'(i5,7i7)') 
<      .          nfly,io_in,io_nest,io_out,io_rest,nwt
251c238
<       ktau=0
---
>       ktau=kstart-1
264d250
< !     N.B. to display orog alone, run with io_in=4, nbd=0, nsib=0      
275a262,280
>       rtt=0.  ! 3D before radn section
>       if(nmi.ne.0)then
>         dt=min(100.,dt)
>         mex=1
>         nhor=0
>         nkuo=0
> !       nqg value gets overridden in indata
>         nrad=0   ! turns off radiation schemes
>         if(ntau.gt.10)ntau=4
>         ntsea=0   ! Mon  11-22-1993
>         ntsur=0
>         nvmix=0
>         ofile=nmifile
>         if(nmidiab.eq.1)then
>           call readreal('nmidiab.fil',rtt,il*jl)
>           print *,'diabatic heating rates read in, e.g. ',
>      .            (rtt(idjd,kl/2),jj=1,jl)
>         endif
>       endif
303,305c308,314
<       wb(:,:)=.15
<       snowd(:)=0.
<       condx(:)=0.
---
>       wb=.15
>       snowd=0.
>       condx=0.
> !     if(ntau+2-kstart.gt.12001)then                    ! disabled in globpe
>         print *,'ntau too big for psa,psm array size'   ! disabled in globpe
> !       stop                                            ! disabled in globpe
> !     endif                                             ! disabled in globpe
308a318,322
> !     for ntsea=2 option, read in initial sea ice depth
> !     if(ntsea.eq.2) then
> !       read(18,*) sicedep
> !     end if
> 
313d326
<       
336,339d348
< 	    if(ier.ne.0)then
< 	      print *,'cannot open netcdf mesofile ',nf_strerror(ier)
< 	      stop
< 	    endif
362a372
>       kstart=1  ! these days
395a406,407
>       psa(npsav)=ps(idjd)
>       psm(npsav)=ps(idjd+1)
420,422d431
<       cbas_ave=0.
<       ctop_ave=0.
<       sno=0.
432d440
<       rgc_ave  = 0.  ! LW_ground (clear sky)
440,441c448,450
<         call outfile(20,il,jl,kl,psa,psm,rundate,nmi,nsnowout,nwrite)
<       endif    ! (nmi.eq.0.and.nwt.ne.0)
---
>         call outfile(20,il,jl,kl,psa,psm,rundate,nmi,nsnowout,
>      .               nwrite,nrad)
>       endif    ! (nmi.eq.0.and.kstart.eq.1.and.nwt.ne.0)
443,449c452,456
<       nper3hr =nint( 3.*3600./dt)
<       nper6hr =nint( 6.*3600./dt)
<       nper9hr =nint( 9.*3600./dt)
<       nper12hr=nint(12.*3600./dt)
<       nper15hr=nint(15.*3600./dt)
<       nper18hr=nint(18.*3600./dt)
<       nper21hr=nint(21.*3600./dt)
---
>       nperday=nint(24.*3600./dt)
>       nper3hr=nint( 3.*3600./dt)
>       nper6hr=nint( 6.*3600./dt)
>       nper12hr=nint( 12.*3600./dt)
>       nper18hr=nint( 18.*3600./dt)
451a459
>       npreczer=nint(nzero*3600./dt)
452a461,462
>       print *,'precip zeroed every ',nzero,
>      .        ' hours with npreczer = ',npreczer
471c481
<       do 88 kktau=1,ntau   ! ****** start of main time loop
---
>       do 88 kktau=kstart,ntau   ! ****** start of main time loop
477a488,490
>       if(nhstest.eq.-1)then  ! aquaplanet test
>          mtimer=mins_gmt
>       endif    ! (nhstest.eq.-1)
492,494c505,508
< !       this sets to ktau=1.5 values on 2nd time through
<         ubar(:,:)=u(:,:)
<         vbar(:,:)=v(:,:)
---
>         do kq=1,ijk         ! this sets to ktau=1.5 values on 2nd time through
>          ubar(kq,1)=u(kq,1)
>          vbar(kq,1)=v(kq,1)
>         enddo
496,497c510,513
<         ubar(:,:)=u(:,:)
<         vbar(:,:)=v(:,:)
---
>         do kq=1,ijk             
>          ubar(kq,1)=u(kq,1)
>          vbar(kq,1)=v(kq,1)
>         enddo
499,501c515,518
< !       (tau+.5) from tau, tau-1
<         ubar(:,:)=u(:,:)*1.5-savu(:,:)*.5
<         vbar(:,:)=v(:,:)*1.5-savv(:,:)*.5
---
>         do kq=1,ijk           ! (tau+.5) from tau, tau-1
>          ubar(kq,1)=u(kq,1)*1.5-savu(kq,1)*.5
>          vbar(kq,1)=v(kq,1)*1.5-savv(kq,1)*.5
>         enddo          
503,507c520,525
< !       (tau+.5) from tau, tau-1, tau-2
<         ubar(:,:)=u(:,:)*15./8.-savu(:,:)*10./8.
<      .                             +ubar(:,:)*3./8. ! ubar is savu1 here
<         vbar(:,:)=v(:,:)*15./8.-savv(:,:)*10./8.
<      .                             +vbar(:,:)*3./8. ! vbar is savv1 here
---
>         do kq=1,ijk           ! (tau+.5) from tau, tau-1, tau-2
>          ubar(kq,1)=u(kq,1)*15./8.-savu(kq,1)*10./8.
>      .                              +ubar(kq,1)*3./8. ! ubar is savu1 here
>          vbar(kq,1)=v(kq,1)*15./8.-savv(kq,1)*10./8.
>      .                              +vbar(kq,1)*3./8. ! vbar is savv1 here
>         enddo
513,514c531,534
<         u(:,:)=savu(:,:)  ! reset u,v to original values
<         v(:,:)=savv(:,:)
---
>         do kq=1,ijk            ! reset u,v to original values
>          u(kq,1)=savu(kq,1)
>          v(kq,1)=savv(kq,1)
>         enddo
516,519c536,541
<       savu1(:,:)=savu(:,:)  
<       savv1(:,:)=savv(:,:)
<       savu(:,:) =u(:,:)  ! before any time-splitting occurs
<       savv(:,:) =v(:,:)
---
>       do kq=1,ijk
>        savu1(kq,1)=savu(kq,1)  
>        savv1(kq,1)=savv(kq,1)
>        savu(kq,1) =u(kq,1)  ! before any time-splitting occurs
>        savv(kq,1) =v(kq,1)
>       enddo
526,593c548,552
<         if(ktau.eq.ktau/ndi*ndi)diag=.true.
<       endif
<       if(ngas.ge.1)then ! re-set trsav prior to vadv, hadv, hordif
< !       N.B. nllp arrays are after gas arrays
<         do igas=1,ngas
< 	  do k=1,klt
< 	   do iq=1,ilt*jlt	 
<            trsav(iq,k,igas)=tr(iq,k,igas) ! 4D for tr conservation in adjust5
< 	   enddo
< 	  enddo
< 	 enddo
<       endif      ! (ngas.ge.1)
< 
<       call nonlin
<       if(diag)then
<         print *,'before hadv'
<         call printa('tx  ',tx(1,nlv),ktau,nlv,ia,ib,ja,jb,200.,1.)
<         write (6,"('tx  ',9f8.2)") (tx(idjd,k),k=nlv,nlv+8)
<         write (6,"('txe ',9f8.2)") (tx(ie(idjd),k),k=nlv,nlv+8)
<         write (6,"('txw ',9f8.2)") (tx(iw(idjd),k),k=nlv,nlv+8)
<         write (6,"('txn ',9f8.2)") (tx(in(idjd),k),k=nlv,nlv+8)
<         write (6,"('txs ',9f8.2)") (tx(is(idjd),k),k=nlv,nlv+8)
<         write(6,'(i2," qgv ",18f7.4)')ktau,(1000.*qg(idjd,k),k=1,kl)
<         call printa('qgv ',qg(1,nlv),ktau,nlv,ia,ib,ja,jb,0.,1.e3)
<       endif
< 
< !     evaluate horizontal advection for combined quantities
<       call upglobal
<       if(diag)then
<         print *,'after hadv'
<         write (6,"('tx  ',9f8.2)") (tx(idjd,k),k=nlv,nlv+8)
<         call printa('tx  ',tx(1,nlv),ktau,nlv,ia,ib,ja,jb,200.,1.)
<         write(6,'(i2," qgh ",18f7.4)')ktau,(1000.*qg(idjd,k),k=1,kl)
<       endif
< 
<       if(nonl.lt.0)then
<         savt(:,:)=t(:,:)  ! can be used in nonlin during next step
<       endif
< 
<       ubar=savu1  ! 3D really saving savu1 in ubar here 
<       vbar=savv1  ! 3D really saving savv1 in vbar here 
< 
<       call adjust5
< 
<       if(mspec.eq.2)then     ! for very first step restore mass & T fields
<         call gettin(1)
<       endif    !  (mspec.eq.2) 
<       if(mfix_qg.eq.0.or.mspec.eq.2)then
<         qg(:,:)=max(qg(:,:),qgmin)  ! guided by McCormick et al 1993 
<       endif  ! (mfix_qg.eq.0.or.mspec.eq.2)
< 79    dt=dtin                    ! ****** end of introductory time loop
<       mspeca=1
< 
<       if(nhor.lt.0)call hordifgt  ! now not tendencies
<       if(diag)print *,'after hordifgt t ',(t(idjd,k),k=1,kl)
<       if(ngwd.lt.0)call gwdrag  ! <0 for split
<       if(nkuo.eq.23)call convjlm     ! split convjlm 
<       cbas_ave(:)=cbas_ave(:)+condc(:)*(1.1-sig(kbsav(:))) ! diagnostic
<       ctop_ave(:)=ctop_ave(:)+condc(:)*(1.1-sig(ktsav(:))) ! diagnostic
<       if(nkuo.eq.46)call conjob    ! split Arakawa-Gordon scheme
<       if(nkuo.eq.5)call betts(t,qg,tn,land,ps) ! not called these days
< 
<       if(ifullw.eq.ifull)then
< c       print*,'Calling prognostic cloud scheme'
<         call leoncld(cfrac)  !Output
<       endif	 ! (ifullw.eq.ifull)
< 
< !       put radiation here
---
>          if(ktau.eq.ktau/ndi*ndi)diag=.true.
>       end if
>       tn=0.  ! 3D
>       if(mspec.eq.1)then   ! don't do radn on first preliminary step
> !       calculate radiation, surface temps and drag coeff arrays.
595c554
< !         Fels-Schwarzkopf radiation
---
> !         best fels-schwarzkopf radiation
598,603d556
<           if(nhstest.lt.0)then ! aquaplanet test -22  
< 	    mtimer_sav=mtimer
<            mtimer=mins_gmt     ! so radn scheme repeatedly works thru same day
<           endif    ! (nhstest.lt.0)
< c         rtt=0.   ! 3D before radn section
< c         qg(:,:)=max(qg(:,:),qgmin)  ! testing
605,610c558,560
<           if(nhstest.lt.0)then ! aquaplanet test -22  
< 	    mtimer=mtimer_sav
<           endif    ! (nhstest.lt.0)
<           t(:,:)=t(:,:)-dt*rtt(:,:) 
<           if(nmaxpr.eq.1)call maxmin(rtt,'rt',ktau,1.e4,kl)
<           if(nmaxpr.eq.1)call maxmin(slwa,'sl',ktau,.1,1)
---
>           tn=-rtt  ! 3D
>  	   egg=0.   ! 2D reset for fort.60 files
> 	   fgg=0.   ! 2D reset for fort.60 files
613c563
<           slwa(:)=-10*nrad  
---
>           slwa=-10*nrad  ! 2D
616,690c566,677
< 
<  	 egg(:)=0.   ! reset for fort.60 files
< 	 fgg(:)=0.   ! reset for fort.60 files
<         if(ntsur.eq.0.or.nhstest.eq.2)then ! Held & Suarez or no surf fluxes
<          eg(:)=0.
<          fg(:)=0.
<          cdtq(:)=0.
<          cduv(:)=0.
<         endif     ! (ntsur.eq.0.or.nhstest.eq.2) 
<         if(nhstest.eq.2)call hs_phys
<         if(ntsur.ne.0)then  ! should be better after convjlm
< 	  call sflux(nalpha,kscreen)
<          epot_ave = epot_ave+epot  ! 2D 
<          ga_ave = ga_ave+ga        ! 2D   
<          if(mstn.eq.0.and.nstn.gt.0)then ! writing station data every time step
<            coslong=cos(rlong0*pi/180.)   ! done here, where work2 has arrays
<            sinlong=sin(rlong0*pi/180.)
<            coslat=cos(rlat0*pi/180.)
<            sinlat=sin(rlat0*pi/180.)
<            polenx=-coslat
<            poleny=0.
<            polenz=sinlat
<            do nn=1,nstn
<              if(ktau.eq.1)write (iunp(nn),950) kdate,ktime
< 950          format("#",i9,i5)
<              i=istn(nn)
<              j=jstn(nn)
<              iq=i+(j-1)*il
<              zonx=            -polenz*y(iq)
<              zony=polenz*x(iq)-polenx*z(iq)
<              zonz=polenx*y(iq)
<              den=sqrt( max(zonx**2+zony**2+zonz**2,1.e-7) )  ! allow for poles
<              costh= (zonx*ax(iq)+zony*ay(iq)+zonz*az(iq))/den
<              sinth=-(zonx*bx(iq)+zony*by(iq)+zonz*bz(iq))/den
<              uzon= costh*u(iq,1)-sinth*v(iq,1)
<              vmer= sinth*u(iq,1)+costh*v(iq,1)
<              es=establ(t(iq,1))
<              rh1=100.*qg(iq,1)*(ps(iq)*sig(1)-es)/(.622*es)
<              es=establ(t(iq,2))
<              rh2=100.*qg(iq,2)*(ps(iq)*sig(2)-es)/(.622*es)
<              wbav=(zse(1)*wb(iq,1)+zse(2)*wb(iq,2)+zse(3)*wb(iq,3)
<      .        +zse(4)*wb(iq,4))/(zse(1)+zse(2)+zse(3)+zse(4))
<              write (iunp(nn),951) ktau,tscrn(iq)-273.16,precip(iq),
<      .         tss(iq)-273.16,tgg(iq,1)-273.16,tgg(iq,2)-273.16,
<      .         tgg(iq,3)-273.16,t(iq,1)-273.16,tgf(iq)-273.16,
<      .         wb(iq,1),wb(iq,2),
<      .         cloudlo(iq),cloudmi(iq)+1.,cloudhi(iq)+2.,
<      .         cloudtot(iq)+3.,
<      .         fg(iq),eg(iq),(1.-tsigmf(iq))*fgg(iq),
<      .         (1.-tsigmf(iq))*egg(iq),rnet(iq),sgsave(iq),
<      .         qg(iq,1)*1.e3,uzon,vmer,precc(iq),
<      .         qg(iq,2)*1.e3,rh1,rh2,tr(iq,1,ico2),tr(iq,2,ico2),
<      .         tr(iq,1,iradon),tr(iq,2,iradon) ,.01*ps(iq),wbav
< 951          format(i4,8f7.2, 2f6.3, 4f5.2, 5f7.1,f6.1,
<      .              f5.1,2f6.1,f7.2, f5.1,2f6.1, 4(1x,f5.1) ,f7.1,f6.3)
<              if(ktau.eq.ntau)then
<                write (iunp(nn),952)
< 952            format("#   tscrn  precip  tss   tgg1   tgg2   tgg3",
<      .       "    t1     tgf    wb1   wb2 cldl cldm cldh  cld",
<      .       "     fg     eg    fgg    egg    rnet   sg   qg1   uu",
<      .       "     vv   precc  qg2  rh1   rh2  co2_1 co2_2",
<      .       " rad_1 rad_2   ps   wbav")
<                isoil=isoilm(iq)
<                write (iunp(nn),953) land(iq),isoil,ivegt(iq),zo(iq),
<      .                              zs(iq)/9.806
< 953            format("# land,isoilm,ivegt,zo,zs/g: ",l2,2i3,2f9.3)
<                write (iunp(nn),954) sigmf(iq),swilt(isoil),sfc(isoil),
<      .                              ssat(isoil),alb(iq)
< 954            format("#sigmf,swilt,sfc,ssat,alb: ",5f7.3)
<                write (iunp(nn),955) i,j,ico2em(iq),radonem(iq)
< 955            format("#i,j,ico2em,radonem: ",2i4,i6,f7.3)
<              endif
<            enddo
<          endif   ! (mstn.eq.0.and.nstn.gt.0)
<          if(mod(ktau,nmaxpr).eq.0)then
---
>         if(diag)print *,'after radrive tn*dt ',(tn(idjd,k)*dt,k=1,kl)
>         if(diag)print *,ktau,' ps,qg ',ps(idjd),(qg(idjd,k),k=1,kl)
>         if(ngas.ge.1)then ! re-set trsav prior to vadv, hadv, hordif
>           trsav(kq,1,ng)=tr(kq,1,ng) ! 3D for tr conservation in adjust5
>         endif      ! (ngas.ge.1)
> 
> !       call the cumulus convection scheme (with changes via tn)
> !!      write(6,'(i2," qg0 ",18f7.4)')ktau,(1000.*qg(idjd,k),k=1,kl)
>         if(abs(nkuo).eq.22)call convjlm    ! jlm convection scheme
>         if(nkuo.eq.44)call conjob          ! Arakawa-Gordon scheme
>         if(nkuo.eq.5)call betts(t,qg,tn,land,ps)
>         if(nvsplit.eq.2)then   ! split all physics
>           t=t+dt*tn ! 3D
>           tn=0.! 3D
>         endif    !  (nvsplit.eq.2)
>         if(nvad.eq.44)then 
>           if(diag.or.nmaxpr.eq.1)then
>             print *,'before nvad=44 vertical advection in globpe'
>             write (6,"('t_gl1(1-9)   ',9f8.2)") (t(idjd,k),k=1,9)
>             write (6,"('qg ',19f7.3/(8x,19f7.3))") 
>      .                 (1000.*qg(idjd,k),k=1,kl)
>           endif
>           if(nvadh.le.2)then
>             call vadvtvd(t,t,u,u,v,v)
>           else
>             do ncall=1,nvadh
>              call vadvtvd(t,t,u,u,v,v)
>             enddo
>           endif  
>           if(diag.or.nmaxpr.eq.1)then
>             print *,'after vertical advection in globpe'
>             write (6,"('t_gl2(1-9)   ',9f8.2)") (t(idjd,k),k=1,9)
>             write (6,"('qg ',19f7.3/(8x,19f7.3))") 
>      .                 (1000.*qg(idjd,k),k=1,kl)
>             write (6,"('thet        ',9f8.2)") 
>      .                 (t(idjd,k)*sig(k)**(-roncp),k=1,9)
>           endif
>         endif   ! (nvad.eq.44)
>         if(ntsur.le.3.or.nhstest.eq.2) then ! Held & Suarez or no surf fluxes
>           do iq=1,ifull
>            eg(iq)=0.
>            fg(iq)=0.
>            cdtq(iq)=0.
>            cduv(iq)=0.
>           enddo
>         else   ! usual runs with ntsur>3
>           call sflux(nalpha,kscreen)
>           epot_ave = epot_ave+epot  ! 2D 
>           ga_ave = ga_ave+ga        ! 2D   
>           if(mstn.eq.0.and.nstn.gt.0)then ! writing station data every time step
>             coslong=cos(rlong0*pi/180.)   ! done here, where work2 has arrays
>             sinlong=sin(rlong0*pi/180.)
>             coslat=cos(rlat0*pi/180.)
>             sinlat=sin(rlat0*pi/180.)
>             polenx=-coslat
>             poleny=0.
>             polenz=sinlat
>             do nn=1,nstn
>               if(ktau.eq.1)write (iunp(nn),950) kdate,ktime
> 950           format("#",i9,i5)
>               i=istn(nn)
>               j=jstn(nn)
>               iq=i+(j-1)*il
>               zonx=            -polenz*y(iq)
>               zony=polenz*x(iq)-polenx*z(iq)
>               zonz=polenx*y(iq)
>               den=sqrt( max(zonx**2+zony**2+zonz**2,1.e-7) )  ! allow for poles
>               costh= (zonx*ax(iq)+zony*ay(iq)+zonz*az(iq))/den
>               sinth=-(zonx*bx(iq)+zony*by(iq)+zonz*bz(iq))/den
>               uzon= costh*u(iq,1)-sinth*v(iq,1)
>               vmer= sinth*u(iq,1)+costh*v(iq,1)
>               es=establ(t(iq,1))
>               rh1=100.*qg(iq,1)*(ps(iq)*sig(1)-es)/(.622*es)
>               es=establ(t(iq,2))
>               rh2=100.*qg(iq,2)*(ps(iq)*sig(2)-es)/(.622*es)
>               wbav=(zse(1)*wb(iq,1)+zse(2)*wb(iq,2)+zse(3)*wb(iq,3)
>      .         +zse(4)*wb(iq,4))/(zse(1)+zse(2)+zse(3)+zse(4))
>               write (iunp(nn),951) ktau,tscrn(iq)-273.16,precip(iq),
>      .          tss(iq)-273.16,tgg(iq,1)-273.16,tgg(iq,2)-273.16,
>      .          tgg(iq,3)-273.16,t(iq,1)-273.16,tgf(iq)-273.16,
>      .          wb(iq,1),wb(iq,2),
>      .          cloudlo(iq),cloudmi(iq)+1.,cloudhi(iq)+2.,
>      .          cloudtot(iq)+3.,
>      .          fg(iq),eg(iq),(1.-tsigmf(iq))*fgg(iq),
>      .          (1.-tsigmf(iq))*egg(iq),rnet(iq),sgsave(iq),
>      .          qg(iq,1)*1.e3,uzon,vmer,precc(iq),
>      .          qg(iq,2)*1.e3,rh1,rh2,tr(iq,1,ico2),tr(iq,2,ico2),
>      .          tr(iq,1,iradon),tr(iq,2,iradon) ,.01*ps(iq),wbav
> 951           format(i4,8f7.2, 2f6.3, 4f5.2, 5f7.1,f6.1,
>      .               f5.1,2f6.1,f7.2, f5.1,2f6.1, 4(1x,f5.1) ,f7.1,f6.3)
>               if(ktau.eq.ntau)then
>                 write (iunp(nn),952)
> 952             format("#   tscrn  precip  tss   tgg1   tgg2   tgg3",
>      .        "    t1     tgf    wb1   wb2 cldl cldm cldh  cld",
>      .        "     fg     eg    fgg    egg    rnet   sg   qg1   uu",
>      .        "     vv   precc  qg2  rh1   rh2  co2_1 co2_2",
>      .        " rad_1 rad_2   ps   wbav")
>                 isoil=isoilm(iq)
>                 write (iunp(nn),953) land(iq),isoil,ivegt(iq),zo(iq),
>      .                               zs(iq)/9.806
> 953             format("# land,isoilm,ivegt,zo,zs/g: ",l2,2i3,2f9.3)
>                 write (iunp(nn),954) sigmf(iq),swilt(isoil),sfc(isoil),
>      .                               ssat(isoil),alb(iq)
> 954             format("#sigmf,swilt,sfc,ssat,alb: ",5f7.3)
>                 write (iunp(nn),955) i,j,ico2em(iq),radonem(iq)
> 955             format("#i,j,ico2em,radonem: ",2i4,i6,f7.3)
>               endif
>             enddo
>           endif   ! (mstn.eq.0.and.nstn.gt.0)
>         endif     ! (ntsur.le.3.or.nhstest.eq.2) .. else ..
>  
>         if(mod(ktau,nmaxpr).eq.0)then
735c722
<           write (6,"('zo,cduv,wetfac,sno,precc,precip',2f8.5,4f8.2)")
---
>           write (6,"('zo,cduv,wetfac,precc,precip',2f8.5,3f8.2)")
737c724
<      .     sno(idjd),precc(idjd),precip(idjd)
---
>      .     precc(idjd),precip(idjd)
750a738,745
> c          write (6,"('t_a ',9f8.2)") (t(idjd,k),k=10,18)
> c          write (6,"('t_b ',9f8.2)") (t(idjd,k),k=1,9)
> c          write (6,"('u_a ',9f8.2)") (u(idjd,k),k=10,18)
> c          write (6,"('u_b ',9f8.2)") (u(idjd,k),k=1,9)
> c          write (6,"('v_a ',9f8.2)") (v(idjd,k),k=10,18)
> c          write (6,"('v_b ',9f8.2)") (v(idjd,k),k=1,9)
> c          write (6,"('qg_a ',9f8.3)") (1000.*qg(idjd,k),k=10,18)
> c          write (6,"('qg_b ',9f8.3)") (1000.*qg(idjd,k),k=1,9)
760,764c755,758
< 	   nlx=min(nlv,kl-8)
<           write (6,"('rh(nlx+) ',9f8.2)") (spmean(k),k=nlx,nlx+8)
<           write (6,"('div(nlx+)',9f8.2)") (div(k),k=nlx,nlx+8)
<           write (6,"('omgf',9f8.3/4x,9f8.3)")   ! in Pa/s
<      .              (ps(idjd)*omgf(idjd,kk),kk=1,kl)
---
>           write (6,"('rh(nlv+) ',9f8.2)") (spmean(k),k=nlv,nlv+8)
>           write (6,"('div(nlv+)  ',9f8.2)") (div(k),k=nlv,nlv+8)
>           write (6,"('omgf(nlv+)*dt',9f8.4)") 
>      .               (omgf(idjd,k)*dt,k=nlv,nlv+8)
766,768c760,813
<          endif  ! (mod(ktau,nmaxpr).eq.0)
<          call vertmix
< 	 endif  ! (ntsur.eq.-6)
---
>         endif
> 
>         un=0. ! 3D
>         vn=0. ! 3D
>         if(nhstest.eq.2)call hs_phys
>         if(ntsur.gt.0)call vertmix(nvsplit)  ! un & vn usually set here
>         if(diag)print *,'after vertmix tn*dt ',(tn(idjd,k)*dt,k=1,kl)
>         if(nhor.lt.0)call hordifgt  ! now not tendencies
>         if(diag)print *,'after hordifgt t ',(t(idjd,k),k=1,kl)
>         if(ngwd.ne.0)call gwdrag  ! <0 non-tendencies
>         if(abs(nkuo).eq.25.or.nkuo.eq.45)then
> !         in this case, incorporate other tendencies, then call conjob
>           t(kq,1)=t(kq,1)+tn(kq,1)*dt ! 3D
>           u(kq,1)=u(kq,1)+un(kq,1)*dt ! 3D
>           v(kq,1)=v(kq,1)+vn(kq,1)*dt ! 3D
>           tn(kq,1)=0. ! 3D
>           un(kq,1)=0. ! 3D
>           vn(kq,1)=0. ! 3D
>           if(abs(nkuo).eq.25)call convjlm   ! jlm scheme
>           if(nkuo.eq.45)call conjob         ! Arakawa-Gordon scheme
>         endif            ! (abs(nkuo).eq.25.or.nkuo.eq.45)
>       endif              !  if(mspec.eq.1)
> 
> !     write(6,'(i2," zs  ",18f7.1)')ktau,
> !    .  ((zs(iq)/9.806,i=id-1,id+1),j=jd-1,jd+1)
> !     write(6,'(i2," sdo ",18f7.3)')ktau,
> !    .  ((sdot(iq,4),i=id-1,id+1),j=jd-1,jd+1)
> 
>       call nonlin
> !!    write(6,'(i2," sdo ",18f7.3)')ktau,(sdot(idjd,k),k=1,kl)
> !!    write(6,'(i2," uuu ",18f7.1)')ktau,(u(idjd,k),k=1,kl)
> !!    write(6,'(i2," vvv ",18f7.1)')ktau,(v(idjd,k),k=1,kl)
> !!    write(6,'(i2," rtt ",18f7.3)')ktau,(1.e5*rtt(idjd,k),k=1,kl)
> !!    call printa('sdot',sdot(1,nlv),ktau,nlv,ia,ib,ja,jb,0.,1.e3)
>       if(diag)then
>         print *,'before hadv'
>         call printa('tx  ',tx(1,nlv),ktau,nlv,ia,ib,ja,jb,200.,1.)
>         write (6,"('tx  ',9f8.2)") (tx(idjd,k),k=nlv,nlv+8)
>         write (6,"('txe ',9f8.2)") (tx(ie(idjd),k),k=nlv,nlv+8)
>         write (6,"('txw ',9f8.2)") (tx(iw(idjd),k),k=nlv,nlv+8)
>         write (6,"('txn ',9f8.2)") (tx(in(idjd),k),k=nlv,nlv+8)
>         write (6,"('txs ',9f8.2)") (tx(is(idjd),k),k=nlv,nlv+8)
>         write(6,'(i2," qgv ",18f7.4)')ktau,(1000.*qg(idjd,k),k=1,kl)
>         call printa('qgv ',qg(1,nlv),ktau,nlv,ia,ib,ja,jb,0.,1.e3)
>       endif
> 
> !     evaluate horizontal advection for combined quantities
>       call upglobal
>       if(diag)then
>         print *,'after hadv'
>         write (6,"('tx  ',9f8.2)") (tx(idjd,k),k=nlv,nlv+8)
>         call printa('tx  ',tx(1,nlv),ktau,nlv,ia,ib,ja,jb,200.,1.)
>         write(6,'(i2," qgh ",18f7.4)')ktau,(1000.*qg(idjd,k),k=1,kl)
>       endif
769a815,871
>       if(nonl.lt.0)then
>         do kq=1,ijk
>          savt(kq,1)=t(kq,1)  ! can be used in nonlin during next step
>         enddo
>       endif
> 
>       if(mspec.eq.1)then
> !       call the cumulus convection scheme
>         if(nkuo.eq.4)call conjob          ! Arakawa-Gordon scheme
>       endif
>       if(ntsur.eq.-4)then
>         tn=0. ! 3D
>         if(diag)print *,ktau,'before sflux tx ',(tx(idjd,k),k=1,kl)
>         call sflux(nalpha,kscreen) ! also calls soilsnow & scrnout
>         if(diag)print *,ktau,'before vertmix tx ',(tx(idjd,k),k=1,kl)
>         if(diag)print *,ktau,'before vertmix tn ',(tn(idjd,k),k=1,kl)
>         stop 'call vertmix(tx,ux,vx,qg,ps,nvsplit)' ! watch common blocks (ux,vx,tx)
>         if(diag)print *,ktau,'after vertmix tx ',(tx(idjd,k),k=1,kl)
>         if(diag)print *,ktau,'after vertmix tn ',(tn(idjd,k),k=1,kl)
>         tx=tx+tn*dt ! 3D
>         ux=ux+un*dt ! 3D
>         vx=vx+vn*dt ! 3D
>       endif  ! (ntsur.eq.-4)
> 
>       ubar=savu1  ! 3D really saving savu1 in ubar here 
>       vbar=savv1  ! 3D really saving savv1 in vbar here 
> 
>       call adjust5
> !!    write(6,'(i2," qga ",18f7.4)')ktau,(1000.*qg(idjd,k),k=1,kl)
> 
>       if(mspec.eq.2)then     ! for very first step restore mass & T fields
>         call gettin(1)
>       else  ! i.e. mspec=1
>         if(ntsur.eq.-5)then  ! can get u,v instabilities from this option
> 	   call sflux(nalpha,kscreen)
>           call vertmix(nvsplit)
> 	 endif
>         if(abs(nkuo).eq.23)call convjlm     ! convjlm split at end of timestep
>       endif
> !     if(abs(mfix).lt.3)then   replaced 3/9/02
>       if(mfix_qg.eq.0.or.mspec.eq.2)then
>         qg=max(qg,qgmin)  ! guided by McCormick et al 1993 ! 3D
>       endif  ! abs(mfix).lt.3
> 79    dt=dtin                    ! ****** end of introductory time loop
> 
>       mspeca=1
>       if(nmi.ne.0)then
>         print *,'diabatic heating rates currently: ',
>      .            (rtt(idjd,kl/2),jj=1,jl)
>         stop 'call vmodes(dt,ds,nmi)'
>         mtimer = mtimer - mins_dt
>         timer=timer-dtin/3600.
>         timeg=timeg-dtin/3600.
>       endif
> !     npsav=npsav+1   ! disabled in globpe
>       psa(npsav)=ps(idjd)
>       psm(npsav)=ps(idjd+1)
813c915
<         call maxmin(tggsn,'tgg',ktau,1.,ms+3)
---
>         call maxmin(tgg,'tgg',ktau,1.,ms)
818c920
<         call maxmin(sno,'sn',ktau,1.,1)      ! as mm
---
>         call maxmin(snowd,'sn',ktau,1.,1)
864,865c966,967
<         endif    ! (t(idjd,kl).gt.258.)
<       endif      ! (mod(ktau,nmaxpr).eq.0)
---
>         endif           ! (t(idjd,kl).gt.258.)
>       endif
869,874c971,978
<       tmaxscr = max(tmaxscr,tscrn)
<       tminscr = min(tminscr,tscrn)
<       eg_ave = eg_ave+eg    
<       fg_ave = fg_ave+fg     
<       tscr_ave = tscr_ave+tscrn    ! take avge in outfile
<       qscrn_ave = qscrn_ave+qgscrn 
---
>       do iq=1,ifull
>        tmaxscr(iq) = max(tmaxscr(iq),tscrn(iq))
>        tminscr(iq) = min(tminscr(iq),tscrn(iq))
>        eg_ave(iq) = eg_ave(iq)+eg(iq)    
>        fg_ave(iq) = fg_ave(iq)+fg(iq)    
>        tscr_ave(iq) = tscr_ave(iq)+tscrn(iq)    ! take avge in outfile
>        qscrn_ave(iq) = qscrn_ave(iq)+qgscrn(iq) 
>       enddo
877,880c981,992
< !     rnd03 to rnd21 are accumulated in mm. Fixup for frequent nwt in outcdf      
<       if(mod(ktau,nperday).eq.nper3hr )rnd03=precip
<       if(mod(ktau,nperday).eq.nper6hr )rnd06=precip
<       if(mod(ktau,nperday).eq.nper9hr )rnd09=precip
---
>       if(mod(ktau,nper3hr).eq.0)then
>         nscrn3hr=nscrn3hr+1
>         if(nscrn3hr.gt.8)nscrn3hr=1
>         print *,'save 3 hrly tscreen for ktau,nscrn3hr: ',ktau,nscrn3hr
>         do iq=1,ifull
>          tscrn3hr(iq,nscrn3hr)=tscrn(iq)
>         enddo
>       endif ! (mod(ktau,nscrn3hr).eq.0)
>       if(mod(ktau,nperday).eq.nper6hr)then
>         print *,'creating nper6hr for ktau = ',ktau
> 	 rnd6=precip
>       endif
882d993
<       if(mod(ktau,nperday).eq.nper15hr)rnd15=precip
884c995,998
<       if(mod(ktau,nperday).eq.nper21hr)rnd21=precip
---
> 
> c      if(mstn.eq.1)then
> c        call stntrc
> c      endif
902d1015
<         rgc_ave  =  rgc_ave/max(koundiag,1)
907,909c1020,1035
<         cbas_ave(:)=1.1-cbas_ave(:)/max(1.e-4,precc(:))  ! 1.1 for no precc
<         ctop_ave(:)=1.1-ctop_ave(:)/max(1.e-4,precc(:))  ! 1.1 for no precc
<         call outfile(20,il,jl,kl,psa,psm,rundate,nmi,nsnowout,nwrite)
---
>         call outfile(20,il,jl,kl,psa,psm,rundate,nmi,nsnowout,
>      .               nwrite,nrad)
>         if(mod(ktau,mexrest*nwt).eq.0)then ! not recently checked out
> !         ensures a clean restart is possible every mexrest multiples of nwt
>           print *,'clean restart is possible after ktau =',ktau
>           print *,'after outfile qg ',(qg(idjd,k),k=1,kl)
> c         write(6,'(a,27e20.9)') 'after outfile qg',(qg(idjd,k),k=1,kl)
>           mspeca=2
>           kstart=ktau+1
>           dt=dtin*.5
>           do kq=1,ijk
>            ubar(kq,1)=u(kq,1) ! mexrest not recently checked out 
>            vbar(kq,1)=v(kq,1) ! 
>           enddo
>           call gettin(0)       ! preserve initial mass & T fields; nmi too
>         endif  !  mod(ktau,mexrest*nwt).eq.0
917c1043,1044
<           call outfile(19,il,jl,kl,psa,psm,rundate,nmi,nsnowout,nwrite)
---
>           call outfile(19,il,jl,kl,psa,psm,rundate,nmi,nsnowout,
>      .                 nwrite,nrad)
923c1050
<        call mslp(pmsl,psl,zs,t)
---
>        call mslp(pmsl)
932a1060,1066
> !       zero the precip (& runoff) fields once per day (all mm)
>         precc=0.
>         precip=0.
>         runoff=0.
> 	 rnd6=0.   
> 	 rnd12=0.   
> 	 rnd18=0.   
943,949d1076
< !       zero the precip (& runoff) fields each nwt (all now mm/day in outcdf)
<         precc=0.
<         precip=0.
<         cbas_ave=0.
<         ctop_ave=0.
< 	 sno=0.
<         runoff=0.
964d1090
<         rgc_ave  = 0.
969c1095
<         if(nllp.gt.0)call setllp ! tied in with nwt at present
---
>         if(nllp.gt.0)call setllp ! tied in with npreczer at present
1039,1043c1165,1169
<       do k=1,klt
<        do iq=1,ilt*jlt        
<         tr(iq,k,min(ntracmax,ngas+1))=alat(iq)
<         tr(iq,k,min(ntracmax,ngas+2))=along(iq)
<         tr(iq,k,min(ntracmax,ngas+3))=.01*ps(iq)*sig(k)  ! in HPa
---
>       do k=1,kl
>        do iq=1,ifull        
>         tr(iq,k,ngas+1)=alat(iq)
>         tr(iq,k,ngas+2)=along(iq)
>         tr(iq,k,ngas+3)=.01*ps(iq)*sig(k)  ! in HPa
1047,1050c1173,1175
<         do k=1,klt
<          do iq=1,ilt*jlt       
<           tr(iq,k,min(ntracmax,ngas+4))=
<      .	               t(iq,k)*(1.e-5*ps(iq)*sig(k))**(-r/cp)
---
>         do k=1,kl
>          do iq=1,ifull        
>           tr(iq,k,ngas+4)=t(iq,k)*(1.e-5*ps(iq)*sig(k))**(-r/cp)
1055,1058c1180,1181
<         do k=1,klt
<          do iq=1,ilt*jlt       
<           tr(iq,k,min(ntracmax,ngas+5))=1000.*qg(iq,k)
<          enddo
---
>         do kq=1,ijk      
>          tr(kq,1,ngas+5)=1000.*qg(kq,1)
1105a1229
> ! *   include 'astro.h'
1112,1113c1236,1237
<       include 'parmdyn.h'  ! nstag,epsp,epsu
<       include 'parmhor.h'  ! mhint, m_bs
---
>       include 'parmdyn.h'  ! morder,ntomg
>       include 'parmhor.h'  ! mhint, m_bs, morder
1131,1137c1255,1262
<       data ja/1/,jb/jl/,id/1/,jd/1/,ndi/1/,ndi2/0/                     
<      . ,io_clim/1/ ,io_in/1/   ,io_out/1/  ,io_rest/1/ ,io_spec/0/    
<      . ,kdate_s/-1/ ,ktime_s/-1/ ,khdif/5/                            
<      . ,nem/2/     ,newtop/0/  ,nextout/0/,nfly/2/                    
<      . ,ngwd/0/     ,nhor/155/  ,nlv/2/                    
<      . ,nmaxpr/5/  ,nqg/5/,nrungcm/0/      
<      . ,ntsea/6/   ,nvad/4/    ,nvmix/4/   ,nwt/-99/       
---
>       data ja/1/   ,jb/jl/     ,id/1/      ,jd/1/                       ! freq
>      . ,io_clim/1/ ,io_in/1/   ,io_out/1/  ,io_rest/1/ ,io_spec/0/      ! freq
>      . ,kdate_s/-1/ ,ktime_s/-1/ ,khdif/5/                    ! freq
>      . ,kstart/1/      ,mex/4/                               ! freq
>      . ,nem/2/     ,newtop/0/  ,nextout/0/                              ! freq
>      . ,ngwd/0/     ,nhor/155/  ,nlv/2/                    ! freq
>      . ,nmaxpr/5/  ,nqg/5/ , nqq/0/       ,nrungcm/0/                   ! freq
>      . ,ntsea/6/   ,nvad/4/    ,nvmix/4/   ,nwt/-99/                    ! freq
1139,1150c1264,1280
<      .  ,idcld  /1/,lgwd/2/,nbd/0/,nsib/3/            
<      .  ,nbox/1/,nvadh/1/       ! globpe only
<      .  ,kbotdav/1/,nlocal/0/
<      .  ,nud_p/1/,nud_q/0/,nud_t/1/,nud_uv/1/,nud_hrs/-24/
<       data namip/0/,nhstest/0/,nspecial/0/
<       data schmidt/1./,rlong0/0./,rlat0/90./,ndiur/1/
<      . ,newsoilm/0/,nglacier/1/,nhorps /1/,newztsea/1/                   
<      . ,nrun/0 /,ntsur/5/,nt_adv/0/,ndept/0/
<      . ,av_vmod/1./,tss_sh/0./,qgmin/1.e-6/       
< 
<       data khor/0/,kwt/kl/,mstn/0/,nps/2/,npsav /1/       
<      . ,nrunx/0/,nsd/0/,nstn/0/,nqg_set/99/   
---
>      .  ,idcld  /1/,lgwd/2/,m/6/,nbd/0/,nsib/3/            ! globpe only
>      .  ,nbox/1/,nunst/0/,nuv/10/,nvadh/1/,nxmap/0/        ! globpe only
>      .  ,kbotdav/1/,mst_bs/2/,mstu_bs/2/,nlocal/0/
>      .  ,nud_p/1/,nud_q/0/,nud_t/1/,nud_uv/1/,nud_hrs/-24/ ! globpe only
>       data nhstest/0/,nvadq/0/,nvadt/0/,nvsplit/0/
>       data namip/0/,mfix/1/,mfix_qg/1/,schmidt/1./
>      . ,rlong0/0./,rlat0/90./,ndiur/1/
>      . ,newsoilm/0/,nhorps /1/,newztsea/1/                   
>      . ,nrun/0 /,nsiceup /1 /,ntsur/5/
>      . ,nritch/0/,nritch_t/0/,nt_adv/0/
>      . ,nstabchk/0/,av_vmod/1./,tss_sh/0./,qgmin/1.e-6/       
>      . ,epsp/200./,epsu/0./,epsf/0./
> 
>       data aleadfr/0./,khor/0/,kwt/kl/,mstn/0/,mup/1/                          
>      . ,nonl  /0 /, nrot/1/ ,nps    /2 /,npsav  /1/       
>      . ,nrunx  /0 /,nsd     /0 /,nstn   /0 /                
>      . ,restol/5.e-6/,nqg_set/99/
1152,1157d1281
<       
< !     some variables in parmdyn.h      
<       data epsp/.1/,epsu/.1/,epsf/0./,m/6/,mex/4/,mfix/1/,mfix_qg/2/,
<      .     mup/1/,nonl/0/,nritch/407/,nritch_t/0/,nrot/1/,
<      .     nstag/-3/,nstagu/-3/,ntbar/-1/,
<      .     nvsplit/2/,nxmap/0/,restol/1.e-6/ ! changed from 5.e-6 on 25/7/03
1169,1171c1293,1295
<       data convfact/1.02/,convtime/.3/
<       data detrain/.05/,detrainx/1./,dsig2/.1/,dsig4/.55/
<       data epsconv/0./,fldown/.6/,iterconv/2/
---
>       data convfact/1./,convtime/0./
>       data detrain/.1/,detrainx/1./,dsig2/.1/,dsig4/.7/
>       data epsconv/0./,fldown/.6/,iterconv/1/
1173c1297
<       data methdetr/8/,methprec/1/
---
>       data methdetr/1/,methprec/2/
1176,1177c1300,1301
<       data nkuo/23/,nrad/4/,nrhcrit/10/,nstab_cld/0/
<       data rhcv/0./,rhmois/.1/,rhsat/1./
---
>       data nkuo/23/,nrhcrit/8/,nstab_cld/0/
>       data rhcv/.75/,rhmois/.1/,rhsat/1./
1183c1307
<       data albfile/' '/,icefile/' '/,maskfile/' '/
---
>       data albfile/' '/,deepfudg/' '/,icefile/' '/,maskfile/' '/
1194a1319
>       data kountr/0/
1238,1246c1363,1371
<       data swilt/0., .072, .216, .286, .135, .219, .283, .175, .395  !eak
< !     data swilt/0., .010, .1  , .138, .135, .219, .283, .175, .395  !mm5
<      &             , .216, .1142, .1547, .2864, .2498/
<       data sfc/1.,  .143, .301, .367, .218, .31 , .37 , .255, .45 
<      &            , .301, .22 , .25 , .367, .294/
<       data ssat/2., .398, .479, .482, .443, .426, .482, .420, .451  !jlm
< !     data ssat/2., .398, .479, .482, .443, .426, .482, .420, .450  !eak
< !     data ssat/2., .339, .470, .468, .443, .426, .482, .420, .450  !mm5
<      &          , .479, .435, .451, .482, .476/
---
>       data swilt/.072, .216, .286, .135, .219, .283, .175, .395, .216  !eak
> !     data swilt/.010, .1  , .138, .135, .219, .283, .175, .395, .216  !mm5
>      &          , .1142, .1547, .2864, .2498/
>       data sfc/ .143, .301, .367, .218, .31 , .37 , .255, .45 , .301
>      &          , .22 , .25 , .367, .294/
>       data ssat/.398, .479, .482, .443, .426, .482, .420, .451, .479  !jlm
> !     data ssat/.398, .479, .482, .443, .426, .482, .420, .450, .479  !eak
> !     data ssat/.339, .470, .468, .443, .426, .482, .420, .450, .479  !mm5
>      &          , .435, .451, .482, .476/
1252a1378,1380
>       data sormax /.00250, .00163, .00045, .00044, .00031,
>      &             .00040, .00072, .00044, .00163,
>      &             .00163, .00106, .00045, .00092/   ! last value not confirmed
=====================================
 
globpe_leon.f
=====================================
=====================================
 
gwdrag.f
=====================================
16c16
<      .            ,thf(ifull,kl),spare(ifull,kl)
---
>      .            ,thf(ifull,kl)
=====================================
 
hconst.f
=====================================
=====================================
 
helmsol.f
=====================================
80,86d79
<            ! Using acceleration of 1.0 on the first iteration improves 
<            ! convergence when there's a good initial guess.
<            if ( iter == 0 ) then
<               accfactor(:) = 1.0/(helm(:)-zz(:))
<            else
<               accfactor(:) = accel/(helm(:)-zz(:))
<            end if
=====================================
 
hordifg.f
=====================================
24,26c24,29
<       common/work2/uc(ifull),vc(ifull),wc(ifull),ee(ifull),ff(ifull) 
<      .      ,xfact(ifull),yfact(ifull),t_kh(ifull),tx_fact(ifull)
<      .      ,ty_fact(ifull),ptemp(ifull),dum(7*ifull)
---
>       common/work2/nface(ifull),xg(ifull),yg(ifull)  ! depts, upglobal & ints
>      .      ,uavx(ifull),vavx(ifull)       ! depts, upglobal,ints, hordifg/t
>      .      ,uc(ifull),vc(ifull),wc(ifull) ! upglobal,ints, hordifg/t
>      .      ,uav(ifull),vav(ifull)         ! upglobal, hordifg/t
>      .      ,ee(ifull),ff(ifull),xfact(ifull),yfact(ifull)
>      . ,t_kh(ifull),tx_fact(ifull),ty_fact(ifull),ptemp(ifull)
142c145
< c      ee now finished with (not used till now in globpea)
---
> c      uav, vav and ee now finished with (not used till now in globpea)
211a215,477
>       return
>       end
> 
>       subroutine hordifg(k)  !  globpea version   
> !     now not usual scheme. N.B. does not have k loop built in.
> c     called from upglobal, for +ve nhor 
> c     now not tendencies, updates uc, vc, wc, tx, qg
> c     for -ve nhor see hordifgt (the usual scheme)
> c     changed to Smagorinsky form with all map factors  Wed  04-30-1997
> c     with nhorq option in parameter list
>       parameter (nhorq=0)  !  1 for qg/p**3 option here
>       parameter (nhorjlm=0)   ! 1 for jlm 3D deformation rather than Smagorinsky
> c     this one has got map factors
> c     partly implicit code. In C37 tests stable for khdif=90,
> c     whereas explicit version was stable for 10 but unstable for 40
> c     this assumes unstaggered u,v. Called from upglobal for mspec=1
> c     carried out on Cartesian uc,vc,wc,t,qg; possibly on pslx
> c     Basic code shown for qg
> c     N.B. no trace_gases yet
> c     now has jlm nhorx option as last digit of nhor, e.g. 155
>       include 'newmpar.h'
>       include 'arrays.h'
>       include 'indices.h'
>       include 'map.h'
>       include 'parm.h'
>       include 'sigs.h'
>       include 'xarrs.h'
>       common/work2/nface(ifull),xg(ifull),yg(ifull)  ! depts, upglobal & ints
>      .      ,uavx(ifull),vavx(ifull)       ! depts, upglobal,ints, hordifg/t
>      .      ,uc(ifull),vc(ifull),wc(ifull) ! upglobal,ints, hordifg/t
>      .      ,uav(ifull),vav(ifull)         ! upglobal, hordifg/t
>      .      ,ee(ifull),ff(ifull),xfact(ifull),yfact(ifull)
>      . ,t_kh(ifull),tx_fact(ifull),ty_fact(ifull),ptemp(ifull)
>       logical done
>       data nf/2/
>       ind(i,j,n)=i+(j-1)*il+n*il*il  ! *** for n=0,5
> 
> c     nhorx used in hordif  ! previous code effectively has nhorx=0
> c           = 1 u, v, T, qg     diffusion reduced near mountains
> c           = 3       T, qg     diffusion reduced near mountains
> c           = 4                 diffusion not reduced near mountains
> c           = 5       T, qg     diffusion reduced near mountains (bottom 2/3)
> c           = 7 u, v, T, qg     diffusion reduced near mountains (bottom 2/3)
> c     nhorps       (N.B. has different usage from DARLAM)
> c           = 0    no pslx diffusion
> c           < 0    no pslx, u, or v diffusion
> c           = 22   pslx diffusion all levels (assumes nritch=22)
> 
> c     khor (set up in darlam.f): if non-zero increases the diffusion in the
> c     upper model levels   (never used these days)
> c         khor > 0 progessively doubles for khor upper levels
> c         khor < 0 linearly increases above sig = 0.2 (up to factor of 1-khor)
> 
> c     this horizontal diffusion routine allows compensation for
> c     being on sigma surfaces through reductions of kh over orography
> c     this is called for nhor.ge.50; the value of nhor (in metres) gives the
> c     scaling value for deltaz
> c     in namelist khdif is fujio's a**2, e.g. 4.
> 
> c     set up topography reduction factors for each type of location
> c     expect power nf to be about 1 or 2 (see data statement)
>       delphi=1.e6  ! turns off reduction (can also use nhorx=4)
>       if(nhor.ge.50)then
>          nhora=10*(nhor/10)    ! e.g. 150  for nhor=157
>          nhorx=nhor-nhora      ! e.g.   7  for nhor=157
>          delphi=nhora*9.806
>       endif
> 
>       do iq=1,ifull
>        ptemp(iq)=ps(iq)**.286
>        tx_fact(iq)=1./(1.+(abs(zs(ie(iq))-zs(iq))/delphi)**nf)
>        ty_fact(iq)=1./(1.+(abs(zs(in(iq))-zs(iq))/delphi)**nf)
>       enddo   !  iq loop
> c     above code independent of k and could be saved
> 
>       hdif=dt*hdiff(k)/ds
>       if(nhorjlm.eq.1)then
> c      jlm scheme using 3D uc, vc, wc
>        do iq=1,ifull
>         cc=(uc(ie(iq))-uc(iw(iq)))**2+(uc(in(iq))-uc(is(iq)))**2
>      .    +(vc(ie(iq))-vc(iw(iq)))**2+(vc(in(iq))-vc(is(iq)))**2
>      .    +(wc(ie(iq))-wc(iw(iq)))**2+(wc(in(iq))-wc(is(iq)))**2
> !       N.B. using double grid length
>         t_kh(iq)= .5*sqrt(cc)*hdif/em(iq)  ! this one without em in D terms
>        enddo   !  iq loop
> 
>       else
> c       uses (dv/dx+du/dy)**2 + .5*(du/dx)**2 + .5*(dv/dy)**2
> c       following Kikuchi et al. 1981      now Smag. Wed  04-30-1997
> !       N.B. original Smag. had m on top (in D formulae) and khdif=3.2
> c       t_kh is kh at t points
> 
> c       use ee and ff arrays temporarily for x and y derivs for 2nd deformation
>         do iq=1,ifull
>          ee(iq)= v(ie(iq),k)-v(iw(iq),k)              ! globpea
>          ff(iq)= u(in(iq),k)-u(is(iq),k)              ! globpea
> !        some bdy vals changed in next loops
>         enddo   !  iq loop
> 
> c       some special boundary values switch signs as well as vel components
>         do n=0,npanels
> c       following treats unusual panel boundaries
>         if(npann(n).ge.100)then
>           do i=1,il
>            iq=ind(i,il,n)
>            ff(iq)= -v(in(iq),k)-u(iq-il,k)     ! globpea sign switch too
>           enddo  ! i loop
>         endif      ! (npann(n).ge.100)
>         if(npane(n).ge.100)then
>           do j=1,il
>            iq=ind(il,j,n)
>            ee(iq)= -u(ie(iq),k)-v(iq-1,k)     ! globpea sign switch too
>           enddo   ! j loop
>         endif      ! (npane(n).ge.100)
>         if(npanw(n).ge.100)then
>           do j=1,il
>            iq=ind(1,j,n)
>            ee(iq)= v(iq+1,k)+u(iw(iq),k)      ! globpea sign switch too
>           enddo   ! j loop
>         endif      ! (npanw(n).ge.100)
>         if(npans(n).ge.100)then
>           do i=1,il
>            iq=ind(i,1,n)
>            ff(iq)= u(iq+1,k)+v(is(iq),k)      ! globpea sign switch too
>           enddo   ! i loop
>         endif      ! (npans(n).ge.100)
>         enddo      ! n loop
> 
>         do iq=1,ifull
> c        better to use ordinary staggered u & v for divergence-type calcs
> c        aa=u(iq,k)-u(iwu(iq),1,k)
> c        bb=v(iq,k)-v(isv(iq),1,k)
>          aa=.5*(u(ieu(iq),k)-u(iwu(iq),k))    ! globpea code
>          bb=.5*(v(inv(iq),k)-v(isv(iq),k))    ! globpea code
>          cc=.5*(ee(iq)+ff(iq))   !  .5 because double grid length
> !        cc=cc**2+(aa**2+bb**2)*.5   ! this one for Kikuchi
>          cc=cc**2+(aa-bb)**2         ! this one for Smagorinsky
> c        print *,'k,iq,em ',k,iq,em(iq)
> !        t_kh(iq)= sqrt(cc)*hdif           ! this one because em in D terms
>          t_kh(iq)= sqrt(cc)*hdif/em(iq)  ! this one without em in D terms
> c        if(diag.and.iq.eq.idjd)then
> c         print *,'k, aa,bb ',k,aa,bb
> c         print *,'k, ee,ff,t_kh ',k,ee(idjd),ff(idjd),t_kh(idjd)
> c       endif
>         enddo   !  iq loop
> c       uav, vav and ee now finished with (not used till now in globpea)
>       endif    !  (nhorjlm.eq.1)
> 
>        if(nhorps.ge.0)then     ! may wish to not diffuse u,v
>          do iq=1,ifull
>           xfact(iq)=(t_kh(ie(iq))+t_kh(iq))*.5
>           yfact(iq)=(t_kh(in(iq))+t_kh(iq))*.5
>          enddo   !  iq loop
>          if((nhorx.ge.7.and.k.le.2*kl/3).or.nhorx.le.1)then
>            do iq=1,ifull
>             xfact(iq)=xfact(iq)*tx_fact(iq)
>             yfact(iq)=yfact(iq)*ty_fact(iq)
>            enddo   !  iq loop
>          endif   ! (nhorx.ge.7.and.k.le.2*kl/3).or.nhorx.le.1
>          do iq=1,ifull
>           emi=1./em(iq)**2
>           uav(iq)=( uc(iq)*emi    ! updated uc temporarily in uav array
>      .      +xfact(iq)*uc(ie(iq)) +xfact(iwu2(iq))*uc(iw(iq))
>      .      +yfact(iq)*uc(in(iq)) +yfact(isv2(iq))*uc(is(iq)) )
>      .      /(emi+xfact(iq)+xfact(iwu2(iq))+yfact(iq)+yfact(isv2(iq)))
>           vav(iq)=( vc(iq)*emi
>      .      +xfact(iq)*vc(ie(iq)) +xfact(iwu2(iq))*vc(iw(iq))
>      .      +yfact(iq)*vc(in(iq)) +yfact(isv2(iq))*vc(is(iq)) )
>      .      /(emi+xfact(iq)+xfact(iwu2(iq))+yfact(iq)+yfact(isv2(iq)))
>           ee(iq)=( wc(iq)*emi
>      .      +xfact(iq)*wc(ie(iq)) +xfact(iwu2(iq))*wc(iw(iq))
>      .      +yfact(iq)*wc(in(iq)) +yfact(isv2(iq))*wc(is(iq)) )
>      .      /(emi+xfact(iq)+xfact(iwu2(iq))+yfact(iq)+yfact(isv2(iq)))
>          enddo   !  iq loop
>          do iq=1,ifull
>           uc(iq)=uav(iq)
>           vc(iq)=vav(iq)
>           wc(iq)= ee(iq)
> c         uc(iq)=uav(iq)-uc(iq)   ! so as to return tendencies of uc
> c         vc(iq)=vav(iq)-vc(iq)   ! so as to return tendencies of vc
> c         wc(iq)= ee(iq)-wc(iq)   ! so as to return tendencies of wc
>          enddo   !  iq loop
>        endif   ! nhorps.ge.0
> 
>        if(diag)then
>          print *,'k,id,jd,idjd ',k,id,jd,idjd
>          print *,'k, xfact, xfactw ',k,xfact(idjd),xfact(iwu2(idjd))
>          print *,'k, yfact, yfacts ',k,yfact(idjd),yfact(isv2(idjd))
>          print *,'k, uc,uce,ucw,ucn,ucs '
>      .     ,k,uc(idjd),uc(ie(idjd)),uc(iw(idjd))
>      .     ,uc(in(idjd)),uc(is(idjd))
>        endif
> 
>        do iq=1,ifull
> c       xflux(iq)=(ff(ie(iq),1)-ff(iq))*
> c    .              (t_kh(ie(iq))+t_kh(iq))*.5
> c       yflux(iq)=(ff(in(iq),1)-ff(iq))*
> c    .              (t_kh(in(iq))+t_kh(iq))*.5
>         xfact(iq)=(t_kh(ie(iq))+t_kh(iq))*.5
>         yfact(iq)=(t_kh(in(iq))+t_kh(iq))*.5
>        enddo   !  iq loop
> 
>        done=.false.
>        if(nhorps.eq.22)then
>          do iq=1,ifull
> c         ff(iq)=zs(iq)+287.*t(iq,k)*psl(iq) ! N.B. level k T e.g. 1
>           ee(iq)=pslx(iq,k)
>          enddo
>          do iq=1,ifull
>           emi=1./em(iq)**2
>           pslx(iq,k)=( ee(iq)*emi
>      .      +xfact(iq)*ee(ie(iq)) +xfact(iwu2(iq))*ee(iw(iq))
>      .      +yfact(iq)*ee(in(iq)) +yfact(isv2(iq))*ee(is(iq)) )
>      .      /(emi+xfact(iq)+xfact(iwu2(iq))+yfact(iq)+yfact(isv2(iq)))
> c         ee(iq)=( ( ff(iq)*emi
> c    .      +xfact(iq)*ff(ie(iq)) +xfact(iwu2(iq))*ff(iw(iq))
> c    .      +yfact(iq)*ff(in(iq)) +yfact(isv2(iq))*ff(is(iq)) )
> c    .      /(emi+xfact(iq)+xfact(iwu2(iq))+yfact(iq)+yfact(isv2(iq)))
> c    .      -zs(iq))/(287.*t(iq,k))  -psl(iq)  ! tendency in ee array
> c         do kk=1,kl
> c          pslx(iq,kk)=pslx(iq,kk)+ee(iq)
> c         enddo !  kk loop
>          enddo   !  iq loop
>        endif   !  (nhorps.eq.22)then
> 
>        if((nhorx.ge.5.and.k.le.2*kl/3).or.nhorx.lt.4)then
>          if(.not.done)then   ! i.e. for psl above
>            do iq=1,ifull
>             xfact(iq)=xfact(iq)*tx_fact(iq)
>             yfact(iq)=yfact(iq)*ty_fact(iq)
>            enddo   !  iq loop
>          endif
>        endif  ! (nhorx.ge.5.and.k.le.2*kl/3).or.nhorx.lt.4
> c      do t diffusion based on potential temperature ff
>        do iq=1,ifull
>         if(nhorq.eq.1)then
>           ee(iq)=qg(iq,k)/(ps(iq)*sig(k))**3
>         else
>           ee(iq)=qg(iq,k)
>         endif
>         ff(iq)=tx(iq,k)/ptemp(iq)
>        enddo   !  iq loop
>        do iq=1,ifull
> c       qg(iq,k)=qg(iq,k)+xflux(iq)-xflux(iwu2(iq),1)
> c    .                       +yflux(iq)-yflux(isv2(iq),1)
> c       qg(iq,k)new=qg(iq,k)old  - qg(iq,k)new *
> c        (xfact(iq)+xfact(iwu2(iq))+yfact(iq)+yfact(isv2(iq)))
> c       +xfact(iq)*ff(ie(iq)) +xfact(iwu2(iq))*ff(iw(iq))
> c    .  +yfact(iq)*ff(in(iq)) +yfact(isv2(iq))*ff(is(iq))
>         emi=1./em(iq)**2
>         qg(iq,k)=( ee(iq)*emi
>      .    +xfact(iq)*ee(ie(iq)) +xfact(iwu2(iq))*ee(iw(iq))
>      .    +yfact(iq)*ee(in(iq)) +yfact(isv2(iq))*ee(is(iq)) )
>      .    /(emi+xfact(iq)+xfact(iwu2(iq))+yfact(iq)+yfact(isv2(iq)))
>         if(nhorq.eq.1)qg(iq,k)=qg(iq,k)*(ps(iq)*sig(k))**3
> c       ptemp()*()/()  -t() gives T tendency
> c       tx(iq,k)=tx(iq,k)-t(iq,k) +ptemp(iq) * ( ff(iq)
>         tx(iq,k)=ptemp(iq) * ( ff(iq)*emi
>      .    +xfact(iq)*ff(ie(iq)) +xfact(iwu2(iq))*ff(iw(iq))
>      .    +yfact(iq)*ff(in(iq)) +yfact(isv2(iq))*ff(is(iq)) )
>      .    /(emi+xfact(iq)+xfact(iwu2(iq))+yfact(iq)+yfact(isv2(iq)))
>        enddo   !  iq loop
> 
=====================================
 
hsdummy.f
=====================================
=====================================
 
hs_phys.f
=====================================
42c42,44
<        do iq=1,ifull
---
>        do j=1,jl
>         do i=1,il
>            iq = i +(j-1)*il
53a56
>         end do
60c63,64
<        do iq=1,ifull
---
>        do j=1,jl
>         do i=1,il
65a70
>         end do
=====================================
 
iabsdate.f
=====================================
=====================================
 
icefall.f
=====================================
=====================================
 
indata.f
=====================================
2c2
< !     has sigmf (& alb) fix-ups for adelaide, perth, darwin, sydney, brisbane
---
> !     has sigmf (& alb) fix-ups for Adelaide, Perth, Darwin, Sydney, Brisbane
7c7
<       parameter (jlmsigmf=1)  ! 1 for jlm fixes to dean's data
---
>       parameter (jlmsigmf=1)  ! 1 for jlm fixes to Dean's data
12,14c12,14
< c             sets hourst (gmt) from ktime
< c             precc, precip setup moved to bottom
< c     note: unformatted qg in g/kg
---
> c             sets hourst (GMT) from ktime
> c             precc, precip & ts2 setup moved to bottom
> c     Note: unformatted qg in g/kg
29c29
<       include 'parmdyn.h'   ! epsp
---
>       include 'parmdyn.h'
49c49
< !     common/work3/p(ifull,kl),dum3(ifull,kl,4)
---
> !     common/work3/p(ifull,kl),dum3(ifull,kl,3)
56,58c56,58
< !     for the held-suarez test
<       parameter(delty = 60.)    ! pole to equator variation in equal temperature
<       parameter(deltheta = 10.) ! vertical variation
---
> !     For the Held-Suarez test
>       parameter(delty = 60.)    ! Pole to equator variation in equal temperature
>       parameter(deltheta = 10.) ! Vertical variation
96c96
< c     now always read eig file fri  12-18-1992
---
> c     now always read eig file Fri  12-18-1992
107c107
<       read(28,*)(sigmh(k),k=1,kl+1) !runs into dsig, but ok
---
>       read(28,*)(sigmh(k),k=1,kl+1) !runs into dsig, but OK
127,128c127,128
<       print *,'iradon,ico2,iso2,iso4,ich4,io2 ',
<      .         iradon,ico2,iso2,iso4,ich4,io2
---
>       print *,'iRADON,iCO2,iSO2,iSO4,iCH4,iO2 ',
>      .         iRADON,iCO2,iSO2,iSO4,iCH4,iO2
131c131
<       if(ngas.gt.0)call tracini  ! set up trace gases
---
>       if(ngas.gt.0)call TracIni  ! set up trace gases
133,134c133,134
< !     read in fresh zs, land-sea mask (land where +ve), variances
<       if(io_in.le.4)then
---
> !       read in fresh zs, land-sea mask (land where +ve), variances
> !       always done from Sept 2002
136a137,138
>         write(6,"('zs#_topof ',9f7.1)") 
>      .              ((zs(ii+(jj-1)*il),ii=id-1,id+1),jj=jd-1,jd+1)
147c149
< !       following is land fix for cape grim radon runs    **************
---
> !       following is land fix for Cape Grim radon runs    **************
155,165d156
<       endif   ! (io_in.le.4)
<       write(6,"('zs#_topof ',9f7.1)") 
<      .            ((zs(ii+(jj-1)*il),ii=id-1,id+1),jj=jd-1,jd+1)
<       write(6,"('he#_topof ',9f7.1)") 
<      .            ((he(ii+(jj-1)*il),ii=id-1,id+1),jj=jd-1,jd+1)
< 
<       if(nhstest.lt.0)then  ! aquaplanet test -22   from June 2003
<         do iq=1,ifull
<          zs(iq)=0.
<         enddo   ! iq loop
<       endif  !  (nhstest.lt.0)
178c169
<           print *,'kdate_s,ktime_s >= ',kdate_s,ktime_s
---
>           print *,'kdate_s,ktime_s ',kdate_s,ktime_s
194c185
< !         reduce sea tss to mslp      e.g. for qcca in ncep gcm
---
> !         reduce sea tss to mslp      e.g. for QCCA in NCEP GCM
199c190
<              tss(iq)=tss(iq)-zss(iq)*.0065/9.806  ! n.b. -
---
>              tss(iq)=tss(iq)-zss(iq)*.0065/9.806  ! N.B. -
222a214,226
>         if(nunst.eq.1)then
> c         may need to unstagger the winds for globpea version
>           do k=1,kl
>             call unstaguv(u(1,k),v(1,k),u(1,k),v(1,k))
>           enddo  ! k loop
>         endif    ! (nunst.eq.1)then
>         if(nunst.eq.2)then
> c         unstagger then stagger winds for globpe (to compare with globpea)
>           do k=1,kl
>            call unstaguv(u(1,k),v(1,k),u(1,k),v(1,k))  ! was ..3
>            call   staguv(u(1,k),v(1,k),u(1,k),v(1,k))  ! was ..3
>           enddo  ! k loop
>         endif    ! (nunst.eq.2)then
306c310
< c       for rotated coordinate version, see jmcg's notes
---
> c       For rotated coordinate version, see JMcG's notes
345c349
< c       assign u and v from zonal and meridional uin and vin (no schmidt here)
---
> c       assign u and v from zonal and meridional uin and vin (no Schmidt here)
383c387
< !     for the held-suarez test
---
> !     For the Held-Suarez test
398c402
< !          set the temperature to the equilibrium zonal mean
---
> !          Set the temperature to the equilibrium zonal mean
403c407
< !          set zonal wind to an approximate equilibrium
---
> !          Set zonal wind to an approximate equilibrium
413c417
<              print *,'indata setting u,v for h-s'
---
>              print *,'indata setting u,v for H-S'
424c428
< !!       just to get something started set the meridional wind to a small
---
> !!       Just to get something started set the meridional wind to a small
433c437
<       endif  ! held-suarez test case
---
>       endif  ! Held-Suarez test case
530c534
< c       set default tgg etc to level 2 temperatures, if not read in above
---
> c       set default ts2 etc to level 2 temperatures, if not read in above
544a549
> !      ts2(iq)=t(iq)       ! always copy from deepest value
546a552
> 	fracice(iq)=1.            ! present default without leads
554,556c560,569
<       if(nqg_set.lt.7)then  ! initialize sicedep from tss (i.e. not read in)
< !       n.b. this stuff & other nqg_set to be removed when always netcdf input
<         print *,'preset sice to .5 via tss, because nqg_set: ',nqg_set
---
>       if(nsiceup.eq.2)then
>         call readreal(icefile,aa,ifull)
>         do iq=1,ifull
>          if(.not.land(iq).and.aa(iq).ge..5)then                 ! sice
>            sicedep(iq)=.5
>          endif
>         enddo   ! iq loop
>       elseif(nqg_set.lt.7)then  ! initialize sicedep from tss (i.e. not read in)
>         print *,'preset sice to .5 via tss, because nsiceup,nqg_set: ',
>      .                                              nsiceup,nqg_set
559c572
<            sicedep(iq)=2.  ! changed from .5 on 26/3/03
---
>            sicedep(iq)=.5      ! sice
561c574
<            sicedep(iq)=0.     
---
>            sicedep(iq)=0.      ! sice
564c577
<       endif ! (nqg_set.lt.7)
---
>       endif ! (nsiceup.eq.2) .. else ..
570d582
< 	  fracice(iq)=0.          
573,574c585
< 	  fracice(iq)=1.  ! present default without leads
<          snowd(iq)=0.    ! no snow presently allowed on sea-ice
---
>          snowd(iq)=0.  ! no snow allowed on sea-ice
581a593
> c       if(nsib.eq.2)call scamrdn         ! reads scam parameters
584,585c596,597
< 	  ivegt(iq)=1   ! default for h_s etc
< 	  isoilm(iq)=1  ! default for h_s etc
---
> 	  ivegt(iq)=1   ! default for H_S etc
> 	  isoilm(iq)=1  ! default for H_S etc
590c602
< !     they can be: preset/read_in_from_previous_run
---
> !     They can be: preset/read_in_from_previous_run
599c611
< !       new code follows; july 2001 jlm
---
> !       new code follows; July 2001 jlm
606c618
< !          fracsum(imo) is .5 for nh summer value, -.5 for nh winter value
---
> !          fracsum(imo) is .5 for NH summer value, -.5 for NH winter value
611c623
< c          wb(iq,ms)= .5*swilt(isoilm(iq))+ .5*sfc(isoilm(iq)) ! till july 01
---
> c          wb(iq,ms)= .5*swilt(isoilm(iq))+ .5*sfc(isoilm(iq)) ! till July 01
616c628
<      .        wb(iq,ms)=swilt(isoilm(iq)) ! dry interior of australia
---
>      .        wb(iq,ms)=swilt(isoilm(iq)) ! dry interior of Australia
661c673
<           read(77,'(12f7.2)') ((tr(iq,k,ico2),iq=1,ilt*jlt),k=1,klt)
---
>           read(77,'(12f7.2)') (tr(kq,1,ico2),kq=1,ijk)
664,668c676,678
< 	   do k=1,klt
< 	    do iq=1,ilt*jlt
<             rmin=min(rmin,tr(iq,k,ico2))
<             rmax=max(rmax,tr(iq,k,ico2))
<            enddo
---
>           do kq=1,ijk
>            rmin=min(rmin,tr(kq,1,ico2))
>            rmax=max(rmax,tr(kq,1,ico2))
678c688
<           read(77,*) ((tr(iq,k,iradon),iq=1,ilt*jlt),k=1,klt)
---
>           read(77,*) (tr(kq,1,iradon),kq=1,ijk)
681,685c691,693
< 	   do k=1,klt
< 	    do iq=1,ilt*jlt
<             rmin=min(rmin,tr(iq,k,iradon))
<             rmax=max(rmax,tr(iq,k,iradon))
<            enddo
---
>           do kq=1,ijk
>            rmin=min(rmin,tr(kq,1,iradon))
>            rmax=max(rmax,tr(kq,1,iradon))
714c722
<       if(nrungcm.eq.4)then !  wb fix for ncep input 
---
>       if(nrungcm.eq.4)then !  wb fix for NCEP input 
716c724
< !       - to compensate for ncep drying out, increase minimum value
---
> !       - to compensate for NCEP drying out, increase minimum value
726,727c734,735
<       if(nrungcm.eq.5)then !  tgg, wb fix for mark 3 input
< !       unfortunately mk 3 only writes out 2 levels
---
>       if(nrungcm.eq.5)then !  tgg, wb fix for Mark 3 input
> !       unfortunately Mk 3 only writes out 2 levels
743c751
<         print *,'after nrungcm=5 fixup of mk3 soil variables:'
---
>         print *,'after nrungcm=5 fixup of Mk3 soil variables:'
748,763d755
<       if(nrungcm.eq.11)then   ! this is old nrungcm=-1 option
<         do iq=1,ifull
<          if(land(iq))then
<            wb(iq,ms)=.5*(swilt(isoilm(iq))+sfc(isoilm(iq)))  
<            if(abs(rlatt(iq)*180./pi).lt.18.)wb(iq,ms)=sfc(isoilm(iq)) ! tropics
<            if(rlatt(iq)*180./pi.gt.-32..and.
<      .        rlatt(iq)*180./pi.lt.-22..and.
<      .        rlongg(iq)*180./pi.gt.117..and.rlongg(iq)*180./pi.lt.146.)
<      .        wb(iq,ms)=swilt(isoilm(iq)) ! dry interior of australia
<          endif    !  (land(iq))
<          do k=1,ms-1
<           wb(iq,k)=wb(iq,ms)
<          enddo    !  k loop
<         enddo     ! iq loop
<       endif       !  ((nrungcm.eq.11)
< 
779c771
< c        fix for antarctic snow
---
> c        fix for Antarctic snow
792a785,787
>         if(newsoilm.gt.10)then    ! also read in ts1 and ts2
>           stop 'code not ready for ts(,1)'
>         endif
795c790
<       if(nhstest.lt.0)then  ! aquaplanet test
---
>       if(nhstest.eq.-1)then  ! aquaplanet test
809,833c804,805
< 	 do k=1,ms
< 	  tgg(:,k)=tss(:)
< 	  wb(:,k)=0.
< 	 enddo
<         if(nhstest.gt.-22)then  ! pgb test, e.g. nhtest=-1 or -2
< 	   ix=il/2
< 	   jx=1.19*il
<           ix=id
< 	   jx=jd
< 	   do j=jx+nhstest,jx-nhstest
<            do i=ix+nhstest,ix-nhstest
<             iq=i+(j-1)*il
<             zs(iq)=.1	   
<             land(iq)=.true.
<             isoilm(iq)=4   ! sandy-loam/loam
<             ivegt(iq)=14
<             sigmf(iq)=0.   ! bare soil
< 	     print *,'i,j,land,zs ',i,j,land(iq),zs(iq)
<      	    enddo
< 	   enddo
< 	   ixjx=ix+(jx-1)*il
< 	   print *,'ix,jx,long,lat ',
<      .             ix,jx,rlongg(ixjx)*180./pi,rlatt(ixjx)*180./pi
<         endif  ! (nhstest.gt.-22)
<       endif    ! (nhstest.lt.0)
---
>         print *,'in indata alb: ',alb(1),alb(ifull/2),alb(ifull)
>       endif  !  (nhstest.eq.-1)
838,840c810,812
<       gwdfac=.01*lgwd   ! most runs used .02 up to fri  10-10-1997
<       helim=800.       ! hal used 800.
<       hefact=.1*abs(ngwd)   ! hal used hefact=1. (equiv to ngwd=10)
---
>       gwdfac=.01*lgwd   ! most runs used .02 up to Fri  10-10-1997
>       helim=800.       ! Hal used 800.
>       hefact=.1*abs(ngwd)   ! Hal used hefact=1. (equiv to ngwd=10)
862,863c834,835
< c****    limit launching height : Palmer et al use limit on variance of
< c****    (400 m)**2. we use launching height = std dev. we limit
---
> c****    limit launching height : palmer et al use limit on variance of
> c****    (400 m)**2. We use launching height = std dev. We limit
865c837
< c****    according to Palmer this prevents 2-grid noise at steep edge of
---
> c****    according to palmer this prevents 2-grid noise at steep edge of
874d845
<            hemax=max(he(iq),hemax)
877d847
<         print *,'final hemax = ',hemax
887,892c857
<        zolog(iq)=log(zmin/zolnd(iq))   ! for land use in sflux
<        if(.not.land(iq))then
< !        from June '03 tgg1	holds actual sea temp, tss holds net temp 
<          tgg(iq,1)=max(271.3,tss(iq)) 
<          tgg(iq,3)=tss(iq)         ! a default 
<        endif   ! (.not.land(iq))
---
>        zolog(iq)=log(zmin/zolnd(iq))   ! for land use in latest sflux
895,899c860,863
<          tgg(iq,3)=min(271.2,tss(iq),t(iq,1)+.04*6.5) ! for 40 m level 1
<          tss(iq)=tgg(iq,3)*fracice(iq)+tgg(iq,1)*(1.-fracice(iq))
<          alb(iq)=.65*fracice(iq)+.1*(1.-fracice(iq))
<        endif   ! (sice(iq)) 
<        if(isoilm(iq).eq.9)then
---
>          tss(iq)=min(271.1,tss(iq),t(iq,1)+.04*6.5) ! for 40 m level 1
>          tgg(iq,1)=tss(iq)
>          alb(iq)=.65
>        elseif(isoilm(iq).eq.9)then
904c868
<        endif   ! (isoilm(iq).eq.9)
---
>        endif   ! (sice(iq)) .. else ..
907d870
< !     tgg(:,:)=max(190.,tgg(:,:))  ! temporary post-glacier-error fix
909,911c872
<       write(6,"('tss#    ',3f7.2,1x,3f7.2,1x,3f7.2)") 
<      .       ((tss(ii+(jj-1)*il),ii=id-1,id+1),jj=jd-1,jd+1)
<       write(6,"('tgg(1)# ',3f7.2,1x,3f7.2,1x,3f7.2)") 
---
>       write(6,"('tgg(1)# ',9f7.2)") 
913c874
<       write(6,"('tgg(2)# ',3f7.2,1x,3f7.2,1x,3f7.2)") 
---
>       write(6,"('tgg(2)# ',9f7.2)") 
915,917c876
<       write(6,"('tgg(3)# ',3f7.2,1x,3f7.2,1x,3f7.2)") 
<      .       ((tgg(ii+(jj-1)*il,3),ii=id-1,id+1),jj=jd-1,jd+1)
<       write(6,"('tgg(ms)#',3f7.2,1x,3f7.2,1x,3f7.2)") 
---
>       write(6,"('tgg(ms)#',9f7.2)") 
919c878
<       write(6,"('land#   ',3l7,1x,3l7,1x,3l7)") 
---
>       write(6,"('land#   ',9L7)") 
921,923c880
<       write(6,"('sice#   ',3l7,1x,3l7,1x,3l7)") 
<      .       ((sice(ii+(jj-1)*il),ii=id-1,id+1),jj=jd-1,jd+1)
<       write(6,"('zo#     ',3f7.2,1x,3f7.2,1x,3f7.2)") 
---
>       write(6,"('zo#     ',9f7.2)") 
925c882
<       write(6,"('wb(1)#  ',3f7.3,1x,3f7.3,1x,3f7.3)") 
---
>       write(6,"('wb(1)#  ',9f7.3)") 
927c884
<       write(6,"('wb(ms)# ',3f7.3,1x,3f7.3,1x,3f7.3)") 
---
>       write(6,"('wb(ms)# ',9f7.3)") 
929c886
<       write(6,"('swilt#  ',3f7.3,1x,3f7.3,1x,3f7.3)")
---
>       write(6,"('swilt#  ',9f7.3)")
931c888
<       write(6,"('wb3frac#',3f7.3,1x,3f7.3,1x,3f7.3)")
---
>       write(6,"('wb3frac#',9f7.3)")
935c892
<       write(6,"('snowd#  ',3f7.2,1x,3f7.2,1x,3f7.2)") 
---
>       write(6,"('snowd# ',9f7.2)") 
937,938d893
<       write(6,"('fracice#',3f7.3,1x,3f7.3,1x,3f7.3)") 
<      .       ((fracice(ii+(jj-1)*il),ii=id-1,id+1),jj=jd-1,jd+1)
942,943c897,898
<       if(npanels.eq.0)i1=2    ! for darlam
<       if(npanels.eq.0)j1=2    ! for darlam
---
>       if(npanels.eq.0)i1=2    ! for DARLAM
>       if(npanels.eq.0)j1=2    ! for DARLAM
967a923
>           tgg(iq,1)=tss(iq) ! setting tice
978c934
<       if(nrungcm.eq.1)then  ! jlm alternative wb fix for nsib runs off early mark 2 gcm
---
>       if(nrungcm.eq.1)then  ! jlm alternative wb fix for nsib runs off early Mark 2 gcm
989c945
< !          very dry jlm suggestion. assume vegfrac ~.5, so try to satisfy
---
> !          very dry jlm suggestion. Assume vegfrac ~.5, so try to satisfy
1018c974
< !          jlm fix-up for tropical oz in january 321
---
> !          jlm fix-up for tropical Oz in January 321
1025c981
< !          jlm fix-up for dry interior in january 321
---
> !          jlm fix-up for dry interior in January 321
1033c989
<          if(nfixwb.eq.10)then    ! was default for nrungcm=1 till oct 2001
---
>          if(nfixwb.eq.10)then    ! was default for nrungcm=1 till Oct 2001
1063c1019
<       if(nrungcm.eq.2)then  ! for nsib runs off early mark 2 gcm
---
>       if(nrungcm.eq.2)then  ! for nsib runs off early Mark 2 gcm
1086c1042
< c     initialize snow variables for sib3 and sib4
---
> c     Initialize snow variables for sib3 and sib4
1119c1075
<       osnowd = snowd  ! 2d
---
>       osnowd = snowd  ! 2D
1129c1085
< !!     can try fix up of oz albedo   27/4/01
---
> !!     can try fix up of Oz albedo   27/4/01
1134c1090
< !     .      alb(iq)=alb(iq)-.04  ! fix over central oz
---
> !     .      alb(iq)=alb(iq)-.04  ! fix over central Oz
1142,1147c1098,1102
< 
<       do ip=1,ipland  ! all land points in this nsib=1+ loop
<        iq=iperm(ip)
<        isoil = isoilm(iq)
<        iveg  = ivegt(iq)
<        if(jlmsigmf.eq.1)then  ! fix-up for dean's veg-fraction
---
>       if(jlmsigmf.eq.1)then  ! fix-up for Dean's veg-fraction
>         do ip=1,ipland  ! all land points in this nsib=1+ loop
>          iq=iperm(ip)
>          isoil = isoilm(iq)
>          iveg  = ivegt(iq)
1153,1166c1108,1109
<        endif   ! (jlmsigmf.eq.1)
< !      following done here just for rsmin diags for nstn and outcdf	
<        tstom=298.
<        if(iveg.eq.6+31)tstom=302.
<        if(iveg.ge.10.and.iveg.le.21.and.
<      .    abs(rlatt(iq)*180./3.14).lt.25.)tstom=302.
<        tsoil=min(tstom, .5*(.3333*tgg(iq,2)+.6667*tgg(iq,3)
<      &            +.95*tgg(iq,4) + .05*tgg(iq,5)))
<        ftsoil=max(0.,1.-.0016*(tstom-tsoil)**2)
< c      which is same as:  ftsoil=max(0.,1.-.0016*(tstom-tsoil)**2)
< c                         if( tsoil .ge. tstom ) ftsoil=1.
<        rlai=  max(.1,rlaim44(iveg)-slveg44(iveg)*(1.-ftsoil))
<        rsmin(iq) = rsunc44(iveg)/rlai   
<       enddo    !  ip=1,ipland
---
>         enddo        !  ip=1,ipland
>       endif  ! (jlmsigmf.eq.1)
1170,1171c1113,1114
<         print *,'before jalbfix isoil,sand,alb,rsmin ',
<      .                          isoil,sand(isoil),alb(idjd),rsmin(idjd)
---
>         print *,'before jalbfix isoil,sand,alb ',
>      .                          isoil,sand(isoil),alb(idjd)
1244c1187
<       print *,'at centre of the panels:'
---
>       print *,'At centre of the panels:'
1255c1198
<      .    t1    tgg2   tgg6     wb1  wb6    ico2  radon')
---
>      .    t1     ts2    ts1     wb1  wbms   ico2  radon')
1259c1202
<         along(iq)=rlongg(iq)*180./pi    ! wed  10-28-1998
---
>         along(iq)=rlongg(iq)*180./pi    ! Wed  10-28-1998
1270,1271d1212
<         print *,'idjd,land,isoil,ivegt ',
<      .           idjd,land(idjd),isoilm(idjd),ivegt(idjd)
1272a1214,1215
>           if(iq.eq.idjd)print *,'iq,land,isoil,ivegt ',
>      .                              iq,land(iq),isoilm(iq),ivegt(iq)
1276c1219
<                 print *,'stopping because nsib = 1 or 3 ',
---
>                 print *,'stopping because nsib = 1',
1300,1328d1242
< 	  if(.not.land(iq))then
< !          simple search for neighbouring land point (not over panel bndries)
< 	    ii=nint(ri)
< 	    jj=nint(rj)
< 	    dist=100.
< 	    distnew=(nint(ri)+1-ri)**2 +(nint(rj)-rj)**2 
< 	    if(land(iq+1).and.distnew.lt.dist)then
< 	      ii=nint(ri)+1
< 	      dist=distnew
< 	    endif
< 	    distnew=(nint(ri)-1-ri)**2 +(nint(rj)-rj)**2 
< 	    if(land(iq-1).and.distnew.lt.dist)then
< 	      ii=nint(ri)-1
< 	      dist=distnew
< 	    endif
< 	    distnew=(nint(ri)-ri)**2 +(nint(rj)+1-rj)**2 
< 	    if(land(iq+il).and.distnew.lt.dist)then
< 	      jj=nint(rj)+1
< 	      dist=distnew
< 	    endif
< 	    distnew=(nint(ri)-ri)**2 +(nint(rj)-1-rj)**2 
< 	    if(land(iq-il).and.distnew.lt.dist)then
< 	      jj=nint(rj)-1
< 	      dist=distnew
< 	    endif
<            istn(nn)=ii
<            jstn(nn)=jj+nface*il
<            iq=istn(nn)+(jstn(nn)-1)*il
< 	  endif  ! (.not.land(iq))
1331,1344c1245,1258
< c!          n.b. following should only be for stretched grid
< c           if(nn.eq.2)alb(iq)=.16   ! fix-up for sydney     was   .13
< c           if(nn.eq.3)alb(iq)=.24   ! fix-up for adelaide   was   .18
< c           if(nn.eq.6)alb(iq)=.18   ! fix-up for brisbane   was   .12
< c           if(nn.eq.7)alb(iq)=.18   ! fix-up for perth      was   .13
< c           if(nn.eq.8)alb(iq)=.12   ! fix-up for darwin     was   .19
< c           if(nn.eq.10)alb(iq)=.16  ! fix-up for albury     was   .13
< c           if(nn.eq.2)sigmf(iq)=.5    ! fix-up for sydney
< c           if(nn.eq.3)sigmf(iq)=.5    ! fix-up for adelaide
< c           if(nn.eq.6)sigmf(iq)=.5    ! fix-up for brisbane
< c!***  n.b. nec sx4 vopt/hopt f90 compiler does not cope with next line!
< c           if(nn.eq.7)sigmf(iq)=.195  ! fix-up for perth
< c           if(nn.eq.8)sigmf(iq)=.5    ! fix-up for darwin
< c           if(nn.eq.8)zolnd(iq)=.3   ! fix-up for darwin     was   .79
---
> c!          N.B. following should only be for stretched grid
> c           if(nn.eq.2)alb(iq)=.16   ! fix-up for Sydney     was   .13
> c           if(nn.eq.3)alb(iq)=.24   ! fix-up for Adelaide   was   .18
> c           if(nn.eq.6)alb(iq)=.18   ! fix-up for Brisbane   was   .12
> c           if(nn.eq.7)alb(iq)=.18   ! fix-up for Perth      was   .13
> c           if(nn.eq.8)alb(iq)=.12   ! fix-up for Darwin     was   .19
> c           if(nn.eq.10)alb(iq)=.16  ! fix-up for Albury     was   .13
> c           if(nn.eq.2)sigmf(iq)=.5    ! fix-up for Sydney
> c           if(nn.eq.3)sigmf(iq)=.5    ! fix-up for Adelaide
> c           if(nn.eq.6)sigmf(iq)=.5    ! fix-up for Brisbane
> c!***  N.B. NEC SX4 vopt/hopt f90 compiler does not cope with next line!
> c           if(nn.eq.7)sigmf(iq)=.195  ! fix-up for Perth
> c           if(nn.eq.8)sigmf(iq)=.5    ! fix-up for Darwin
> c           if(nn.eq.8)zolnd(iq)=.3   ! fix-up for Darwin     was   .79
1347a1262,1266
>          tsoil=0.5*(0.3333*tgg(iq,2)+0.6667*tgg(iq,3)
>      &              +0.95*tgg(iq,4) +  0.05*tgg(iq,5))
>          ftsoil=max( 0. , 1.-.0016*(298.-tsoil)*max(0.,298.-tsoil) )
>          rlai= max(.1,rlaim44(iveg)-slveg44(iveg)*(1.-ftsoil))
>          rsminn = rsunc44(iveg)/rlai   ! this is used rather than read-in values
1352c1271
<      .    wb(iq,3),wet3,sigmf(iq),zolnd(iq),rsmin(iq),he(iq)
---
>      .    wb(iq,3),wet3,sigmf(iq),zolnd(iq),rsminn,he(iq)
1354,1356c1273,1275
<      .           4f5.2,f5.1,f7.1)
<         enddo  ! nn=1,nstn
<         if(mstn.eq.2)then   ! then eva's stn2 values too
---
>      .           4f5.2,f5.0,f7.1)
>         enddo  ! nn
>         if(mstn.eq.2)then   ! then Eva's stn2 values too
1375c1294
< c     subroutine to read in  data sets required for biospheric scheme.
---
> c     Subroutine to read in  data sets required for biospheric scheme.
1389,1393c1308,1312
<       parameter( ivegdflt=1, isoildflt=7, ico2dflt = 999 )
<       parameter( falbdflt=15., fsoildflt=0.15, frsdflt=990.)
<       parameter( fzodflt=1.)
<       data idatafix/0/
<       logical rdatacheck,idatacheck,mismatch
---
>       parameter( iVEGDFLT=1, iSOILDFLT=7, iCO2DFLT = 999 )
>       parameter( fALBDFLT=15., fSOILDFLT=0.15, fRSDFLT=990.)
>       parameter( fZODFLT=1.)
>       data idataFix/0/
>       logical rDataCheck,iDataCheck,mismatch
1405c1324
<        call readreal(rsmfile,rsmin,ifull)  ! not used these days
---
>        call readreal(rsmfile,rsmin,ifull)
1411,1421c1330,1340
<        mismatch = .false.
<        if( rdatacheck(land,alb,'alb',idatafix,falbdflt))
<      .      mismatch = .true.
<        if( rdatacheck(land,rsmin,'rsmin',idatafix,frsdflt))
<      .      mismatch = .true.
<        if( rdatacheck(land,zolnd,'zolnd',idatafix,fzodflt))
<      .      mismatch = .true.
<        if( idatacheck(land,ivegt,'ivegt',idatafix,ivegdflt))
<      .      mismatch = .true.
<        if( idatacheck(land,isoilm,'isoilm',idatafix,isoildflt))
<      .      mismatch = .true.
---
>        mismatch = .FALSE.
>        if( rDataCheck(land,alb,'alb',idataFix,fALBDFLT))
>      .      mismatch = .TRUE.
>        if( rDataCheck(land,rsmin,'rsmin',idataFix,fRSDFLT))
>      .      mismatch = .TRUE.
>        if( rDataCheck(land,zolnd,'zolnd',idataFix,fZODFLT))
>      .      mismatch = .TRUE.
>        if( iDataCheck(land,ivegt,'ivegt',idataFix,iVEGDFLT))
>      .      mismatch = .TRUE.
>        if( iDataCheck(land,isoilm,'isoilm',idataFix,iSOILDFLT))
>      .      mismatch = .TRUE.
1424,1427c1343,1346
<          if(rdatacheck(land,wb(1,1),'w',idatafix,fsoildflt))
<      .            mismatch  =.true.
<          if(rdatacheck(land,wb(1,ms),'w2',idatafix,fsoildflt))
<      .            mismatch  =.true.
---
>          if(rDataCheck(land,wb(1,1),'w',idataFix,fSOILDFLT))
>      .            mismatch  =.TRUE.
>          if(rDataCheck(land,wb(1,ms),'w2',idataFix,fSOILDFLT))
>      .            mismatch  =.TRUE.
1429c1348
<        if(ico2.gt.0) then
---
>        if(ico2.GT.0) then
1432,1433c1351,1352
< !        if( jdatacheck(land,ico2em,'ico2em',idatafix,ico2dflt))
< !    .     mismatch = .true.
---
> !        if( jDataCheck(land,ico2em,'ico2em',idataFix,iCO2DFLT))
> !    .     mismatch = .TRUE.
1436,1437c1355,1356
< c      if(mismatch.and.idatafix.eq.0)      ! stop in indata for veg
< c    .                      stop ' rdnsib: landmask/field mismatch'
---
> c      if(mismatch.and.idataFix.EQ.0)      ! stop in indata for veg
> c    .                      stop ' RdNsib: landmask/field mismatch'
1439c1358
< c --- rescale and patch up vegie data if necessary
---
> c --- rescale and patch up data if necessary
1448,1449c1367,1368
<        print *,'**** in this run veg types increased from 1-13 to 32-44'
<        do iq=1,ifull        ! add offset to sib values so 1-13 becomes 32-44
---
>        print *,'**** In this run veg types increased from 1-13 to 32-44'
>        do iq=1,ifull        ! add offset to Sib values so 1-13 becomes 32-44
1472,1474c1391,1393
< c     set sensible default for nso2lev for vertmix, in case so2 not done
<       nso2lev=1
<       if( iso2.gt.0) then
---
> c     set sensible default for nSO2lev for vertmix, in case so2 not done
>       nSO2lev=1
>       if( iSO2.GT.0) then
1476,1477c1395,1396
<         call rdso2em( so2emfile, iso2em, jso2em, so2em, iso2emindex,
<      .      iso2lev, nso2lev, so2background, nso2slev, nso2sour )
---
>         call RdSO2em( SO2emfile, iSO2em, jSO2em, SO2em, iSO2emIndex,
>      .      iSO2lev, nSO2lev, SO2BackGround, nSO2SLEV, nSO2SOUR )
1483,1484c1402,1403
<       subroutine rdso2em( file, iso2em, jso2em, so2em, iso2emindex,
<      .       iso2lev, nso2lev, so2background, nsulfl, ns )
---
>       Subroutine RdSO2em( file, iSO2em, jSO2em, SO2em, iSO2emIndex,
>      .       iSO2lev, nSO2lev, SO2BackGround, nsulfl, ns )
1491,1493c1410,1412
<       integer iso2em(2,ns), jso2em(ns)
<       integer iso2emindex(ns), iso2lev(0:nsulfl)
<       real    so2em(ns)
---
>       integer iSO2em(2,ns), jSO2em(ns)
>       integer iSO2emIndex(ns), iSO2lev(0:nsulfl)
>       real    SO2em(ns)
1497,1500c1416,1419
<        nso2src = 0
<        open (unit=ludat,file=so2emfile,status='old',form='formatted')
<        print *,'rdso2em: reading in so2'
<        print *,'!!!!!!!!!!!!!! rdnsib: ds =',ds
---
>        nSO2src = 0
>        open (unit=ludat,file=SO2emfile,status='old',form='formatted')
>        print *,'RdSO2em: reading in SO2'
>        print *,'!!!!!!!!!!!!!! RDNSIB: ds =',ds
1506c1425
< * 64.065 molecular weight of so2
---
> * 64.065 molecular weight of SO2
1513,1516c1432,1435
<        read( ludat,'(50x,f9.2)',end=30 ) so2background
<        write( *,* ) ' rdso2em: so2 backgroud source value is',
<      .               so2background
<        so2background = so2background/factor
---
>        read( ludat,'(50x,f9.2)',end=30 ) SO2BackGround
>        write( *,* ) ' RdSO2em: SO2 backgroud source value is',
>      .               SO2BackGround
>        SO2BackGround = SO2BackGround/factor
1521c1440
<        nso2src = nso2src+1
---
>        nSO2src = nSO2src+1
1525c1444
< c iso2em - first index along the parallels
---
> c iSO2em - first index along the parallels
1528c1447
< c so2em  - emission values at iso2em grid point
---
> c SO2em  - emission values at iSO2em grid point
1531,1533c1450,1452
< c      write(*,*)' rdso2em: rlat,rlon,ri,rj',rlat,rlon,ri,rj
< c      iso2em(1,nso2src) = ri+.5
< c      iso2em(2,nso2src) = rj+.5
---
> c      write(*,*)' RdSO2em: rlat,rlon,ri,rj',rlat,rlon,ri,rj
> c      iSO2em(1,nSO2src) = ri+.5
> c      iSO2em(2,nSO2src) = rj+.5
1535c1454
< c this is a rough treatment: 500m 3rd level
---
> c This is a rough treatment: 500m 3rd level
1538,1541c1457,1460
<        if( height.gt.400.) then
<          jso2em(nso2src) = 3
<        else if( height.gt.200.) then
<          jso2em(nso2src) = 2
---
>        if( height.GT.400.) then
>          jSO2em(nSO2src) = 3
>        else if( height.GT.200.) then
>          jSO2em(nSO2src) = 2
1543c1462
<          jso2em(nso2src) = 1
---
>          jSO2em(nSO2src) = 1
1546,1549c1465,1468
<        ix = iso2em(1,nso2src)
<        jx = iso2em(2,nso2src)
< !      so2em(nso2src) = rmult*eso2/factor/em(ix,jx)**2
< !        write(*,*) rmult,ix,jx,so2em(nso2src),factor,em(ix,jx)
---
>        ix = iSO2em(1,nSO2src)
>        jx = iSO2em(2,nSO2src)
> !      SO2em(nSO2src) = rmult*eSO2/factor/em(ix,jx)**2
> !        write(*,*) rmult,ix,jx,SO2em(nSO2src),factor,em(ix,jx)
1554c1473
<        write(*,*) 'rdso2em: read',nso2src,' sources from file ',file
---
>        write(*,*) 'RdSO2em: read',nSO2src,' sources from file ',file
1558,1561c1477,1480
<        write(*,*) 'rdso2em: nsulfl =', nsulfl
<        do i=1,nso2src
<          write(*,'(3i4,1pe12.4)') (iso2em(jj,i),jj=1,2),
<      .                            jso2em(i), so2em(i)
---
>        write(*,*) 'RdSO2em: nsulfl =', nsulfl
>        do i=1,nSO2src
>          write(*,'(3i4,1pe12.4)') (iSO2em(jj,i),jj=1,2),
>      .                            jSO2em(i), SO2em(i)
1565,1566c1484,1485
<        call iindexx(nso2src,jso2em,iso2emindex )
<        write(*,*) 'rdso2em: after iindexx'
---
>        call iindexx(nSO2src,jSO2em,iSO2emIndex )
>        write(*,*) 'RdSO2em: after iindexx'
1568,1574c1487,1493
< c if the highest level is above nsulfl, then i'm overwriting something --- quit
<       ix0 = jso2em( iso2emindex(nso2src) )
<       if( ix0.gt.nsulfl ) then
<         write(*,*) ' rdso2em: level value out of range: jso2em(iso2emind
<      .ex(nso2src)), iso2emindex(nso2src), nso2src =',
<      .    jso2em( iso2emindex(nso2src) ),iso2emindex(nso2src),nso2src
<           stop 'rdso2em: execution terminated due to error(s) (1)'
---
> C if the highest level is above nsulfl, then I'm overwriting something --- QUIT
>       ix0 = jSO2em( iSO2emIndex(nSO2src) )
>       if( ix0.GT.nsulfl ) then
>         write(*,*) ' RdSO2em: level value out of range: jSO2em(iSO2emInd
>      .ex(nSO2src)), iSO2emIndex(nSO2src), nSO2src =',
>      .    jSO2em( iSO2emIndex(nSO2src) ),iSO2emIndex(nSO2src),nSO2src
>           stop 'RdSO2em: execution terminated due to error(s) (1)'
1577,1590c1496,1509
< c index the level range in array iso2em
<       iso2lev(   0 ) = 0
<       iso2lev( ix0 ) = nso2src
<       nso2lev = ix0
<       write(*,*) 'ix0, iso2lev(ix0)',ix0, iso2lev(ix0)
<       do i=nso2src-1, 1, -1
<          ix = jso2em( iso2emindex(i) )
<          if( ix.gt.nsulfl ) then
<            write(*,*) ' rdso2em: level value out of range: jso2em(iso2em
<      .index(i)), iso2emindex(i), i =',
<      .     jso2em( iso2emindex(i) ),iso2emindex(i),i
<            stop 'rdso2em: execution terminated due to error(s) (2)'
<          else if( ix.ne.ix0 ) then
<            iso2lev( ix ) = i
---
> c index the level range in array iSO2em
>       iSO2lev(   0 ) = 0
>       iSO2lev( ix0 ) = nSO2src
>       nSO2lev = ix0
>       write(*,*) 'ix0, iSO2lev(ix0)',ix0, iSO2lev(ix0)
>       do i=nSO2src-1, 1, -1
>          ix = jSO2em( iSO2emIndex(i) )
>          if( ix.GT.nsulfl ) then
>            write(*,*) ' RdSO2em: level value out of range: jSO2em(iSO2em
>      .Index(i)), iSO2emIndex(i), i =',
>      .     jSO2em( iSO2emIndex(i) ),iSO2emIndex(i),i
>            stop 'RdSO2em: execution terminated due to error(s) (2)'
>          else if( ix.NE.ix0 ) then
>            iSO2lev( ix ) = i
1592,1593c1511,1512
<            write(*,*) 'ix , iso2lev(ix )',
<      .                 ix, iso2lev(ix)
---
>            write(*,*) 'ix , iSO2lev(ix )',
>      .                 ix, iSO2lev(ix)
1598c1517
<        write(*,*) 'rdso2em: sources after sorting'
---
>        write(*,*) 'RdSO2em: sources after sorting'
1602,1605c1521,1524
<        do i=1,nso2src
<          ix = iso2emindex(i)
<          write(*,'(4i4,1pe12.4)') i,(iso2em(jj,ix),jj=1,2),
<      .                            jso2em(ix), so2em(ix)
---
>        do i=1,nSO2src
>          ix = iSO2emIndex(i)
>          write(*,'(4i4,1pe12.4)') i,(iSO2em(jj,ix),jj=1,2),
>      .                            jSO2em(ix), SO2em(ix)
1608c1527
< c      stop 'rdso2em: about to exit routine'
---
> c      stop 'RdSO2em: about to exit routine'
1611c1530
< 30     stop 'rdso2em: error in so2 emissions file (background)'
---
> 30     stop 'RdSO2em: error in SO2 emissions file (background)'
1614c1533
<       function rdatacheck( mask,fld,lbl,idfix,val )
---
>       Function rDataCheck( mask,fld,lbl,idFix,val )
1620,1621c1539,1540
<       logical rdatacheck, sdatacheck, idatacheck, jdatacheck
<       logical toval, err
---
>       logical rDataCheck, sDataCheck, iDataCheck, jDataCheck
>       logical toVal, err
1625c1544
<       toval =.true.
---
>       toVal =.TRUE.
1628c1547
<       entry sdatacheck( mask,fld,lbl,idfix,val )
---
>       Entry sDataCheck( mask,fld,lbl,idFix,val )
1631c1550
<       toval =.false.
---
>       toVal =.FALSE.
1633c1552
< 10    write(*,*)' datacheck: verifying field ',lbl
---
> 10    write(*,*)' DataCheck: verifying field ',lbl
1635c1554
<       err =.false.
---
>       err =.FALSE.
1639,1641c1558,1560
<             if( fld(iq).eq.from ) then
<               err = .true.
<               if( idfix.eq.1 ) then
---
>             if( fld(iq).EQ.from ) then
>               err = .TRUE.
>               if( idFix.EQ.1 ) then
1652,1653c1571,1572
<       if( toval ) then
<         rdatacheck = err
---
>       if( toVal ) then
>         rDataCheck = err
1655c1574
<         sdatacheck = err
---
>         sDataCheck = err
1659c1578
<       entry idatacheck( mask,ifld,lbl,idfix,ival )
---
>       Entry iDataCheck( mask,ifld,lbl,idFix,ival )
1662c1581
<       toval =.true.
---
>       toVal =.TRUE.
1665c1584
<       entry jdatacheck( mask,ifld,lbl,idfix,ival )
---
>       Entry jDataCheck( mask,ifld,lbl,idFix,ival )
1668c1587
<       toval =.false.
---
>       toVal =.FALSE.
1670,1671c1589,1590
< 20    write(*,*)' datacheck: verifying field ',lbl
<       err =.false.
---
> 20    write(*,*)' DataCheck: verifying field ',lbl
>       err =.FALSE.
1674,1676c1593,1595
<             if( ifld(iq).eq.ifrom ) then
<               err = .true.
<               if( idfix.eq.1 ) then
---
>             if( ifld(iq).EQ.ifrom ) then
>               err = .TRUE.
>               if( idFix.EQ.1 ) then
1687,1688c1606,1607
<       if( toval ) then
<         idatacheck = err
---
>       if( toVal ) then
>         iDataCheck = err
1690c1609
<         jdatacheck = err
---
>         jDataCheck = err
1695c1614
<       subroutine tracini
---
>       Subroutine TracIni
1701c1620
<       data fco2/357.0/, fradon/0.0/, fso2/0.0/, fo2/2.1e5/
---
>       data fCO2/357.0/, fRADON/0.0/, fSO2/0.0/, fO2/2.1e5/
1703c1622
<       if( ico2.ne.0.) then
---
>       if( iCO2.NE.0.) then
1705,1706c1624,1627
<      .      .and.rlong0.ge.137.5 .and. rlong0.le.138.5)fco2=0.
<         tr(:,:,max(1,ico2))=fco2
---
>      .      .and.rlong0.ge.137.5 .and. rlong0.le.138.5)fCO2=0.
>         do kq=1,ijk
>           tr(kq,1,iCO2)=fCO2
>         end do
1709,1710c1630,1633
<       if( iradon.ne.0.) then
<         tr(:,:,max(1,iradon))=fradon
---
>       if( iRADON.NE.0.) then
>         do kq=1,ijk
>           tr(kq,1,iRADON)=fRADON
>         end do
1713,1714c1636,1639
<       if( iso2.ne.0. ) then
<         tr(:,:,max(1,iso2))=fso2
---
>       if( iSO2.NE.0. ) then
>         do kq=1,ijk
>           tr(kq,1,iSO2  )=fSO2
>         end do
1717,1718c1642,1645
<       if( io2.ne.0. ) then
<         tr(:,:,max(1,io2))=fo2
---
>       if( iO2.NE.0. ) then
>         do kq=1,ijk
>           tr(kq,1,iO2  )=fO2
>         end do
1769c1696
< !     n.b. presets for soilv.h moved to blockdata
---
> !     N.B. presets for soilv.h moved to blockdata
1772a1700
>          tgmax(isoil) = (sormax(isoil)/hyds(isoil))**2  ! [s]
1829,1830c1757,1758
< c kf, 1997
< c for each vegetation type (= iv), assign veg height, total lai, albedo,
---
> c KF, 1997
> c For each vegetation type (= iv), assign veg height, total LAI, albedo,
1832,1834c1760,1762
< c jmax0 assigned due to table by ray leuning and estimates  21-08-97 
< c apply seasonal variations in lai and height. return via /canopy/
< c nb: total lai = xrlai, veglai = xvlai, veg cover fraction = xpfc,
---
> c Jmax0 assigned due to table by Ray Leuning and estimates  21-08-97 
> c Apply seasonal variations in LAI and height. Return via /canopy/
> c NB: total LAI = xrlai, vegLAI = xvlai, veg cover fraction = xpfc,
1836,1838c1764,1766
< c type  0 to 31: 2d version with graetz veg types
< c type 32 to 43: 2d version with gcm veg types
< c type 44:       stand-alone version
---
> c Type  0 to 31: 2D version with Graetz veg types
> c Type 32 to 43: 2D version with GCM veg types
> c Type 44:       stand-alone version
1840,1873c1768,1801
< c   name                             symbol  code hc:cm pfc:%  veglai
< c   ocean                                oc     0     0     0  0.0
< c   tall dense forest                    t4     1  4200   100  4.8
< c   tall mid-dense forest                t3     2  3650    85  6.3
< c   dense forest                         m4     3  2500    85  5.0  (?)
< c   mid-dense forest                     m3     4  1700    50  3.75
< c   sparse forest (woodland)             m2     5  1200    20  2.78
< c   very sparse forest (woodland)        m1     6  1000     5  2.5
< c   low dense forest                     l4     7   900    85  3.9
< c   low mid-dense forest                 l3     8   700    50  2.77
< c   low sparse forest (woodland)         l2     9   550    20  2.04
< c   tall mid-dense shrubland (scrub)     s3    10   300    50  2.6
< c   tall sparse shrubland                s2    11   250    20  1.69
< c   tall very sparse shrubland           s1    12   200     5  1.9
< c   low mid-dense shrubland              z3    13   100    50  1.37
< c   low sparse shrubland                 z2    14    60    20  1.5
< c   low very sparse shrubland            z1    15    50     5  1.21
< c   sparse hummock grassland             h2    16    50    20  1.58
< c   very sparse hummock grassland        h1    17    45     5  1.41
< c   dense tussock grassland              g4    18    75    85  2.3
< c   mid-dense tussock grassland          g3    19    60    50  1.2
< c   sparse tussock grassland             g2    20    45    20  1.71
< c   very sparse tussock grassland        g1    21    40     5  1.21
< c   dense pasture/herbfield (perennial)  f4    22    60    85  2.3
< c   dense pasture/herbfield (seasonal)  f4s    23    60    85  2.3
< c   mid-dense pasture/herb (perennial)   f3    24    45    50  1.2
< c   mid-dense pasture/herb  (seasonal)  f3s    25    45    50  1.2
< c   sparse herbfield*                    f2    26    35    20  1.87
< c   very sparse herbfield                f1    27    30     5  1.0
< c   littoral                             ll    28   250    50  3.0
< c   permanent lake                       pl    29     0     0  0
< c   ephemeral lake (salt)                sl    30     0     0  0
< c   urban                                 u    31     0     0  0
< c   stand alone: hc,rlai from param1      -    44     -   100  -
---
> c   Name                             Symbol  Code hc:cm PFC:%  vegLAI
> c   Ocean                                Oc     0     0     0  0.0
> c   Tall dense forest                    T4     1  4200   100  4.8
> c   Tall mid-dense forest                T3     2  3650    85  6.3
> c   Dense forest                         M4     3  2500    85  5.0  (?)
> c   Mid-dense forest                     M3     4  1700    50  3.75
> c   Sparse forest (woodland)             M2     5  1200    20  2.78
> c   Very sparse forest (woodland)        M1     6  1000     5  2.5
> c   Low dense forest                     L4     7   900    85  3.9
> c   Low mid-dense forest                 L3     8   700    50  2.77
> c   Low sparse forest (woodland)         L2     9   550    20  2.04
> c   Tall mid-dense shrubland (scrub)     S3    10   300    50  2.6
> c   Tall sparse shrubland                S2    11   250    20  1.69
> c   Tall very sparse shrubland           S1    12   200     5  1.9
> c   Low mid-dense shrubland              Z3    13   100    50  1.37
> c   Low sparse shrubland                 Z2    14    60    20  1.5
> c   Low very sparse shrubland            Z1    15    50     5  1.21
> c   Sparse hummock grassland             H2    16    50    20  1.58
> c   Very sparse hummock grassland        H1    17    45     5  1.41
> c   Dense tussock grassland              G4    18    75    85  2.3
> c   Mid-dense tussock grassland          G3    19    60    50  1.2
> c   Sparse tussock grassland             G2    20    45    20  1.71
> c   Very sparse tussock grassland        G1    21    40     5  1.21
> c   Dense pasture/herbfield (perennial)  F4    22    60    85  2.3
> c   Dense pasture/herbfield (seasonal)  F4S    23    60    85  2.3
> c   Mid-dense pasture/herb (perennial)   F3    24    45    50  1.2
> c   Mid-dense pasture/herb  (seasonal)  F3S    25    45    50  1.2
> c   Sparse herbfield*                    F2    26    35    20  1.87
> c   Very sparse herbfield                F1    27    30     5  1.0
> c   Littoral                             LL    28   250    50  3.0
> c   Permanent lake                       PL    29     0     0  0
> c   Ephemeral Lake (salt)                SL    30     0     0  0
> c   Urban                                 U    31     0     0  0
> c   STAND ALONE: hc,rlai from param1      -    44     -   100  -
1875c1803
< c   above are dean's. below are sib (add 31 to get model iveg)
---
> c   above are Dean's. Below are sib (add 31 to get model iveg)
1881c1809
< c  6 - broadleaf trees with ground cover (savannah)
---
> c  6 - broadleaf trees with ground cover (Savannah)
1889,1890c1817,1818
< c                             soil type
< c       texture               
---
> c                             Soil type
> c       Texture               
1909,1910c1837,1838
< c aerodynamic parameters, diffusivities, water density:
<       parameter(vonk   = 0.40,     ! von karman constant
---
> c Aerodynamic parameters, diffusivities, water density:
>       parameter(vonk   = 0.40,     ! von Karman constant
1912,1914c1840,1842
<      &          csw    = 0.50,     ! canopy sw decay (weil theory)
<      &          ctl    = 0.40)     ! wagga wheat (rdd 1992, challenges)
< c vegetation height
---
>      &          csw    = 0.50,     ! canopy sw decay (Weil theory)
>      &          ctl    = 0.40)     ! Wagga wheat (RDD 1992, Challenges)
> c Vegetation height
1920c1848
<      & 32.,20.,20.,17.,17., 1., 1., 1., 0.5, 0.6, 0., 1.,0./ !sellers 1996 j.climate
---
>      & 32.,20.,20.,17.,17., 1., 1., 1., 0.5, 0.6, 0., 1.,0./ !Sellers 1996 J.Climate
1922c1850
< c vegetation fractional cover
---
> c Vegetation fractional cover
1930,1931c1858,1859
< c veg lai from graetz table of 283 veg types (iv=0 to 31), and maximum 
< c veg lai for gcm veg types (iv=32 to 43)  stand-alone: 44
---
> c Veg LAI from Graetz table of 283 veg types (iv=0 to 31), and maximum 
> c Veg LAI for GCM veg types (iv=32 to 43)  stand-alone: 44
1939c1867
< c for seasonally varying lai, amplitude of veg lai seasonal change
---
> c For seasonally varying LAI, amplitude of veg LAI seasonal change
1946c1874
< c leaf gsmax for forest (0.006), grass (0.008) and crop (0.012)
---
> c Leaf gsmax for forest (0.006), grass (0.008) and crop (0.012)
1963,1965c1891,1893
< c assign aerodynamic, radiative, stomatal, interception properties
< c assign total lai (xrlai) from veg lai and pfc, and assign seasonal 
< c   variation in lai and veg height where necessary. this is controlled
---
> c Assign aerodynamic, radiative, stomatal, interception properties
> c Assign total LAI (xrlai) from veg LAI and PFC, and assign seasonal 
> c   variation in LAI and veg height where necessary. This is controlled
1972c1900
< c   find roughness length z0m from hc and rlai:
---
> c   Find roughness length z0m from hc and rlai:
1974c1902
< c   set aerodynamic variables for bare soil and vegetated cases:
---
> c   Set aerodynamic variables for bare soil and vegetated cases:
1977c1905
<         z0m    = zobgin      ! bare soil surface
---
>         z0m    = zobgin      ! BARE SOIL SURFACE
1987,1989c1915,1917
< c see: raupach, 1992, blm 60 375-395
< c      mrr notes "simplified wind model for canopy", 23-oct-92
< c      mrr draft paper "simplified expressions...", dec-92
---
> c see: Raupach, 1992, BLM 60 375-395
> c      MRR notes "Simplified wind model for canopy", 23-oct-92
> c      MRR draft paper "Simplified expressions...", dec-92
1999,2000c1927,1928
< c           u(z) = u(h)*exp(coexp*(z/h-1)), found by gradient-matching
< c           canopy and roughness-sublayer u(z) at z=h
---
> c           U(z) = U(h)*exp(coexp*(z/h-1)), found by gradient-matching
> c           canopy and roughness-sublayer U(z) at z=h
2009c1937
<      &           vonk  = 0.4)          ! von karman constant
---
>      &           vonk  = 0.4)          ! von Karman constant
2014c1942
<       usuh   = min(usuhl,usuhm)
---
>       USUH   = min(usuhl,usuhm)
=====================================
 
infile.f
=====================================
12c12
< !     From March 2000 exact kdate, ktime are calculated and compared
---
> !     From March 2000 exact kdate, ktime are calculated and compared. kstart=1
95c95
<         write (6,"('100*psl# in',3f7.2,1x,3f7.2,1x,3f7.2)") 
---
>         write (6,"('100*psl# in',9f7.2)") 
99c99
<         write (6,"('zs# in  ',3f7.1,1x,3f7.1,1x,3f7.1)") 
---
>         write (6,"('zs# in  ',9f7.1)") 
104c104
<         write (6,"('tss# in ',3f7.1,1x,3f7.1,1x,3f7.1)") 
---
>         write (6,"('tss# in ',9f7.1)") 
106c106
<         write (6,"('prec# in',3f7.2,1x,3f7.2,1x,3f7.2)") 
---
>         print *,'precip# in: ',
180c180
< c       when no snowd available initially, e.g. COMPARE III (jlm formula)
---
> c       when no snowd available initially, e.g. COMPARE III
263,264c263,264
<       print *,'kdate_r,ktime_r: ',kdate_r,ktime_r,
<      .        'kdate_s,ktime_s >= ',kdate_s,ktime_s
---
>       print *,'kdate_s,ktime_s,kdate_r,ktime_r: ',
>      .         kdate_s,ktime_s,kdate_r,ktime_r
278c278
<      &   timeg,ds_r,psl,zs,tss,
---
>      &   timeg,ds_r,psl,pmsl,zs,tss,
282c282
<           write (6,"('100*psl# in',3f7.2,1x,3f7.2,1x,3f7.2)") 
---
>           write (6,"('100*psl# in',9f7.2)") 
284c284
<           write (6,"('zs# in  ',3f7.1,1x,3f7.1,1x,3f7.1)") 
---
>           write (6,"('zs# in  ',9f7.1)") 
290c290
<           write (6,"('tss# in ',3f7.1,1x,3f7.1,1x,3f7.1)") 
---
>           write (6,"('tss# in ',9f7.1)") 
292c292
<           write (6,"('prec# in',3f7.2,1x,3f7.2,1x,3f7.2)") 
---
>           print *,'precip# in: ',
344c344
<       print *,'end infile; next read will be kdate_s,ktime_s >= ',
---
>       print *,'end infile; next read will be kdate_s,ktime_s ',
352c352
<      & timeg,ds_r,psl,zs,tss,
---
>      & timeg,ds_r,psl,pmsl,zs,tss,
359,360c359,360
<       include 'liqwpar.h'  ! ifullw
<       include 'mapproj.h'   ! du,tanl,rnml,stl1,stl2
---
>       include 'liqwpar.h'
>       include 'mapproj.h'  ! du,tanl,rnml,stl1,stl2
366,368c366,368
<       include 'soil.h'      !  alb, sicedep
<       include 'soilsnow.h'  ! with nested=0/1 option
<       include 'stime.h'     ! kdate_s,ktime_s  sought values for data read
---
>       include 'soil.h'     !  alb, sicedep
>       include 'soilsnow.h'   ! with nested=0/1 option
>       include 'stime.h'   ! kdate_s,ktime_s  sought values for data read
371c371
<       real psl(ifull),zs(ifull),tss(ifull),
---
>       real psl(ifull),pmsl(ifull),zs(ifull),tss(ifull),
467,470d466
< !         assume very old file 	   
<           rlong0x =0.
<           rlat0x  =0.
<           schmidtx=1.
686,687c682,683
<         print *,'kdate,ktime: ',kdate,ktime,
<      .          'kdate_s,ktime_s >= ',kdate_s,ktime_s
---
>         print *,'kdate_s,ktime_s,kdate,ktime ',
>      .           kdate_s,ktime_s,kdate,ktime
689c685,686
<         print *,'in newin; ktau_r,timer: ',ktau_r,timer
---
>         print *,'in newin; ktau_r,kstart,timer: ',
>      .                     ktau_r,kstart,timer
733c730
< c     turn OFF fatal netcdf errors; from here on
---
> c     turn OFF fatal netcdf errors
739,747c736,737
<       if(ifullw.eq.ifull)then
<         call histrd4(ncid,iarch,ier,'qfg',ik,jk,kk,qfg)       !  kg/kg
<         call histrd4(ncid,iarch,ier,'qlg',ik,jk,kk,qlg)       !  kg/kg
<         if(ier.ne.0)then
< !         set default qfg, qlg to zero if not available on input file	
<           qfg=0. 
<           qlg=0. 
<         endif
<       endif     ! (ifullw.eq.ifull)
---
> c     turn on fatal netcdf errors
>       call ncpopt(NCVERBOS+NCFATAL)
751a742,746
> c       turn OFF fatal netcdf errors
>         call ncpopt(0)
>         call histrd4(ncid,iarch,ier,'qc',ik,jk,kk,qc)
>         call histrd4(ncid,iarch,ier,'qp',ik,jk,kk,qp)
> 
770,771c765,766
<             tgg(iq,3)=tgg(iq,2) ! initial temper. from GCM runs with 3 layers
<             wb(iq,1) =wb(iq,2)  ! layer initialisation of moisture
---
>             tgg(iq,3)=tgg(iq,2)   ! initial temper. from GCM runs with 3 layers
>             wb(iq,1) =wb(iq,2)    ! layer initialisation of moisture
773c768
<            do k=3,ms-1          ! don't want to change value of tgg(,2) and tgg(,ms)
---
>            do k=3,ms-1           ! don't want to change value of tgg(,2) and tgg(,ms)
791,792c786,787
<             tgg(iq,3)=tgg(iq,2) ! initial temper. from GCM runs with 3 layers
<             wb(iq,1) =wb(iq,2)  ! layer initialisation of moisture
---
>             tgg(iq,3)=tgg(iq,2)   ! initial temper. from GCM runs with 3 layers
>             wb(iq,1) =wb(iq,2)    ! layer initialisation of moisture
794c789
<            do k=3,ms-1          ! don't want to change value of tgg(,2) and tgg(,ms)
---
>            do k=3,ms-1           ! don't want to change value of tgg(,2) and tgg(,ms)
808c803
< !         when no snowd available initially, e.g. COMPARE III (jlm formula)
---
> !         when no snowd available initially, e.g. COMPARE III
870,879d864
<         if(ier.ne.0)then  ! for siced
<  	   print *,'pre-setting siced in newin'
<           do iq=1,ifull
<            if(tss(iq).le.271.2)then
<              sicedep(iq)=2. 
<            else
<              sicedep(iq)=0.     
<            endif
<         enddo   ! iq loop
< 	 endif
886c871
<       endif  ! (nested.eq.0)   !  only done at start of run 
---
>       endif  ! (nested.eq.0)   !  following only at start of run #############
900c885
< !     common/work3/dont_use(ifull,kl,3),ivar(ijk),spare(ijk)
---
> !     common/work3/dont_use(ifull,kl,3),ivar(ijk)
974c959
< !     common/work3/dont_use(ifull,kl,3),ivar(ijk),spare(ijk)
---
> !     common/work3/dont_use(ifull,kl,3),ivar(ijk)
1045c1030
<       common/work3/dum3(ifull,kl,3),told(ifull,kl),spare(ijk)
---
>       common/work3/dum3(ifull,kl,3),told(ifull,kl)
1087c1072,1075
<       told(:,:)=t(:,:)
---
>       do kq=1,ijk
>        told(kq,1)=t(kq,1)
>       enddo
> 
1105c1093,1095
<         t(:,:)=max(t(:,:),1.e-6)
---
>         do kq=1,ijk
>          t(kq,1)=max(t(kq,1),1.e-6)
>         enddo
=====================================
 
int2.f
=====================================
=====================================
 
ints.f
=====================================
5c5
< c     parameter (mh_bs): B&S on/off depending on value of nfield
---
> c     parameter (m_bs): m_bs=0 for B&S off; 2 for B&S on; -2 on for gases only
10d9
< !     nfield: 1 (psl), 2 (u, v), 3 (T), 4 (gases)
11a11
>       parameter (nspeedy=0)  ! 0 simple code, 1 more vectorized (but slower!)
14c14
<       include 'parmhor.h'    ! has mh_bs
---
>       include 'parmhor.h'    ! has m_bs
17c17
<      .       ,dum2(3*ifull -(il+4)*(il+4)*(npanels+1) )
---
>      .       ,dum2(2*ifull -(il+4)*(il+4)*(npanels+1) )
30a31
>       if(nspeedy.eq.0)then
37a39,47
>       else
> !       jlm notes: above loop can be vectorized by something like
> !       or else set up permutation arrays in indata
>         do iq=1,ifull    !  this one not using n loop
>          ix=iq +4*((iq-1)/il) +4*(il+4)*((iq-1)/(il*il))
>          sx(ix,1,0)=s(iq)
> !        if(ktau.eq.1.and.mod(iq,il).eq.1)print *,'iq,ix ',iq,ix
>         enddo ! iq loop
>       endif   ! (nspeedy.eq.0)
85c95
<         if(nfield.lt.mh_bs)then
---
>         if(m_bs.eq.0.or.(m_bs.eq.-2.and.nfield.lt.4))then
92,95c102,105
< c          if(ntest.eq.1)then
< c            if(xxg.lt.0..or.xxg.gt.1..or.yyg.lt.0..or.yyg.gt.1.)
< c    .        print *,'intsb problem iq xxg,yyg ',iq,xxg,yyg
< c          endif
---
>            if(ntest.eq.1)then
>              if(xxg.lt.0..or.xxg.gt.1..or.yyg.lt.0..or.yyg.gt.1.)
>      .        print *,'intsb problem iq xxg,yyg ',iq,xxg,yyg
>            endif
140c150
<         else                      ! (nfield.lt.mh_bs)
---
>         else                      ! m_bs.eq.0.or.(m_bs.eq.-2.and.nfield.lt.4)
151,152c161,164
<             cmin=min( 1.e20,c2,c3)   ! Bermejo & Staniforth
<             cmax=max(-1.e20,c2,c3)   ! Bermejo & Staniforth
---
> !           if(m_bs.eq.2)then
>               cmin=min( 1.e20,c2,c3)   ! Bermejo & Staniforth
>               cmax=max(-1.e20,c2,c3)   ! Bermejo & Staniforth
> !           endif
166,167c178,181
<             cmin=min(cmin,c2,c3)   ! Bermejo & Staniforth
<             cmax=max(cmax,c2,c3)   ! Bermejo & Staniforth
---
> !           if(m_bs.eq.2)then
>               cmin=min(cmin,c2,c3)   ! Bermejo & Staniforth
>               cmax=max(cmax,c2,c3)   ! Bermejo & Staniforth
> !           endif
194c208,212
<           s(iq)=min(max(cmin,sss),cmax)   ! Bermejo & Staniforth
---
> !         if(m_bs.eq.2)then
>              s(iq)=min(max(cmin,sss),cmax)   ! Bermejo & Staniforth
> !          else
> !            s(iq)=sss
> !          endif   ! m_bs.eq.2
196c214
<         endif      ! (nfield.lt.mh_bs)  .. else ..
---
>         endif      ! m_bs.eq.0.or.(m_bs.eq.-2.and.nfield.lt.4)  .. else ..
244c262
<         if(nfield.lt.mh_bs)then
---
>         if(m_bs.eq.0.or.(m_bs.eq.-2.and.nfield.lt.4))then
251,254c269,272
< c          if(ntest.eq.1)then
< c            if(xxg.lt.0..or.xxg.gt.1..or.yyg.lt.0..or.yyg.gt.1.)
< c    .        print *,'intsc problem iq xxg,yyg ',iq,xxg,yyg
< c          endif
---
>            if(ntest.eq.1)then
>              if(xxg.lt.0..or.xxg.gt.1..or.yyg.lt.0..or.yyg.gt.1.)
>      .        print *,'intsc problem iq xxg,yyg ',iq,xxg,yyg
>            endif
299c317
<         else                      ! (nfield.lt.mh_bs)
---
>         else                      ! m_bs.eq.0.or.(m_bs.eq.-2.and.nfield.lt.4)
310,311c328,331
<             cmin=min( 1.e20,c2,c3)   ! Bermejo & Staniforth
<             cmax=max(-1.e20,c2,c3)   ! Bermejo & Staniforth
---
> !           if(m_bs.eq.2)then
>               cmin=min( 1.e20,c2,c3)   ! Bermejo & Staniforth
>               cmax=max(-1.e20,c2,c3)   ! Bermejo & Staniforth
> !           endif
325,326c345,348
<             cmin=min(cmin,c2,c3)   ! Bermejo & Staniforth
<             cmax=max(cmax,c2,c3)   ! Bermejo & Staniforth
---
> !           if(m_bs.eq.2)then
>               cmin=min(cmin,c2,c3)   ! Bermejo & Staniforth
>               cmax=max(cmax,c2,c3)   ! Bermejo & Staniforth
> !           endif
353c375,379
<            s(iq)=min(max(cmin,sss),cmax)   ! Bermejo & Staniforth
---
> !          if(m_bs.eq.2)then
>              s(iq)=min(max(cmin,sss),cmax)   ! Bermejo & Staniforth
> !          else
> !            s(iq)=sss
> !          endif   ! m_bs.eq.2
355c381
<         endif      ! (nfield.lt.mh_bs)  .. else ..
---
>         endif      ! m_bs.eq.0.or.(m_bs.eq.-2.and.nfield.lt.4)  .. else ..
=====================================
 
jimcc.f
=====================================
7d6
<       include 'parm.h'    ! ktau
18c17
<      .    ,dum3(5*ijk- 4*(iquad)*(iquad) -np*np )
---
>      .    ,dum3(4*ijk- 4*(iquad)*(iquad) -np*np )
25a25,28
> c     ndiag=0
> c     print *,'supply ngrmax (1 - 4) '    !jlm
> c     read *,ngrmax
> c     print *,'ngrmax = ',ngrmax
26a30,34
> c     print'('' input panel you want to display'')'
> c     read(*,*)ipanel
> c     ipanel=2   ! jlm  corresponds to jlm ipanel=0 (x~1)
> c     print *,'ipanel = ',ipanel  !jlm
> c     if(ipanel.lt.0.or.ipanel.gt.5)stop'invalid panel'
27a36,39
> c     open(35,file='xxyy.out',status='unknown')
> c     open(36,file='xxyyb.jim',status='unknown')
> c     open(37,file='xxyyu.jim',status='unknown')
> c     open(38,file='xxyyv.jim',status='unknown')
28a41,42
> c      print *,'ngr = ',ngr
> c      lu=34+ngr
32d45
<       if(ktau.eq.0)then
43,45c56,58
<        print *,'in jimcc xa,xb,xc: ',1,5,xa(1,5),xb(1,5),xc(1,5)
<        print *,'now imposing 8-fold symmetry (jlm)'
<       endif  ! (ktau.eq.0)
---
>        i=1
>        j=5
>        print *,'in jimcc xa,xb,xc: ',i,j,xa(i,j),xb(i,j),xc(i,j)
46a60
>        print *,'now imposing 8-fold symmetry (jlm)'
68d81
<       if(ktau.eq.0)then
79,80c92,94
<        print *,'in jimcc xa,xb,xc: ',1,5,xa(1,5),xb(1,5),xc(1,5)
<       endif  ! (ktau.eq.0)
---
>        i=1
>        j=5
>        print *,'in jimcc xa,xb,xc: ',i,j,xa(i,j),xb(i,j),xc(i,j)
=====================================
 
jimco.f
=====================================
=====================================
 
latltoij.f
=====================================
10d9
<       parameter (ntest=0)
49c48
< !     if(num.eq.0)then     ! not with onthefly
---
>       if(num.eq.0)then
74c73
< !     endif
---
>       endif
98c97
<           if(ntest.eq.1.and.z1.gt..82.and.z1.lt..821)then
---
>           if(z1.gt..82.and.z1.lt..821)then
250c249
<       if(ntest.eq.1.and.rlongin.gt.43.1.and.rlongin.lt.49.9)then
---
>       if(rlongin.gt.43.1.and.rlongin.lt.49.9)then
=====================================
 
leoncld.f
=====================================
=====================================
 
lwr88.f
=====================================
40c40
<       parameter (ndum=5*ijk- imax*(2*lp1*lp1 +9*lp1 +4*l +4)) !jlm
---
>       parameter (ndum=4*ijk- imax*(2*lp1*lp1 +9*lp1 +4*l +4)) !jlm
=====================================
 
maxmin.f
=====================================
48,51c48,49
< c        print 971,ktau,char,(umax(k),k=1,kup)
< c971     format(i7,1x,a2,'max ',10f7.2/(14x,10f7.2)/(14x,10f7.2))
<         print 971,ktau,char,(umax(k),k=1,10),char,(umax(k),k=11,kup)
< 971     format(i7,1x,a2,'max ',10f7.2/(a10,'maX ',10f7.2)/(14x,10f7.2))
---
>         print 971,ktau,char,(umax(k),k=1,kup)
> 971     format(i7,1x,a2,'max ',10f7.2/(14x,10f7.2)/(14x,10f7.2))
=====================================
 
mslp.f
=====================================
1,2c1,2
<       subroutine mslp(pmsl,psl,zs,t)
<       parameter (meth=1) ! 0 for original, 1 for other jlm - always now
---
>       subroutine mslp(pmsl)
>       parameter (meth=1) ! 0 for original, 1 for other jlm
3a4
>       include 'arrays.h'
4a6
>       include 'map.h'       ! zs,land
6c8
<       real pmsl(ifull),psl(ifull),zs(ifull),t(ifull,kl)
---
>       real pmsl(ifull)
8d9
<       save lev
16,20c17,21
< c     if(meth.eq.0)then
< c       do iq=1,ifull
< c        pmsl(iq)=ps(iq)*(1.+con*zs(iq)/t(iq,lev))**conr
< c       enddo
< c     endif  ! (meth.eq.0)
---
>       if(meth.eq.0)then
>         do iq=1,ifull
>          pmsl(iq)=ps(iq)*(1.+con*zs(iq)/t(iq,lev))**conr
>         enddo
>       endif
29,47d29
<       endif  ! (meth.eq.1)
<       if(nmaxpr.eq.1)then
<         print *,'meth,lev,sig(lev) ',meth,lev,sig(lev)
<         print *,'zs,t_lev,psl,pmsl ',
<      .           zs(idjd),t(idjd,lev),psl(idjd),pmsl(idjd)
<       endif
<       return
<       entry to_psl(pmsl,psl,zs,t)
<       do iq=1,ifull
<        phi1=t(iq,lev)*r*(1.-sig(lev))/sig(lev) ! phi of sig(lev) above sfce
<        tsurf=t(iq,lev)+phi1*.0065/g
<        tav=tsurf+zs(iq)*.5*.0065/g
<        dlnps=zs(iq)/(r*tav)
<        psl(iq)=log(1.e-5*pmsl(iq)) -dlnps
<       enddo
<       if(nmaxpr.eq.1)then
<         print *,'to_psl lev,sig(lev) ',lev,sig(lev)
<         print *,'zs,t_lev,psl,pmsl ',
<      .           zs(idjd),t(idjd,lev),psl(idjd),pmsl(idjd)
=====================================
 
mtimerget.f
=====================================
=====================================
 
nestin.f
=====================================
11,15c11,14
<       include 'parm.h'     ! qgmin
<       include 'pbl.h'      ! sice
<       include 'soil.h'     ! tss
<       include 'soilsnow.h' ! tgg
<       include 'stime.h'    ! kdate_s,ktime_s  sought values for data read
---
>       include 'parm.h'   ! qgmin
>       include 'pbl.h'    ! sice
>       include 'soil.h'   ! tss
>       include 'stime.h'   ! kdate_s,ktime_s  sought values for data read
24c23
<       common/work3/dum3a(ifull,kl),dum3b(ifull,kl,4)
---
>       common/work3/dum3a(ifull,kl),dum3b(ifull,kl,3)
31c30
<       if(ktau.lt.100)print *,'with kdate_s,ktime_s >= ',kdate_s,ktime_s
---
>       if(ktau.lt.100)print *,'with kdate_s,ktime_s: ',kdate_s,ktime_s
39,42c38,43
<         tb(:,:)=t(:,:)
<         qb(:,:)=max(qg(:,:),qgmin)
<         ub(:,:)=u(:,:)
<         vb(:,:)=v(:,:)
---
>         do kq=1,ijk
>          tb(kq,1)=t(kq,1)
>          qb(kq,1)=max(qg(kq,1),qgmin)
>          ub(kq,1)=u(kq,1)
>          vb(kq,1)=v(kq,1)
>         enddo
53,56c54,59
<       ta(:,:)=tb(:,:)
<       qa(:,:)=qb(:,:)
<       ua(:,:)=ub(:,:)
<       va(:,:)=vb(:,:)
---
>       do kq=1,ijk
>        ta(kq,1)=tb(kq,1)
>        qa(kq,1)=qb(kq,1)
>        ua(kq,1)=ub(kq,1)
>        va(kq,1)=vb(kq,1)
>       enddo
65a69,72
>         write (6,"('zsb# nestin  ',9f7.1)") 
>      .              ((zs(ii+(jj-1)*il),ii=id-1,id+1),jj=jd-1,jd+1)
>         write (6,"('tssb# nestin ',9f7.1)") 
>      .              ((tssb(ii+(jj-1)*il),ii=id-1,id+1),jj=jd-1,jd+1)
75,78d81
<       write (6,"('zsb# nestin  ',9f7.1)") 
<      .          ((zsb(ii+(jj-1)*il),ii=id-1,id+1),jj=jd-1,jd+1)
<       write (6,"('tssb# nestin ',9f7.1)") 
<      .          ((tssb(ii+(jj-1)*il),ii=id-1,id+1),jj=jd-1,jd+1)
91c94
< c    .               +nint(60*(ktime_r-ktime)/100.)  ! up till 29/11/02
---
> c    .               +nint(60*(ktime_r-ktime)/100.)
101c104
< !     if(mod(ktau,nmaxpr).eq.0.or.diag)then
---
>       if(mod(ktau,nmaxpr).eq.0.or.diag)then
110c113
< !     endif
---
>       endif
112c115,117
<       qb(:,:)=max(qb(:,:),qgmin)
---
>       do kq=1,ijk
>        qb(kq,1)=max(qb(kq,1),qgmin)
>       enddo
185c190
<       endif   !  num.eq.0
---
>       endif   !  num.eq.0.and.kstart.eq.1
191,199d195
<       psls(:)=cona*psla(:)+conb*pslb(:)
<       tt (:,:)=cona*ta(:,:)+conb*tb(:,:)
<       qgg(:,:)=cona*qa(:,:)+conb*qb(:,:)
<       uu (:,:)=cona*ua(:,:)+conb*ub(:,:)
<       vv (:,:)=cona*va(:,:)+conb*vb(:,:)
< 
< c     calculate time interpolated tss (into tssi)
<       if(namip.eq.0)return     ! namip SSTs/sea-ice take precedence
<       tssi(:)=cona*tssa(:)+conb*tssb(:)  
201,214c197,222
<        if(.not.land(iq))then
< 	  if(tssi(iq).gt.273.2)then
< 	    tss(iq)=tssi(iq)
< 	    tgg(iq,1)=tssi(iq)
< !          all others are for implied sea ice points
< !          N.B. fracice, sice etc are updated once daily in sflux
< 	  elseif(tss(iq).gt.273.2)then  
< 	    tss(iq)=tssi(iq)
< 	    tgg(iq,1)=tssi(iq)
< !          if already sea ice implied, use present tss, tgg1
<          endif	    
<        endif  ! (.not.land(iq))
<       enddo  
< 	      
---
>        psls(iq)=cona*psla(iq)+conb*pslb(iq)
>       enddo
>       do kq=1,ijk
>        tt (kq,1)=cona*ta(kq,1)+conb*tb(kq,1)
>        qgg(kq,1)=cona*qa(kq,1)+conb*qb(kq,1)
>        uu (kq,1)=cona*ua(kq,1)+conb*ub(kq,1)
>        vv (kq,1)=cona*va(kq,1)+conb*vb(kq,1)
>       enddo
> 
>       if(ntsea.eq.6) then    ! check this fully later
> c       calculate time interpolated tss (into tssi)
>         do iq=1,ifull
>          tssi(iq)=cona*tssa(iq)+conb*tssb(iq)   ! error before 19/2/98
>         enddo
>         do iq=1,ifull
>           if(.not.land(iq).and..not.sice(iq))tss(iq)=tssi(iq)
>         enddo
>         if(nsiceup.eq.1)then  ! update tss over sice too
> !         N.B. mask updated once per day in sflux for nsiceup=1
>           do iq=1,ifull
>            if(sice(iq))tss(iq)=tssi(iq)
>           enddo
>         endif  !  (nsiceup.eq.1)
> !       other nsiceup options to come here, affecting tice (in tgg array)
>       endif    ! (ntsea.eq.6)
> 
=====================================
 
newcloud.f
=====================================
=====================================
 
newrain.f
=====================================
=====================================
 
nfft.f
=====================================
=====================================
 
nonlin.f
=====================================
3c3
<       parameter (meth=1)    ! 0 or 1 for nphip scheme
---
>       parameter (meth=1)
6a7
>       parameter (moist=0)    ! set moist to 0, 1 or 2  in nonlin and adjust5
17c18
<       include 'parmdyn.h'  
---
>       include 'parmdyn.h'  ! morder,ntomg
35c36
<      .             ,spare(ifull,kl)      
---
>       common/work3d/tomgsav(ifull,kl)   ! just in adjust5, nonlin & updps
38a40,41
> !!    real phisav(ifull,kl)
> !!    equivalence (phisav,tomgsav)
56a60
>         tv(iq,k)=.61*qg(iq,k)*t(iq,k)  ! just add-on at this stage
58a63,65
>         if(moist.eq.1)qg(iq,k)=qg(iq,k)/(ps(iq)*sig(k))**3
>         if(moist.eq.2)qg(iq,k)=max(qg(iq,k),1.e-6)
>         if(moist.eq.2)qg(iq,k)=qg(iq,k)**(1./3.)/(ps(iq)*sig(k))
92d98
<         print *,'at beginning of nonlin'
112a119,120
>         print *,'diags from nonlin after omgf calculated, ds = ',ds
>         print *,'omgf ',(omgf(idjd,k),k=1,kl)
118,120c126,137
<       un(:,:)=0. !   needed (whilst un equiv in vertmix)
<       vn(:,:)=0.
<       tn(:,:)=0.
---
>       if(nvsplit.eq.1.or.nvsplit.eq.2)then   ! split all physics
>         do k=1,kl               
>          do iq=1,ifull
>           t(iq,k)=t(iq,k)+dt*tn(iq,k)
>           u(iq,k)=u(iq,k)+dt*un(iq,k)
>           v(iq,k)=v(iq,k)+dt*vn(iq,k)
>           tn(iq,k)=0.
>           un(iq,k)=0.
>           vn(iq,k)=0.
>          enddo
>         enddo
>       endif    !  (nvsplit.eq.1.or.nvsplit.eq.2)
125,126d141
<         write (6,"('u   ',9f8.2/4x,9f8.2)") (u(idjd,kk),kk=1,kl)
<         write (6,"('v   ',9f8.2/4x,9f8.2)") (v(idjd,kk),kk=1,kl)
130c145
<       if(nvad.ne.0)then
---
>       if(nvad.ne.0.and.nvad.ne.44)then
131a147,149
>         if(nmaxpr.eq.1)
>      .   write (6,"('t_no1(1-9)',9f8.2)") (t(idjd,k),k=1,9)
>         if(nvad.eq.3)call vadvni(t,tx,u,ux,v,vx)
133,136c151,152
<         if(nvad.eq.7)call vadv30(t,tx,u,ux,v,vx)   ! for vadvbess
<         t(:,:)=tx(:,:)
<         u(:,:)=ux(:,:)
<         v(:,:)=vx(:,:)
---
>         if(nvad.eq.5)call vadv30(t,tx,u,ux,v,vx)
>         if(nvad.eq.8)call vadvl_w(t,tx,u,ux,v,vx)
138,152c154,158
<          print *,'in nonlin after vertical advection'
<          write (6,"('qg  ',9f8.3/4x,9f8.3)")(1000.*qg(idjd,kk),kk=1,kl)
<          write (6,"('t   ',9f8.2/4x,9f8.2)") (t(idjd,kk),kk=1,kl)
<          write (6,"('thet',9f8.2/4x,9f8.2)")  
<      .                (t(idjd,k)*sig(k)**(-roncp),k=1,kl)
<          write (6,"('u   ',9f8.2/4x,9f8.2)") (u(idjd,kk),kk=1,kl)
<          write (6,"('v   ',9f8.2/4x,9f8.2)") (v(idjd,kk),kk=1,kl)
<          write (6,"('t#  ',9f8.2)") 
<      .             ((t(ii+(jj-1)*il,nlv),ii=id-1,id+1),jj=jd-1,jd+1)
<          write (6,"('u#  ',9f8.2)") 
<      .             ((u(ii+(jj-1)*il,nlv),ii=id-1,id+1),jj=jd-1,jd+1)
<          write (6,"('v#  ',9f8.2)") 
<      .             ((v(ii+(jj-1)*il,nlv),ii=id-1,id+1),jj=jd-1,jd+1)
<          write (6,"('omgf#',9f8.3)") ((ps(ii+(jj-1)*il)*
<      .               omgf(ii+(jj-1)*il,nlv),ii=id-1,id+1),jj=jd-1,jd+1)
---
>           print *,'in nonlin after vertical advection'
>           write (6,"('qg  ',9f8.3/4x,9f8.3)")(1000.*qg(idjd,kk),kk=1,kl)
>           write (6,"('t   ',9f8.2/4x,9f8.2)") (tx(idjd,kk),kk=1,kl)
>           write (6,"('thet',9f8.2/4x,9f8.2)")  
>      .                 (tx(idjd,k)*sig(k)**(-roncp),k=1,kl)
154c160,179
<       endif      ! (nvad.ne.0)
---
>         if(nmaxpr.eq.1)
>      .    write (6,"('t_no2(1-9)',9f8.2)") (tx(idjd,k),k=1,9)
>         if(nvsplit.le.1)then   ! original way using tendencies of vert. adv.
>          do k=1,kl               
>           do iq=1,ifull
>            tn(iq,k)=tn(iq,k)+(tx(iq,k)-t(iq,k))/dt
>            un(iq,k)=un(iq,k)+(ux(iq,k)-u(iq,k))/dt
>            vn(iq,k)=vn(iq,k)+(vx(iq,k)-v(iq,k))/dt
>           enddo
>          enddo
>         else     !  nvsplit= 2,3  split t,u,v, vadv.
>          do k=1,kl               
>           do iq=1,ifull
>            t(iq,k)=tx(iq,k)
>            u(iq,k)=ux(iq,k)
>            v(iq,k)=vx(iq,k)
>           enddo
>          enddo
>         endif    ! (nvsplit.eq.0) .. else ..
>       endif      ! (nvad.ne.0.and.nvad.ne.44)
195a221,233
>       if(nonl.ge.10)then  !  split effect of vadv & hs_phys
>        do k=1,kl
> 	 do iq=1,ifull
>          t(iq,k)=t(iq,k)+tn(iq,k)*dt
>          u(iq,k)=u(iq,k)+un(iq,k)*dt
>          v(iq,k)=v(iq,k)+vn(iq,k)*dt
>          tn(iq,k)=0.
>          un(iq,k)=0.
>          vn(iq,k)=0.
>         enddo  ! iq loop  
>        enddo   !  k loop    
>       endif
> 
212d249
<       tv=.61*qg*t  ! 3D - just add-on at this stage (after vadv)
229a267,273
>       if(ntomg.eq.2.and.ktau.eq.kstart)then
>         do k=1,kl
>          do iq=1,ifull
>            tomgsav(iq,k)=(t(iq,k)-tbar2d(iq))*omgf(iq,k) 
>          enddo     ! iq loop
>         enddo      ! k  loop
>       endif        ! (ntomg.eq.2.and.ktau.eq.kstart)
231a276,279
>         if(moist.eq.1)qg(iq,k)=
>      .                qg(iq,k)*(1.-1.5*dt*omgf(iq,k)/sig(k))
>         if(moist.eq.2)qg(iq,k)=
>      .                qg(iq,k)*(1.-.5*dt*omgf(iq,k)/sig(k))
233,234c281,292
<         tn(iq,k)=tn(iq,k)+(t(iq,k)
<      .           +contv*tv(iq,k))*omgf(iq,k)*roncp/sig(k) -termlin
---
>         if(ntomg.eq.2)then  
>           tn(iq,k)=tn(iq,k)+ ( contv*tv(iq,k)*omgf(iq,k)
>      .          +.5*(tomgsav(iq,k)+(t(iq,k)-tbar2d(iq))*omgf(iq,k)))
>      .          *roncp/sig(k)
>         else
>           tn(iq,k)=tn(iq,k)+(t(iq,k)
>      .             +contv*tv(iq,k))*omgf(iq,k)*roncp/sig(k) -termlin
>         endif   ! (ntomg.eq.2) .. else ..
>         if(ntomg.eq.1.or.ntomg.eq.2)tomgsav(iq,k)=
>      .                            (t(iq,k)-tbar2d(iq))*omgf(iq,k) 
> !       for ntomg=3, tomgsav holds omgfnl; leaves tv part as before
>         if(ntomg.eq.3)tomgsav(iq,k)=(t(iq,k)-tbar2d(iq))*tomgsav(iq,k) 
246c304
<         print *,'tvv,tn ',tvv,tn(iq,k)
---
>         print *,'ntomg,tvv,tn ',ntomg,tvv,tn(iq,k)
393,405c451,461
< 	if(ntest.eq.1)then
<   	  iq=idjd
< 	  print *,'ps,pse,psn ',ktau,ps(iq),ps(ie(iq)),ps(in(iq))
< 	  print *,'psl,psle,psln ',psl(iq),psl(ie(iq)),psl(in(iq))
< 	  print *,'phitopm,e,n ',phip(iq,nphip-4),phip(ie(iq),nphip-4),
<      .                          phip(in(iq),nphip-4)
< 	  print *,'phitop,e,n ',phip(iq,nphip),phip(ie(iq),nphip),
<      .                         phip(in(iq),nphip)
<          do k=1,kl
< 	   print *,'k,tv,tve,tvn ',
<      .             k,tv(iq,k),tv(ie(iq),k),tv(in(iq),k)
< 	  enddo
< 	endif   ! (ntest.eq.1)
---
> 	iq=idjd
> 	print *,'ps,pse,psn ',ktau,ps(iq),ps(ie(iq)),ps(in(iq))
> 	print *,'psl,psle,psln ',psl(iq),psl(ie(iq)),psl(in(iq))
> 	print *,'phitopm,e,n ',phip(iq,nphip-4),phip(ie(iq),nphip-4),
>      .                       phip(in(iq),nphip-4)
> 	print *,'phitop,e,n ',phip(iq,nphip),phip(ie(iq),nphip),
>      .                       phip(in(iq),nphip)
>        do k=1,kl
> 	 print *,'k,tv,tve,tvn ',
>      .           k,tv(iq,k),tv(ie(iq),k),tv(in(iq),k)
> 	enddo
419c475
<       if(ntest.eq.1.and.nphip.gt.1)then
---
>       if(nphip.gt.1)then
424,425c480,481
<      .                dphi_dx(idjd,k),p(ie(idjd),k)-p(idjd,k)
<      .                +rtav*(psl(ie(idjd))-psl(idjd))
---
>      .                   dphi_dx(idjd,k),p(ie(idjd),k)-p(idjd,k)
>      .                   +rtav*(psl(ie(idjd))-psl(idjd))
431,432c487,488
<      .                dphi_dy(idjd,k),p(in(idjd),k)-p(idjd,k)
<      .                +rtav*(psl(in(idjd))-psl(idjd))
---
>      .                   dphi_dy(idjd,k),p(in(idjd),k)-p(idjd,k)
>      .                   +rtav*(psl(in(idjd))-psl(idjd))
434c490
<       endif     ! (ntest.eq.1.and.nphip.gt.1)
---
>       endif     ! (nphip.gt.1)
473c529
< !      morder=24 scheme with residual terms for un, vn
---
>        if(morder.eq.24)then ! residual terms for un, vn
481c537
< 
---
>        endif      ! (morder.eq.24)  
502,511d557
<        if(diag.and.k.eq.nlv)then
<         call printa('aa  ',aa,ktau,nlv,ia,ib,ja,jb,0.,1.)
<         call printa('aa2 ',aa2,ktau,nlv,ia,ib,ja,jb,0.,1.)
<         call printa('bb  ',bb,ktau,nlv,ia,ib,ja,jb,0.,1.)
<         call printa('bb2 ',bb2,ktau,nlv,ia,ib,ja,jb,0.,1.)
<         call printa('cc  ',cc,ktau,nlv,ia,ib,ja,jb,0.,1.)
<         call printa('cc2 ',cc2,ktau,nlv,ia,ib,ja,jb,0.,1.)
<         call printa('dd  ',dd,ktau,nlv,ia,ib,ja,jb,0.,1.)
<         call printa('dd2 ',dd2,ktau,nlv,ia,ib,ja,jb,0.,1.)
<        endif  ! (diag.and.k.eq.nlv)
518,520c564,570
<         tn(:,:)=2.*tn(:,:)   ! all tn added in adjust
<         un(:,:)=2.*un(:,:)   ! all un added in adjust
<         vn(:,:)=2.*vn(:,:)   ! all vn added in adjust
---
>        do k=1,kl
> 	 do iq=1,ifull
>          tn(iq,k)=2.*tn(iq,k)   ! all tn added in adjust
>          un(iq,k)=2.*un(iq,k)   ! all un added in adjust
>          vn(iq,k)=2.*vn(iq,k)   ! all vn added in adjust
>         enddo  ! iq loop  
>        enddo   !  k loop    
522,525c572,579
<         if(ktau.eq.1)then
<           tnsav(:,:)=tn(:,:)
<           unsav(:,:)=un(:,:)
<           vnsav(:,:)=vn(:,:)
---
>         if(ktau.eq.kstart)then
>          do k=1,kl
> 	   do iq=1,ifull
>            tnsav(iq,k)=tn(iq,k)
>            unsav(iq,k)=un(iq,k)
>            vnsav(iq,k)=vn(iq,k)
>           enddo  ! iq loop  
>          enddo   !  k loop    
527,533c581,597
<         tx(:,:)=tx(:,:) +1.5*dt*tn(:,:)-.5*dt*tnsav(:,:)
<         ux(:,:)=ux(:,:) +1.5*dt*un(:,:)-.5*dt*unsav(:,:)
<         vx(:,:)=vx(:,:) +1.5*dt*vn(:,:)-.5*dt*vnsav(:,:)
<       else       ! (nonl=0, 1, or 11)  usual code has nonl=0
<         tx(:,:)=tx(:,:) +cnon*dt*tn(:,:)
<         ux(:,:)=ux(:,:) +cnon*dt*un(:,:)
<         vx(:,:)=vx(:,:) +cnon*dt*vn(:,:)
---
>         do k=1,kl
> 	  do iq=1,ifull
>           tx(iq,k)=tx(iq,k) +1.5*dt*tn(iq,k)-.5*dt*tnsav(iq,k)
>           ux(iq,k)=ux(iq,k) +1.5*dt*un(iq,k)-.5*dt*unsav(iq,k)
>           vx(iq,k)=vx(iq,k) +1.5*dt*vn(iq,k)-.5*dt*vnsav(iq,k)
> !         ux(iq,k)=ux(iq,k) + .5*dt*un(iq,k)
> !         vx(iq,k)=vx(iq,k) + .5*dt*vn(iq,k)
>          enddo  ! iq loop  
>         enddo   !  k loop    
>       else       ! (nonl=0, 1, or 11)  usual code:
>         do k=1,kl
> 	  do iq=1,ifull
>           tx(iq,k)=tx(iq,k) +cnon*dt*tn(iq,k)
>           ux(iq,k)=ux(iq,k) +cnon*dt*un(iq,k)
>           vx(iq,k)=vx(iq,k) +cnon*dt*vn(iq,k)
>          enddo  ! iq loop  
>         enddo   !  k loop    
560,562c624,630
<         un(:,:)=0. 
<         vn(:,:)=0.
<         tn(:,:)=0.
---
>         do k=1,kl
>          do iq=1,ifull
>           tn(iq,k)=0.
>           un(iq,k)=0.
>           vn(iq,k)=0.
>          enddo  ! iq loop  
>         enddo   !  k loop    
=====================================
 
o3_read.f
=====================================
=====================================
 
o3set.f
=====================================
=====================================
 
onthefly.f
=====================================
11,12c11
<       parameter (nord=3)   ! 1 for bilinear, 3 for bicubic
< !     related to cctocc4                       
---
> !     related to cctocc4                         jlm 12/7/01 & 9/11/02
30,34c29
<       common/work3b/rlong4(ifull,4),rlat4(ifull,4),   ! shared with setxyz
<      .              aa(ifull),bb(ifull),
<      .              xx4_sav(iquad,iquad),yy4_sav(iquad,iquad),
<      .              dum3d(2*ijk-10*ifull-2*iquad*iquad) 
<       common/work3f/nface(ifull),xg(ifull),yg(ifull),
---
>       common/work3b/nface(ifull),xg(ifull),yg(ifull),
40,41c35
<      .              uc(ifull),vc(ifull),wc(ifull),
<      .              pmsl(ifull),dum3b(3*ijk-23*ifull)
---
>      .              uc(ifull),vc(ifull),wc(ifull),dum3b(2*ijk-22*ifull)
42a37,40
>       common/work3d/rlong4(ifull,4),rlat4(ifull,4),   ! shared with setxyz
>      .              aa(ifull),bb(ifull),
>      .              xx4_sav(iquad,iquad),yy4_sav(iquad,iquad),
>      .              dum3d(ijk-10*ifull-2*iquad*iquad) 
52,53c50
< c     data pi/3.1415926536/,id1/16/,jd1/79/
<       data pi/3.1415926536/,id1/3/,jd1/60/
---
>       data pi/3.1415926536/,id1/16/,jd1/79/
66,75d62
< c     start of processing loop 
<       nemi=2   !  assume source land-mask based on tss sign first
<       if(ktau.lt.3)print *,'search for kdate_s,ktime_s >= ',
<      .                                 kdate_s,ktime_s
<       id_t=id
<       jd_t=jd
<       id=id1
<       jd=jd1
<       idjd=id+il*(jd-1)
<       idjd1=idjd
77,81c64,78
<       call infile(io_in2,kdate_r,ktime_r,nem2,
<      . timegb,ds,psl,aa,zss,aa,bb,
<      . tss,aa,wb,wbice,aa,snowd,sicedep,
<      . t,u,v,qg,tgg,
<      . tggsn,smass,ssdn, ssdnn,osnowd,snage,isflag,nested)
---
> c      start of processing loop 
>        nemi=2   !  assume source land-mask based on tss sign first
>        print *,'search for kdate_s,ktime_s ',kdate_s,ktime_s
>        id_t=id
>        jd_t=jd
>        id=id1
>        jd=jd1
>        idjd=id+il*(jd-1)
>        idjd1=idjd
> 
>         call infile(io_in2,kdate_r,ktime_r,nem2,
>      .   timegb,ds,psl,aa,zss,aa,bb,
>      .   tss,aa,wb,wbice,aa,snowd,sicedep,
>      .   t,u,v,qg,tgg,
>      .   tggsn,smass,ssdn, ssdnn,osnowd,snage,isflag,nested)
82a80,83
>       print *,'io_in2,kdate_r,ktime_r,ktau,ds',
>      .         io_in2,kdate_r,ktime_r,ktau,ds
> 
>       print *,'ds,ds_t ',ds,ds_t
85a87
>       print *,'a zss(idjd1) ',zss(idjd1)
87,117c89,112
<       rlong0=rlong0x
<       rlat0=rlat0x
<       schmidt=schmidtx
<       call setxyz   ! for source data geometry        ******************
< !     rotpole(1,) is x-axis of rotated coords in terms of orig Cartesian
< !     rotpole(2,) is y-axis of rotated coords in terms of orig Cartesian
< !     rotpole(3,) is z-axis of rotated coords in terms of orig Cartesian
<       coslong=cos(rlong0*pi/180.)
<       sinlong=sin(rlong0*pi/180.)
<       coslat=cos(rlat0*pi/180.)
<       sinlat=sin(rlat0*pi/180.)
<       rotpoles(1,1)=coslong*sinlat
<       rotpoles(1,2)=-sinlong
<       rotpoles(1,3)=coslong*coslat
<       rotpoles(2,1)=sinlong*sinlat
<       rotpoles(2,2)=coslong
<       rotpoles(2,3)=sinlong*coslat
<       rotpoles(3,1)=-coslat
<       rotpoles(3,2)=0.
<       rotpoles(3,3)=sinlat
<       if(ktau.lt.3)then
<         print *,'nfly,nord ',nfly,nord
<         print *,'io_in2,kdate_r,ktime_r,ktau,ds',
<      .         io_in2,kdate_r,ktime_r,ktau,ds
<         print *,'ds,ds_t ',ds,ds_t
<         print *,'a zss(idjd1) ',zss(idjd1)
<         print *,'rotpoles:'
<         do i=1,3
<          print 9,(i,j,j=1,3),(rotpoles(i,j),j=1,3)
<         enddo
<       endif ! (ktau.lt.3)
---
>        rlong0=rlong0x
>        rlat0=rlat0x
>        schmidt=schmidtx
>        call setxyz   ! for source data geometry
> !      rotpole(1,) is x-axis of rotated coords in terms of orig Cartesian
> !      rotpole(2,) is y-axis of rotated coords in terms of orig Cartesian
> !      rotpole(3,) is z-axis of rotated coords in terms of orig Cartesian
>        coslong=cos(rlong0*pi/180.)
>        sinlong=sin(rlong0*pi/180.)
>        coslat=cos(rlat0*pi/180.)
>        sinlat=sin(rlat0*pi/180.)
>        rotpoles(1,1)=coslong*sinlat
>        rotpoles(1,2)=-sinlong
>        rotpoles(1,3)=coslong*coslat
>        rotpoles(2,1)=sinlong*sinlat
>        rotpoles(2,2)=coslong
>        rotpoles(2,3)=sinlong*coslat
>        rotpoles(3,1)=-coslat
>        rotpoles(3,2)=0.
>        rotpoles(3,3)=sinlat
>        print *,'rotpoles:'
>        do i=1,3
>         print 9,(i,j,j=1,3),(rotpoles(i,j),j=1,3)
>        enddo
131,132c126,127
<         xx4_sav(i,j)=xx4(i,j)
<         yy4_sav(i,j)=yy4(i,j)
---
> 	 xx4_sav(i,j)=xx4(i,j)
> 	 yy4_sav(i,j)=yy4(i,j)
144c139
<       call setxyz  ! for target        *********************************
---
>       call setxyz  ! for target
162,170c157,161
<       if(nmaxpr.eq.1)then
<         print *,'rotpole:'
<         do i=1,3
<          print 9,(i,j,j=1,3),(rotpole(i,j),j=1,3)
< 9        format(3x,2i1,5x,2i1,5x,2i1,5x,3f8.4)
<         enddo
<         print *,'xx4,xx4_sav,yy4,yy4_sav ',
<      .           xx4(id,jd),xx4_sav(id,jd),yy4(id,jd),yy4_sav(id,jd)
<       endif  ! (nmaxpr.eq.1)
---
>       print *,'rotpole:'
>       do i=1,3
>        print 9,(i,j,j=1,3),(rotpole(i,j),j=1,3)
> 9      format(3x,2i1,5x,2i1,5x,2i1,5x,3f8.4)
>       enddo
183,193c174,182
< !     restore cc source file geometry for latltoij
<       rlong0=rlong0x
<       rlat0=rlat0x
<       schmidt=schmidtx
<       if(nmaxpr.eq.1)then
<         print *,'before latltoij for id,jd: ',id,jd
<         print *,'rlong4(1-4) ',(rlong4(idjd,m),m=1,4)
<         print *,'rlat4(1-4) ',(rlat4(idjd,m),m=1,4)
<         print *,'rlong0x,rlat0x,schmidtx ',rlong0x,rlat0x,schmidtx 
<       endif  ! (nmaxpr.eq.1)
<       do m=1,4
---
>        print *,'before latltoij for id,jd: ',id,jd
>        print *,'rlong4(1-4) ',(rlong4(idjd,m),m=1,4)
>        print *,'rlat4(1-4) ',(rlat4(idjd,m),m=1,4)
> !      restore cc source file geometry for latltoij
>        rlong0=rlong0x
>        rlat0=rlat0x
>        schmidt=schmidtx
> 	print *,'rlong0x,rlat0x,schmidtx ',rlong0x,rlat0x,schmidtx 
>        do m=1,4
201,214c190,197
<        idjd2=id2+il*(jd2-1)
< 	if(nmaxpr.eq.1)then
<          print *,'after latltoij giving id2,jd2: ',id2,jd2
<          print *,'nface4(1-4) ',(nface4(idjd,m),m=1,4)
<          print *,'xg4(1-4) ',(xg4(idjd,m),m=1,4)
<          print *,'yg4(1-4) ',(yg4(idjd,m),m=1,4)
<          write(6,"('wb_s(1)#  ',9f7.3)") 
<      .          ((wb(ii+(jj-1)*il,1),ii=id2-1,id2+1),jj=jd2-1,jd2+1)
<          write(6,"('wb_s(ms)# ',9f7.3)") 
<      .          ((wb(ii+(jj-1)*il,ms),ii=id2-1,id2+1),jj=jd2-1,jd2+1)
<        endif
<        if(nfly.eq.2)then    ! needs pmsl in this case (preferred)
<          call mslp(pmsl,psl,zss,t)  
< 	endif
---
>        print *,'after latltoij giving id2,jd2: ',id2,jd2
>        print *,'nface4(1-4) ',(nface4(idjd,m),m=1,4)
>        print *,'xg4(1-4) ',(xg4(idjd,m),m=1,4)
>        print *,'yg4(1-4) ',(yg4(idjd,m),m=1,4)
>        write(6,"('wb_s(1)#  ',9f7.3)") 
>      .        ((wb(ii+(jj-1)*il,1),ii=id2-1,id2+1),jj=jd2-1,jd2+1)
>        write(6,"('wb_s(ms)# ',9f7.3)") 
>      .        ((wb(ii+(jj-1)*il,ms),ii=id2-1,id2+1),jj=jd2-1,jd2+1)
216a200,201
>          print *
>          print *,'k, u , v: ',k,u(idjd1,k),v(idjd1,k)
231c216
<           print *,'uc,vc,wc: ',uc(id),vc(idjd1),wc(idjd1)
---
>           print *,'uc,vc,wc: ',uc(idjd1),vc(idjd1),wc(idjd1)
239,243c224,228
<        call ints4(t (1,k),nface4,xg4,yg4,nord)
<        call ints4(qg(1,k),nface4,xg4,yg4,nord)
<        call ints4(ucc,      nface4,xg4,yg4,nord)
<        call ints4(vcc,      nface4,xg4,yg4,nord)
<        call ints4(wcc,      nface4,xg4,yg4,nord)
---
>        call ints4(t (1,k),nface4,xg4,yg4)
>        call ints4(qg(1,k),nface4,xg4,yg4)
>        call ints4(ucc,      nface4,xg4,yg4)
>        call ints4(vcc,      nface4,xg4,yg4)
>        call ints4(wcc,      nface4,xg4,yg4)
245c230
< c        call ints4(sdot(1,k),   nface4,xg4,yg4,nord)
---
> c        call ints4(sdot(1,k),   nface4,xg4,yg4)
248,253c233,238
< c      ********************** N.B. tracers not ready yet
< c      if(iltin.gt.1)then
< c        do ntr=1,ntracin
< c         call ints4(tr(1,k,ntr),nface4,xg4,yg4,nord)
< c        enddo
< c      endif
---
> c**********************  tracers not ready yet
> c       if(iltin.gt.1)then
> c         do ntr=1,ntracin
> c          call ints4(tr(1,k,ntr),nface4,xg4,yg4)
> c         enddo
> c       endif
255,266c240,251
<        do iq=1,ifull
< !       now convert to "target" Cartesian components (transpose used)
<         uct(iq)=ucc(iq)*rotpole(1,1)+vcc(iq)*rotpole(2,1)
<      .                           +wcc(iq)*rotpole(3,1)
<         vct(iq)=ucc(iq)*rotpole(1,2)+vcc(iq)*rotpole(2,2)
<      .                           +wcc(iq)*rotpole(3,2)
<         wct(iq)=ucc(iq)*rotpole(1,3)+vcc(iq)*rotpole(2,3)
<      .                           +wcc(iq)*rotpole(3,3)
< !       then finally to "target" local x-y components
<         u(iq,k)=ax(iq)*uct(iq) +ay(iq)*vct(iq) +az(iq)*wct(iq)
<         v(iq,k)=bx(iq)*uct(iq) +by(iq)*vct(iq) +bz(iq)*wct(iq)
<        enddo  ! iq loop
---
>         do iq=1,ifull
> !         now convert to "target" Cartesian components (transpose used)
>           uct(iq)=ucc(iq)*rotpole(1,1)+vcc(iq)*rotpole(2,1)
>      .                             +wcc(iq)*rotpole(3,1)
>           vct(iq)=ucc(iq)*rotpole(1,2)+vcc(iq)*rotpole(2,2)
>      .                             +wcc(iq)*rotpole(3,2)
>           wct(iq)=ucc(iq)*rotpole(1,3)+vcc(iq)*rotpole(2,3)
>      .                             +wcc(iq)*rotpole(3,3)
> !         then finally to "target" local x-y components
>           u(iq,k)=ax(iq)*uct(iq) +ay(iq)*vct(iq) +az(iq)*wct(iq)
>           v(iq,k)=bx(iq)*uct(iq) +by(iq)*vct(iq) +bz(iq)*wct(iq)
>         enddo  ! iq loop
270,273c255,258
< 	  print *,'ax,ay,az ',ax(idjd),ay(idjd),az(idjd)
< 	  print *,'bx,by,bz ',bx(idjd),by(idjd),bz(idjd)
<          print *,'final u , v: ',u(idjd,k),v(idjd,k)
< 	endif
---
> 	   print *,'ax,ay,az ',ax(idjd),ay(idjd),az(idjd)
> 	   print *,'bx,by,bz ',bx(idjd),by(idjd),bz(idjd)
>           print *,'final u , v: ',u(idjd,k),v(idjd,k)
> 	 endif
324,331c309,310
<       if(nmaxpr.eq.1)then
<         print *,'before fill tss ',tss(idjd2)
<         print *,'before fill tss_l, tss_s ',tss_l(idjd2),tss_s(idjd2)
<         print *,'before fill/ints4 sicedep ',sicedep(idjd2)
<         print *,'before fill wb'
<         write(6,"('wb_s(1)#  ',9f7.3)") 
<      .          ((wb(ii+(jj-1)*il,1),ii=id2-1,id2+1),jj=jd2-1,jd2+1)
<       endif  ! (nmaxpr.eq.1)
---
>       print *,'before fill tss ',tss(idjd1)
>       print *,'before fill tss_l, tss_s ',tss_l(idjd1),tss_s(idjd1)
332a312
>       print *,'before fill tss_l, tss_s ',tss_l(idjd1),tss_s(idjd1)
333a314,319
>       print *,'after fill tss_l, tss_s ',tss_l(idjd1),tss_s(idjd1)
> !     call fill_cc(w,spval)
> !     call fill_cc(w2,spval)
> !     call fill_cc(ts(1,1),spval)
> !     call fill_cc(ts(1,2),spval)
>       print *,'before fill snowd '
334a321
>       print *,'before fill/ints4 sicedep ',sicedep(idjd1)
335a323,326
> 	 	     print *,'after fill/ints4 sicedep ',sicedep(idjd1)
>       print *,'before fill wb'
>       write(6,"('wb_s(1)#  ',9f7.3)") 
>      .        ((wb(ii+(jj-1)*il,1),ii=id2-1,id2+1),jj=jd2-1,jd2+1)
340,364c331,341
<       if(nmaxpr.eq.1)then
<         print *,'after fill tss_l, tss_s ',tss_l(idjd2),tss_s(idjd2)
<         print *,'after fill sicedep ',sicedep(idjd2)
<         print *,'after fill wb'
<         write(6,"('wb_s(1)#  ',9f7.3)") 
<      .          ((wb(ii+(jj-1)*il,1),ii=id2-1,id2+1),jj=jd2-1,jd2+1)
<         print *,'before ints4 psl(idjd2),zss(idjd2) ',
<      .                        psl(idjd),zss(idjd2)
<       endif  ! (nmaxpr.eq.1)
< 
<       if(nfly.gt.0)then
<         norder=1
<       else
<         norder=nord
<       endif
<       call ints4(psl ,     nface4,xg4,yg4,norder)
<       call ints4(zss ,nface4,xg4,yg4,norder)  
<       if(nfly.eq.2)then
<         call ints4(pmsl,   nface4,xg4,yg4,nord)
< !       invert pmsl to get psl
<         call to_psl(pmsl,psl,zss,t)  
<       endif  ! (nfly.eq.2)
<       call ints4(tss_l ,   nface4,xg4,yg4,nord)
<       call ints4(tss_s ,   nface4,xg4,yg4,nord)
< c     call ints4(precip,   nface4,xg4,yg4,nord)
---
>       print *,'before fill/ints4 wb'
>       write(6,"('wb_s(1)#  ',9f7.3)") 
>      .        ((wb(ii+(jj-1)*il,1),ii=id2-1,id2+1),jj=jd2-1,jd2+1)
> 
>       call ints4(psl ,     nface4,xg4,yg4)
>       print *,'before ints4 zss(idjd1) ',zss(idjd1)
>       call ints4(zss ,     nface4,xg4,yg4)
>       print *,'after ints4 idjd,zss(idjd) ',idjd,zss(idjd)
>       call ints4(tss_l ,   nface4,xg4,yg4)
>       call ints4(tss_s ,   nface4,xg4,yg4)
> c     call ints4(precip,   nface4,xg4,yg4)
366,367c343,344
<        call ints4(tgg(1,k),nface4,xg4,yg4,nord)
<        call ints4(wb(1,k) ,nface4,xg4,yg4,nord)
---
>        call ints4(tgg(1,k),nface4,xg4,yg4)
>        call ints4(wb(1,k) ,nface4,xg4,yg4)
369,377c346,350
<       if(nmaxpr.eq.1)then
<         print *,'after ints4 idjd,zss(idjd) ',idjd,zss(idjd)
< 	 print *,'after ints4 psl,pmsl ',psl(idjd),pmsl(idjd)
<         print *,'after ints4 wb_t'
<         write(6,"('wb_t(1)#  ',9f7.3)") 
<      .           ((wb(ii+(jj-1)*il,1),ii=id2-1,id2+1),jj=jd2-1,jd2+1)
<       endif  ! (nmaxpr.eq.1)
< c     call ints4(alb ,     nface4,xg4,yg4,nord)
< c     call ints4(precc,    nface4,xg4,yg4,nord)
---
>       print *,'after ints4 wb_t'
>       write(6,"('wb_t(1)#  ',9f7.3)") 
>      .        ((wb(ii+(jj-1)*il,1),ii=id2-1,id2+1),jj=jd2-1,jd2+1)
> c     call ints4(alb ,     nface4,xg4,yg4)
> c     call ints4(precc,    nface4,xg4,yg4)
379,380c352,353
<         call ints4(snowd,  nface4,xg4,yg4,nord)
<         call ints4(sicedep,nface4,xg4,yg4,nord)
---
>         call ints4(snowd,  nface4,xg4,yg4)
>         call ints4(sicedep,nface4,xg4,yg4)
382,384c355,357
< c       call ints4(cloudlo,nface4,xg4,yg4,nord)
< c       call ints4(cloudmi,nface4,xg4,yg4,nord)
< c       call ints4(cloudhi,nface4,xg4,yg4,nord)
---
> c       call ints4(cloudlo,nface4,xg4,yg4)
> c       call ints4(cloudmi,nface4,xg4,yg4)
> c       call ints4(cloudhi,nface4,xg4,yg4)
387,390c360,362
< c       call ints4(tscrn,  nface4,xg4,yg4,nord)
< 
< c       call ints4(qgscrn, nface4,xg4,yg4,nord)
< c       call ints4(u10,    nface4,xg4,yg4,nord)
---
> c       call ints4(tscrn,  nface4,xg4,yg4)
> c       call ints4(qgscrn, nface4,xg4,yg4)
> c       call ints4(u10,    nface4,xg4,yg4)
404,407c376,377
<       if(nmaxpr.eq.1)then
<         print *,'after ints tss_l, tss_s ',tss_l(idjd),tss_s(idjd)
<         print *,'after ints tss',tss(idjd)
<       endif  ! (nmaxpr.eq.1)
---
>       print *,'after ints tss_l, tss_s ',tss_l(idjd),tss_s(idjd)
>       print *,'after ints tss',tss(idjd)
431a402
>       print *,'successfully finished onthefly with zss(idjd) ',zss(idjd)
435c406
<       subroutine ints4(s,nface4 ,xg4 ,yg4,nord)  ! does calls to intsb
---
>       subroutine ints4(s,nface4 ,xg4 ,yg4)  ! does calls to intsb
441,449c412,415
<       if(nord.eq.1)then
<         do m=1,4
<          call ints_blb(s,wrk(1,m),nface4(1,m),xg4(1,m),yg4(1,m))
<         enddo
<       else
<         do m=1,4
<          call intsb(s,wrk(1,m),nface4(1,m),xg4(1,m),yg4(1,m))
<         enddo
<       endif   ! (nord.eq.1)  .. else ..
---
>       do m=1,4
> c      print *,'in ints4 for m= ',m
>        call intsb(s,wrk(1,m),nface4(1,m),xg4(1,m),yg4(1,m))
>       enddo
451c417
<         print *,'in ints4 for id,jd,nord: ',id,jd,nord
---
>         print *,'in ints4 for id,jd: ',id,jd
474c440
<      .       ,dum2(3*ifull -(il+4)*(il+4)*(npanels+1) )
---
>      .       ,dum2(2*ifull -(il+4)*(il+4)*(npanels+1) )
573,630d538
<       enddo    ! iq loop
<       return
<       end
< 
<       subroutine ints_blb(s,sout,nface,xg,yg) 
< c     this one does bi-linear interpolation only
<       include 'newmpar.h'
<       include 'parm.h'
<       dimension s(ifull),nface(ifull),xg(ifull),yg(ifull)
<       common/work2b/sx(-1:il+2,-1:il+2,0:npanels)
<      .       ,dum2(3*ifull -(il+4)*(il+4)*(npanels+1) )
< c     real sx(-1:il+2,-1:il+2,0:npanels),
<       real sout(ifull)
<       include 'indices.h' ! in,is,iw,ie,inn,iss,iww,iee
<       dimension in6(il,il,0:npanels),is6(il,il,0:npanels)
<      .         ,iw6(il,il,0:npanels),ie6(il,il,0:npanels)
<      .         ,inn6(il,il,0:npanels),iss6(il,il,0:npanels)
<      .         ,iww6(il,il,0:npanels),iee6(il,il,0:npanels)
<      .         ,ine6(il,il,0:npanels),ise6(il,il,0:npanels)
<      .         ,ien6(il,il,0:npanels),iwn6(il,il,0:npanels)
<       equivalence (in,in6),(is,is6),(iw,iw6),(ie,ie6)
<       equivalence (inn,inn6),(iss,iss6),(iww,iww6),(iee,iee6)
<       equivalence (ine,ine6),(ise,ise6),(ien,ien6),(iwn,iwn6)
<       ind(i,j,n)=i+(j-1)*il+n*il*il  ! *** for n=0,npanels
< c     first extend s arrays into sx - this one -1:il+2 & -1:il+2
< c                    but for bi-linear only need 0:il+1 &  0:il+1
<       do n=0,npanels
<        do j=1,il
<         do i=1,il
<          sx(i,j,n)=s(ind(i,j,n))
<         enddo  ! i loop
<        enddo   ! j loop
<        do j=1,il
<         sx(0,j,n)=s(iw6(1,j,n))
<         sx(il+1,j,n)=s(ie6(il,j,n))
<        enddo   ! j loop
<        do i=1,il
<         sx(i,0,n)=s(is6(i,1,n))
<         sx(i,il+1,n)=s(in6(i,il,n))
<        enddo  ! i loop
< 
<        sx(0,0,n)=s(lws(n))
<        sx(il+1,0,n)=s(les(n))
<        sx(0,il+1,n)   =s(iwn6(1,il,n))
<        sx(il+1,il+1,n)=s(ien6(il,il,n))
<       enddo    ! n loop
< 
<       do iq=1,ifull
<        n=nface(iq)
<        idel=int(xg(iq))
<        xxg=xg(iq)-idel
<        jdel=int(yg(iq))
<        yyg=yg(iq)-jdel
< c      print *,'iq,idel,jdel,n ',iq,idel,jdel,n
<        sout(iq)=yyg*(xxg*sx(idel+1,jdel+1,n)
<      .               +(1.-xxg)*sx(idel,jdel+1,n))
<      .    +(1.-yyg)*(xxg*sx(idel+1,jdel,n)
<      .               +(1.-xxg)*sx(idel,jdel,n))
=====================================
 
optm.f
=====================================
=====================================
 
outcdf.f
=====================================
3a4,7
>       include 'aalat.h'
>       include 'arrays.h'
>       include 'astro.h'
> !     include 'comhtg.h'
5a10
>       include 'extraout.h'
8c13,15
<       include 'liqwpar.h'  ! ifullw
---
>       include 'map.h'
>       include 'mapproj.h'
>       include 'morepbl.h'
10,11c17
<       include 'parmdyn.h'  
<       include 'parmhor.h'  ! mhint, m_bs, nt_adv, ndept
---
>       include 'parmdyn.h'
13c19,36
<       include 'tracers.h'  ! ngas, nllp, ntrac, tr
---
>       include 'pbl.h'
>       include 'prec.h'
>       include 'screen.h'
>       include 'sigs.h'
>       include 'soil.h'
>       include 'tracers.h'
>       include 'trcom2.h'
>       include 'vvel.h'
>       include 'scamdim.h'
>       include 'soilsnow.h'
>       common/histave/eg_ave(ifull),fg_ave(ifull),ga_ave(ifull),
>      .    epot_ave(ifull),
>      .    qscrn_ave(ifull),tmaxscr(ifull),tminscr(ifull),tscr_ave(ifull)
>       common/raddiag/sint_ave(ifull), sot_ave (ifull), soc_ave (ifull),
>      &               sgn_ave (ifull), rtu_ave (ifull), rtc_ave (ifull),
>      &               rgn_ave (ifull), cld_ave (ifull), cll_ave (ifull),
>      &               clm_ave (ifull), clh_ave (ifull), koundiag
>       common/work3/qgout(ifull,kl),dum3(ifull,kl,3)
144c167
<         nahead(5)=nsd        ! not needed now
---
>         nahead(5)=nsd        ! needed by cc2hist
162c185
<         nahead(23)=nqg       ! not needed now      
---
>         nahead(23)=nqg       ! needed by cc2hist
190c213
<         nahead(51)=ifullw
---
>         nahead(51)=0  ! nchen now not used or defined
259a283,284
>       include 'astro.h'
> !     include 'comhtg.h'
263c288
<       include 'filnames.h' ! list of files, read in once only
---
>       include 'filnames.h'  ! list of files, read in once only
265d289
<       include 'liqwpar.h'  ! ifullw
269d292
<       include 'netcdf.inc'
276d298
<       include 'scamdim.h'
280,281c302
<       include 'soilsnow.h'
<       include 'soilv.h'   ! sfc,zse
---
>       include 'soilv.h'  ! zse
284c305,309
<       include 'vvel.h'    ! sdot, dpsldt
---
>       include 'vvel.h'
>       include 'scamdim.h'
>       include 'soilsnow.h'
> 
>       include 'netcdf.inc'
286c311
<       character lname*50,expdesc*50,numba*2
---
>       character lname*50, expdesc*50
292d316
<       common/dpsdt/dpsdt(ifull)    ! shared adjust5 & openhist
294c318
<      .    epot_ave(ifull),cbas_ave(ifull),ctop_ave(ifull),
---
>      .    epot_ave(ifull),
296d319
< !       *** qscrn_ave not presently written     
299,304c322,325
<      &               rgn_ave (ifull), rgc_ave (ifull), cld_ave (ifull), 
<      &               cll_ave (ifull), clm_ave (ifull), clh_ave (ifull), 
<      &               koundiag
<       common/work2/pmsl(ifull),aa(ifull),bb(ifull),cc(ifull),
<      &             dum2(ifull,14)
<       common/work3c/tmpry(ifull,kl)
---
>      &               rgn_ave (ifull), cld_ave (ifull), cll_ave (ifull),
>      &               clm_ave (ifull), clh_ave (ifull), koundiag
>       common/work2/pmsl(ifull),tssout(ifull),tmp(ifull)
>      &      ,cll(ifull),clm(ifull),clh(ifull),dum2(ifull,12)
311,313c332,342
< !     if(itype.ne.-1)then  ! don't scale up for restart file as done already
< !       insert stuff here if re-scaling clouds etc
< !     endif  ! (itype.ne.-1)
---
> c     convert cloud from fraction to %
>       do iq=1,ifull
>           cll(iq)=cloudlo(iq)*100.
>           clm(iq)=cloudmi(iq)*100.
>           clh(iq)=cloudhi(iq)*100.
>       enddo
> c     reincorporate land mask into surface temperature (only DARLAM ??)
>       do iq=1,ifull
>          tssout(iq)=tss(iq)
>          if(.not.land(iq))tssout(iq)=-tss(iq)
>       enddo  
315c344
< c     if this is the first archive, set up some global attributes
---
> c if this is the first archive, set up some global attributes
323,324c352,354
< c       Create global attributes
< c       Model run number
---
> c Create global attributes
> 
> c Model run number
329c359
< c       Experiment description
---
> c Experiment description
334c364
< c       Sigma levels
---
> c Sigma levels
379,380d408
<         lname = 'Surface geopotential'
<         call attrib(idnc,idim2,2,'zht',lname,'m2/s2',-100.,90.e3)
382a411,412
>         lname = 'Surface geopotential'
>         call attrib(idnc,idim2,2,'zht',lname,'m2/s2',-100.,9.e4)
386a417,418
>         lname = 'Albedo initial'
>         call attrib(idnc,idim2,2,'als',lname,'none',0.,1.)
388,389c420,421
<         call attrib(idnc,idim2,2,'rsmin',lname,'none',0.,200.)
<         lname = 'Vegetation fraction'
---
>         call attrib(idnc,idim2,2,'rsmin',lname,'none',0.,10.)
>         lname = 'Sigmf'
391,392d422
<         lname = 'Surface roughness'
<         call attrib(idnc,idim2,2,'zolnd',lname,'none',0.,40.)
394a425,426
>         lname = 'Surface roughness'
>         call attrib(idnc,idim2,2,'zolnd',lname,'none',0.,40.)
405,406d436
<         lname = '3hr precipitation'
<         call attrib(idnc,idim2,3,'rnd03',lname,'mm',0.,1000.)
408,410c438
<         call attrib(idnc,idim2,3,'rnd06',lname,'mm',0.,1000.)
<         lname = '9hr precipitation'
<         call attrib(idnc,idim2,3,'rnd09',lname,'mm',0.,1000.)
---
>         call attrib(idnc,idim2,3,'rnd6',lname,'mm/day',0.,1000.)
412,414c440
<         call attrib(idnc,idim2,3,'rnd12',lname,'mm',0.,1000.)
<         lname = '15hr precipitation'
<         call attrib(idnc,idim2,3,'rnd15',lname,'mm',0.,1000.)
---
>         call attrib(idnc,idim2,3,'rnd12',lname,'mm/day',0.,1000.)
416,418c442
<         call attrib(idnc,idim2,3,'rnd18',lname,'mm',0.,1000.)
<         lname = '21hr precipitation'
<         call attrib(idnc,idim2,3,'rnd21',lname,'mm',0.,1000.)
---
>         call attrib(idnc,idim2,3,'rnd18',lname,'mm/day',0.,1000.)
421,423d444
<         lname = 'Snowfall'
<         call attrib(idnc,idim2,3,'sno',lname,'mm/day',0.,1000.)
<         call attrib(idnc,idim2,3,'runoff','Runoff','mm/day',0.,1000.)
433c454
<         call attrib(idnc,idim2,3,'qgscrn',lname,'kg/kg',0.,.06)
---
>         call attrib(idnc,idim2,3,'qgscrn',lname,'kg/kg',0.,.05)
435,439c456
<         call attrib(idnc,idim2,3,'u10',lname,'K',0.,60.)
< c       lname = '3m wind speed'
< c       call attrib(idnc,idim2,3,'u3',lname,'K',0.,60.)
<         lname = 'Screen level wind speed'
<         call attrib(idnc,idim2,3,'uscrn',lname,'K',0.,40.)
---
>         call attrib(idnc,idim2,3,'u10',lname,'K',0.,40.)
444,445d460
<         lname = 'snow depth (liquid water)'
<         call attrib(idnc,idim2,3,'snd',lname,'cm',0.,1000.)
447,454c462,467
<         lname = 'Low cloud ave'
<         call attrib(idnc,idim2,3,'cll',lname,'frac',0.,1.)
<         lname = 'Mid cloud ave'
<         call attrib(idnc,idim2,3,'clm',lname,'frac',0.,1.)
<         lname = 'Hi cloud ave'
<         call attrib(idnc,idim2,3,'clh',lname,'frac',0.,1.)
<         lname = 'Total cloud ave'
<         call attrib(idnc,idim2,3,'cld',lname,'frac',0.,1.)
---
>         lname = 'Low cloud'
>         call attrib(idnc,idim2,3,'cll',lname,'%',0.,100.)
>         lname = 'Mid cloud'
>         call attrib(idnc,idim2,3,'clm',lname,'%',0.,100.)
>         lname = 'Hi cloud'
>         call attrib(idnc,idim2,3,'clh',lname,'%',0.,100.)
456c469
<         call attrib(idnc,idim2,3,'taux',lname,'N/m2',-50.,50.)
---
>         call attrib(idnc,idim2,3,'taux',lname,'N/m2',-10.,10.)
458,464c471,473
<         call attrib(idnc,idim2,3,'tauy',lname,'N/m2',-50.,50.)
<         lname = 'Soil moisture as frac FC levels 1-2'
<         call attrib(idnc,idim2,3,'wbfshal',lname,'frac',0.,4.)
<         lname = 'Soil moisture as frac FC levels 3-4'
<         call attrib(idnc,idim2,3,'wbfroot',lname,'frac',0.,4.)
<         lname = 'Soil moisture as frac FC levels 1-6'
<         call attrib(idnc,idim2,3,'wbftot',lname,'frac',0.,4.)
---
>         call attrib(idnc,idim2,3,'tauy',lname,'N/m2',-10.,10.)
>         lname = 'Runoff'
>         call attrib(idnc,idim2,3,'runoff',lname,'mm/day',0.,1000.)
468c477
<           call attrib(idnc,idim2,3,'rtu_ave',lname,'W/m2',0.,800.)
---
>           call attrib(idnc,idim2,3,'rtu',lname,'W/m2',0.,800.)
470,486c479
<           call attrib(idnc,idim2,3,'rtc_ave',lname,'W/m2',0.,800.)
<           lname = 'LW down at ground'
<           call attrib(idnc,idim2,3,'rgn_ave',lname,'W/m2',-500.,1000.)
<           lname = 'Clear sky LW at ground'
<           call attrib(idnc,idim2,3,'rgc_ave',lname,'W/m2',-500.,1000.)
<           lname = 'Solar in at TOA'
<           call attrib(idnc,idim2,3,'sint_ave',lname,'W/m2',0.,1600.)
<           lname = 'Solar out at TOA'
<           call attrib(idnc,idim2,3,'sot_ave',lname,'W/m2',0.,1000.)
<           lname = 'Clear sky SW out at TOA'
<           call attrib(idnc,idim2,3,'soc_ave',lname,'W/m2',0.,900.)
<           lname = 'Solar down at ground'
<           call attrib(idnc,idim2,3,'sgn_ave',lname,'W/m2',-500.,2000.)
<           lname = 'Surface pressure tendency'
<           call attrib(idnc,idim2,3,'dpsdt',lname,'hPa/day',-400.,400.)
<           lname = 'PBL depth'
<           call attrib(idnc,idim2,3,'pblh',lname,'m',0.,6000.)
---
>           call attrib(idnc,idim2,3,'rtc',lname,'W/m2',0.,800.)
488a482,483
>           lname = 'surface roughness'
>           call attrib(idnc,idim2,3,'zo',lname,'m',0.,2.)
490a486,514
>         print *,'3d variables'
> 
>         write(lname,'(a)') 'Air temperature'
> 	 call attrib(idnc,dim,4,'temp',lname,'K',100.,350.)
>         write(lname,'(a)') 'Zonal wind'
> 	 call attrib(idnc,dim,4,'u',lname,'m/s',-100.,150.)
>         write(lname,'(a)') 'Meridional wind'
>         call attrib(idnc,dim,4,'v',lname,'m/s',-100.,150.)
>         write(lname,'(a)') 'Specific humidity'
>         call attrib(idnc,dim,4,'mixr',lname,'kg/kg',0.,.05)
> 
>         print *,'nqg=',nqg
>         if(nsd.ge.1)then
>           write(lname,'(a)') 'change in grid spacing per time step +.5'
>           call attrib(idnc,dim,4,'sdot',lname,'1/ts',-3.,3.)
>         endif ! ( nsd.ge.1 ) then
> 
>         lname = 'Soil moisture lev 1'
>         call attrib(idnc,idim2,3,'wb1',lname,'m3/m3',0.,1.)
>         lname = 'Soil moisture lev 2'
>         call attrib(idnc,idim2,3,'wb2',lname,'m3/m3',0.,1.)
>         lname = 'Soil moisture lev 3'
>         call attrib(idnc,idim2,3,'wb3',lname,'m3/m3',0.,1.)
>         lname = 'Soil moisture lev 4'
>         call attrib(idnc,idim2,3,'wb4',lname,'m3/m3',0.,1.)
>         lname = 'Soil moisture lev 5'
>         call attrib(idnc,idim2,3,'wb5',lname,'m3/m3',0.,1.)
>         lname = 'Soil moisture lev 6'
>         call attrib(idnc,idim2,3,'wb6',lname,'m3/m3',0.,1.)
504,508c528
<         call attrib(idnc,idim2,3,'rnet',lname,'W/m2',-3000.,3000.)
<         lname = 'Avg cloud base'
<         call attrib(idnc,idim2,3,'cbas_ave',lname,'sigma',0.,1.1)
<         lname = 'Avg cloud top'
<         call attrib(idnc,idim2,3,'ctop_ave',lname,'sigma',0.,1.1)
---
>         call attrib(idnc,idim2,3,'rnet',lname,'W/m2',-5000.,5000.)
510c530
<         call attrib(idnc,idim2,3,'epot_ave',lname,'W/m2',-1000.,10.e3)
---
>         call attrib(idnc,idim2,3,'epot_ave',lname,'W/m2',-1000.,5000.)
512c532
<         call attrib(idnc,idim2,3,'eg',lname,'W/m2',-1000.,3000.)
---
>         call attrib(idnc,idim2,3,'eg',lname,'W/m2',-1000.,5000.)
514c534
<         call attrib(idnc,idim2,3,'eg_ave',lname,'W/m2',-1000.,3000.)
---
>         call attrib(idnc,idim2,3,'eg_ave',lname,'W/m2',-1000.,5000.)
516c536
<         call attrib(idnc,idim2,3,'fg',lname,'W/m2',-3000.,3000.)
---
>         call attrib(idnc,idim2,3,'fg',lname,'W/m2',-5000.,5000.)
518,538c538,546
<         call attrib(idnc,idim2,3,'fg_ave',lname,'W/m2',-3000.,3000.)
<         lname = 'Avg flux into tgg1 layer'
<         call attrib(idnc,idim2,3,'ga_ave',lname,'W/m2',-1000.,1000.)
< 	 if(ntrac.gt.0)then ! ntrac because may have nllp>0
<          do igas=1,ntrac
< 	   write(numba,'(i2.2)') igas
< !         N.B. may need to set trmax manually if starting with zero concentration	 
<           trmax=1.  ! N.B. trmax only set first time, with iarch=1
< 	   if(igas.eq.iRADON)trmax=1000.  ! typical large value is 1000.
<           trmin=0.
<           if(nllp.gt.0.and.igas.eq.ngas+1)trmin=-90.   ! i.e. latitudes
<           do k=1,kl
<            do iq=1,ifull
<             trmax=max(trmax,tr(iq,k,igas))
<            enddo
<           enddo!k
<           trmax=1.5*trmax  ! for safety during the coming month
<           lname = 'Tracer'//numba
<           call attrib(idnc,dim,4,'tr'//numba,lname,'ppm',trmin,trmax)
<          enddo ! igas loop
< 	 endif  ! (ntrac.gt.0)
---
>         call attrib(idnc,idim2,3,'fg_ave',lname,'W/m2',-5000.,5000.)
>         lname = 'Avg ground heat flux'
>         call attrib(idnc,idim2,3,'ga_ave',lname,'W/m2',-5000.,5000.)
>         lname = 'Avg LW flux at ground'
>         call attrib(idnc,idim2,3,'rgn_ave',lname,'W/m2',-5000.,5000.)
>         lname = 'Avg solar flux at ground'
>         call attrib(idnc,idim2,3,'sgn_ave',lname,'W/m2',-5000.,5000.)
>         lname = 'snow depth (liquid water)'
>         call attrib(idnc,idim2,3,'snd',lname,'cm',0.,1000.)
540,567c548
<         print *,'3d variables'
< 	 call attrib(idnc,dim,4,'temp','Air temperature','K',100.,350.)
<    	 call attrib(idnc,dim,4,'u','x-component wind','m/s',-150.,150.)
<         call attrib(idnc,dim,4,'v','y-component wind','m/s',-150.,150.)
<         lname= 'vertical velocity'
<         call attrib(idnc,dim,4,'omega',lname,'Pa/s',-50.,50.)
<         lname= 'Water mixing ratio'
<         call attrib(idnc,dim,4,'mixr',lname,'kg/kg',0.,.05)
<         if(ifullw.eq.ifull)then
<           call attrib(idnc,dim,4,'qfg','Frozen water','kg/kg',0.,.02)
<           call attrib(idnc,dim,4,'qlg','Liquid water','kg/kg',0.,.02)
<         endif
< 
<         if(itype.eq.-1)then   ! extra stuff just needed for restart file
<          lname= 'sdot: change in grid spacing per time step +.5'
<          call attrib(idnc,dim,4,'sdot',lname,'1/ts',-3.,3.) ! just restart file
<          lname = 'Soil moisture lev 1'
<          call attrib(idnc,idim2,3,'wb1',lname,'m3/m3',0.,1.)
<          lname = 'Soil moisture lev 2'
<          call attrib(idnc,idim2,3,'wb2',lname,'m3/m3',0.,1.)
<          lname = 'Soil moisture lev 3'
<          call attrib(idnc,idim2,3,'wb3',lname,'m3/m3',0.,1.)
<          lname = 'Soil moisture lev 4'
<          call attrib(idnc,idim2,3,'wb4',lname,'m3/m3',0.,1.)
<          lname = 'Soil moisture lev 5'
<          call attrib(idnc,idim2,3,'wb5',lname,'m3/m3',0.,1.)
<          lname = 'Soil moisture lev 6'
<          call attrib(idnc,idim2,3,'wb6',lname,'m3/m3',0.,1.)
---
>        if(itype.eq.-1)then   ! extra stuff just needed for restart file
602c583,585
<         endif  ! (itype.eq.-1)
---
>        endif  ! (itype.eq.-1)
> 
>        print *,'finished defining attributes'
604,605c587
<         print *,'finished defining attributes'
< c       Leave define mode
---
> c      Leave define mode
643c625
<       endif ! iarch.eq.1
---
>       end if ! iarch.eq.1
674c656
<         call histwrt3(rsmin,'rsmin',idnc,iarch)
---
>         call histwrt3(albsav,'als',idnc,iarch)
676d657
<         call histwrt3(zolnd,'zolnd',idnc,iarch)
678c659
<          aa(iq)=isoilm(iq)
---
>          tmp(iq)=isoilm(iq)
680c661
<         call histwrt3(aa,'soilt',idnc,iarch)
---
>         call histwrt3(tmp,'soilt',idnc,iarch)
683c664
<          aa(iq)=ivegt(iq)
---
>          tmp(iq)=ivegt(iq)
685c666
<         call histwrt3(aa,'vegt',idnc,iarch)
---
>         call histwrt3(tmp,'vegt',idnc,iarch)
687,688c668,673
<          isoil=isoilm(iq)
<          aa(iq)=(wb(iq,3)-swilt(isoil))/(sfc(isoil)-swilt(isoil))
---
>          if(land(iq))then
>            isoil=isoilm(iq)
>            tmp(iq)=(wb(iq,3)-swilt(isoil))/(sfc(isoil)-swilt(isoil))
>          else
>            tmp(iq)=0.
>          endif
690c675
<         call histwrt3(aa,'wetfrac',idnc,iarch)
---
>         call histwrt3(tmp,'wetfrac',idnc,iarch)
696c681
<         aa(iq)=pmsl(iq)/100.
---
>         tmp(iq)=pmsl(iq)/100.
698c683
<       call histwrt3(aa,'pmsl',idnc,iarch)
---
>       call histwrt3(tmp,'pmsl',idnc,iarch)
700a686,698
>       call histwrt3(precip,'rnd',idnc,iarch)
>       call histwrt3(rnd6,'rnd6',idnc,iarch)
>       call histwrt3(rnd12,'rnd12',idnc,iarch)
>       call histwrt3(rnd18,'rnd18',idnc,iarch)
>       call histwrt3(precc,'rnc',idnc,iarch)
>       call histwrt3(snowd,'snd',idnc,iarch)
>       call histwrt3(tmaxscr,'tmaxscr',idnc,iarch)
>       call histwrt3(tminscr,'tminscr',idnc,iarch)
>       call histwrt3(tscr_ave,'tscr_ave',idnc,iarch)
>       call histwrt3(tscrn,'tscrn',idnc,iarch)
>       call histwrt3(qgscrn,'qgscrn',idnc,iarch)
>       call histwrt3(u10,'u10',idnc,iarch)
>       call histwrt3(sicedep,'siced',idnc,iarch)
707,810c705,725
<       do iq=1,ifull
< !      calculate wb/field_capacity;  up to 3.0 for sand (isoil=1)	   
< 	isoil=isoilm(iq)
< 	aa(iq)=(zse(1)*wb(iq,1)+zse(2)*wb(iq,2))/
<      .	       ((zse(1)+zse(2))*sfc(isoil))
< 	bb(iq)=(zse(3)*wb(iq,3)+zse(4)*wb(iq,4))/
<      .	       ((zse(3)+zse(4))*sfc(isoil))
< 	cc(iq)=(zse(1)*wb(iq,1)+zse(2)*wb(iq,2)+zse(3)*wb(iq,3)+
<      .         zse(4)*wb(iq,4)+zse(5)*wb(iq,5)+zse(6)*wb(iq,6))/
<      .	       ((zse(1)+zse(2)+zse(3)+zse(4)+zse(5)+zse(6))*sfc(isoil))
<       enddo
<       call histwrt3(aa,'wbfshal',idnc,iarch)
<       call histwrt3(bb,'wbfroot',idnc,iarch)
<       call histwrt3(cc,'wbftot',idnc,iarch)
<       call histwrt3(sicedep,'siced',idnc,iarch)
<       call histwrt3(snowd,'snd',idnc,iarch)
<       
<       if(ktau.gt.0)then
<        if(nwt.ne.nperday.and.itype.ne.-1)then  
< !       scale up precip,precc,sno,runoff to mm/day (soon reset to 0 in globpe)
< !       but, don't scale up for restart file as just done in previous write
< !       ktau in next line in case ntau (& thus ktau) < nwt 
<         precip=precip*real(nperday)/min(nwt,max(1,ktau))     
<         precc =precc *real(nperday)/min(nwt,max(1,ktau))     
<         sno   =sno   *real(nperday)/min(nwt,max(1,ktau))     
<         runoff=runoff*real(nperday)/min(nwt,max(1,ktau))    
<        endif   ! (nwt.ne.nperday.and.itype.ne.-1)
<        call histwrt3(precip,'rnd',idnc,iarch)
<        call histwrt3(precc,'rnc',idnc,iarch)
<        call histwrt3(sno,'sno',idnc,iarch)
<        call histwrt3(runoff,'runoff',idnc,iarch)
<        if(mod(ktau,nperday).eq.0)then  ! N.B. only write once per day
<          call histwrt3(tmaxscr,'tmaxscr',idnc,iarch)
<          call histwrt3(tminscr,'tminscr',idnc,iarch)
< !        if writes done more than once per day, 
< !        need to augment accumulated 3-hourly rainfall in rnd06 to rnd21 
< !        to allow for intermediate zeroing of precip()
< !        this correction allows for writes of 2,4 or 8 times per day
<          nwtperday=nperday/nwt
< 	  print *,'nwtperday	',nwtperday	
< 	  if(nwtperday.eq.8)then
<   	    rnd06=rnd06+rnd03
< 	    rnd09=rnd09+rnd06
< 	    rnd12=rnd12+rnd09
< 	    rnd15=rnd15+rnd12
< 	    rnd18=rnd18+rnd15
< 	    rnd21=rnd21+rnd18
< 	  endif
< 	  if(nwtperday.eq.4)then
< 	    rnd09=rnd09+rnd06
< 	    rnd12=rnd12+rnd06
< 	    rnd15=rnd15+rnd12
< 	    rnd18=rnd18+rnd12
< 	    rnd21=rnd21+rnd18
< 	  endif
< 	  if(nwtperday.eq.2)then
< 	    rnd15=rnd15+rnd12
< 	    rnd18=rnd18+rnd12
< 	    rnd21=rnd21+rnd12
< 	  endif
<          call histwrt3(rnd03,'rnd03',idnc,iarch)
<          call histwrt3(rnd06,'rnd06',idnc,iarch)
<          call histwrt3(rnd09,'rnd09',idnc,iarch)
<          call histwrt3(rnd12,'rnd12',idnc,iarch)
<          call histwrt3(rnd15,'rnd15',idnc,iarch)
<          call histwrt3(rnd18,'rnd18',idnc,iarch)
<          call histwrt3(rnd21,'rnd21',idnc,iarch)
< 	endif
<        call histwrt3(tscr_ave,'tscr_ave',idnc,iarch)
<        call histwrt3(tscrn,'tscrn',idnc,iarch)
<        call histwrt3(qgscrn,'qgscrn',idnc,iarch)
<        call histwrt3(u10,'u10',idnc,iarch)
<        call histwrt3(uscrn,'uscrn',idnc,iarch)
<        call histwrt3(rnet,'rnet',idnc,iarch)
<        call histwrt3(cbas_ave,'cbas_ave',idnc,iarch)
<        call histwrt3(ctop_ave,'ctop_ave',idnc,iarch)
<        call histwrt3(epot_ave,'epot_ave',idnc,iarch)
<        call histwrt3(eg,'eg',idnc,iarch)
<        call histwrt3(eg_ave,'eg_ave',idnc,iarch)
<        call histwrt3(fg,'fg',idnc,iarch)
<        call histwrt3(fg_ave,'fg_ave',idnc,iarch)
<        call histwrt3(ga_ave,'ga_ave',idnc,iarch)
<        call histwrt3(cll_ave,'cll',idnc,iarch)
<        call histwrt3(clm_ave,'clm',idnc,iarch)
<        call histwrt3(clh_ave,'clh',idnc,iarch)
<        call histwrt3(cld_ave,'cld',idnc,iarch)
<        call histwrt3(taux,'taux',idnc,iarch)
<        call histwrt3(tauy,'tauy',idnc,iarch)
< c      "extra" outputs
<        print *,'nextout, idnc: ',nextout,idnc
<        if(nextout.eq.1) then
<          call histwrt3(rtu_ave,'rtu_ave',idnc,iarch)
<          call histwrt3(rtc_ave,'rtc_ave',idnc,iarch)
<          call histwrt3(rgn_ave,'rgn_ave',idnc,iarch)
<          call histwrt3(rgc_ave,'rgc_ave',idnc,iarch)
<          call histwrt3(sint_ave,'sint_ave',idnc,iarch)
<          call histwrt3(sot_ave,'sot_ave',idnc,iarch)
<          call histwrt3(soc_ave,'soc_ave',idnc,iarch)
<          call histwrt3(sgn_ave,'sgn_ave',idnc,iarch)
<          call histwrt3(dpsdt,'dpsdt',idnc,iarch)
<          call histwrt3(pblh,'pblh',idnc,iarch)
<          call histwrt3(ustar,'ustar',idnc,iarch)
<        endif  ! nextout.eq.1
<       endif    ! (ktau.gt.0)
---
>       call histwrt3(wb(1,1),'wb1',idnc,iarch)
>       call histwrt3(wb(1,2),'wb2',idnc,iarch)
>       call histwrt3(wb(1,3),'wb3',idnc,iarch)
>       call histwrt3(wb(1,4),'wb4',idnc,iarch)
>       call histwrt3(wb(1,5),'wb5',idnc,iarch)
>       call histwrt3(wb(1,6),'wb6',idnc,iarch)
>       call histwrt3(rnet,'rnet',idnc,iarch)
>       call histwrt3(epot_ave,'epot_ave',idnc,iarch)
>       call histwrt3(eg,'eg',idnc,iarch)
>       call histwrt3(eg_ave,'eg_ave',idnc,iarch)
>       call histwrt3(fg,'fg',idnc,iarch)
>       call histwrt3(fg_ave,'fg_ave',idnc,iarch)
>       call histwrt3(ga_ave,'ga_ave',idnc,iarch)
>       call histwrt3(rgn_ave,'rgn_ave',idnc,iarch)
>       call histwrt3(sgn_ave,'sgn_ave',idnc,iarch)
>       call histwrt3(cll,'cll',idnc,iarch)
>       call histwrt3(clm,'clm',idnc,iarch)
>       call histwrt3(clh,'clh',idnc,iarch)
>       call histwrt3(taux,'taux',idnc,iarch)
>       call histwrt3(tauy,'tauy',idnc,iarch)
>       call histwrt3(runoff,'runoff',idnc,iarch)
815a731
> c     Specific humidity
817,821c733,738
< 	do iq=1,ifull
< 	 tmpry(iq,k)=ps(iq)*dpsldt(iq,k)
< 	enddo
<       enddo
<       call histwrt4(tmpry,'omega',idnc,iarch)  ! 3d variable
---
> c       for packing, set a minimum qg value of 0.
>         do iq=1,ifull
>             qg(iq,k) = max(qg(iq,k),0.)
> 
>         enddo   
>       end do     ! k
823,832c740,751
<       if(ifullw.eq.ifull)then
<         call histwrt4(qfg,'qfg',idnc,iarch)
<         call histwrt4(qlg,'qlg',idnc,iarch)
<       endif
<       if(ntrac.gt.0)then 
<        do igas=1,ntrac
< 	 write(numba,'(i2.2)') igas
<         call histwrt4(tr(1,1,igas),'tr'//numba,idnc,iarch)
<        enddo ! igas loop
<       endif  ! (ntrac.gt.0)
---
> 
>       if ( nsd.ge.1 ) then  ! writes k=2 to kl+1
>         call histwrt4(sdot(1,2),'sdot',idnc,iarch)
>       endif ! ( nsd.ge.1 ) 
> 
> c     "extra" outputs
>       print *,'nextout, idnc: ',nextout,idnc
>       if(nextout.eq.1) then
>         call histwrt3(rtsave,'rtu',idnc,iarch)
>         call histwrt3(rtclsave,'rtc',idnc,iarch)
>         call histwrt3(ustar,'ustar',idnc,iarch)
>       end if  ! nextout.eq.1
835,841d753
<        call histwrt4(sdot(1,2),'sdot',idnc,iarch)
<        call histwrt3(wb(1,1),'wb1',idnc,iarch)
<        call histwrt3(wb(1,2),'wb2',idnc,iarch)
<        call histwrt3(wb(1,3),'wb3',idnc,iarch)
<        call histwrt3(wb(1,4),'wb4',idnc,iarch)
<        call histwrt3(wb(1,5),'wb5',idnc,iarch)
<        call histwrt3(wb(1,6),'wb6',idnc,iarch)
859c771
<         aa(iq)=isflag(iq)
---
>         tmp(iq)=isflag(iq)
861c773
<        call histwrt3(aa,'sflag',idnc,iarch)
---
>        call histwrt3(tmp,'sflag',idnc,iarch)
866a779,1026
>       subroutine nc2out(data,nt,thr,mthr,idnc,sname,lname,
>      &                   units,dn,dx,iprint)
>       include 'newmpar.h'
>       include 'parm.h'
>       logical debug
>       parameter ( debug=.false. )
> 
> c this program write out a 2-dim array of data with unlimited time dim.
> c in netcdf format
> 
>       include 'netcdf.inc'        ! comment out on atmos
> 
>       character*(*) sname
>       character*(*) lname
>       character*(*) units
> * netCDF id
>       integer  idnc
>       integer  ier
> * dimension ids
>       integer  dimil,dimjl,dimtim
> * variable ids
>       integer  idil,idjl,idnt,mthr
>       integer  id_data
> * variable shapes
>       integer idims(3)
> * corners and edge lengths
>       integer corner(3),edges(3)
> * data variables
>       real data(il,jl)
> * packing variables
>       integer*2 ipack(200*200) ! was integer*2 
>       integer*2 vmin, vmax, missval ! was integer*2 
>       parameter(vmin = -32500, vmax = 32500, missval = -32501)
> * dim variables
>       real coord(500)
> 
>       if ( debug ) then
>         print *,'nc2out: ifull,nt,idnc=',ifull,nt,idnc
>         print *,'nc2out: lname=',lname
>         print *,'nc2out: units=',units
>         print *,'nc2out: sx,sn=',dx,dn
>       endif ! debug
> 
>       if ( il*jl .gt. 200*200 ) then
>         print *,'il*jl=',il*jl,' too big in nc2out'
>         stop
>       endif
>       idims(1)=-1
>       idims(2)=-1
>       idims(3)=-1
> 
> c turn OFF fatal netcdf errors
>       call ncpopt(0)
> c check to see if variable exits
>       id_data = ncvid(idnc,sname,ier)
> c turn on fatal netcdf errors
>       call ncpopt(NCVERBOS+NCFATAL)
> 
> c***********************************************************************
>       if ( ier.ne.0 ) then
> c only do the following for the first call to each variable
> c***********************************************************************
> 
>         call ncinq(idnc,ndims,nvars,ngatts,nulid,ier)
>         if(debug) print *,"idnc,ndims,nvars,ngatts,nulid,ier"
>      &                    ,idnc,ndims,nvars,ngatts,nulid,ier
> 
>         call ncredf(idnc,ier)
>         if ( debug ) print *,'ncredf ier=',ier
> 
> c get dimension ids
>           dimil = 1
>           dimjl = 2
>           dimtim = 3
>           idims(1) = dimil
>           idims(2) = dimjl
>           idims(3) = dimtim
> c       endif
>         if ( debug ) print *,'idims=',idims
> 
> c create variable using short name
>         if ( mthr.ge.0 ) then
>           id_data = ncvdef(idnc,sname,ncshort,3,idims,ier)
>           if(debug)print *,"id_data(3),ier=",id_data,ier
>         else
>           id_data = ncvdef(idnc,sname,ncshort,2,idims,ier)
>           if(debug)print *,"id_data(2),ier=",id_data,ier
>         endif ! ( mthr.ge.0 ) then
>         if ( debug ) print *,'id_data,sn,ier=',id_data,sname,ier
> 
> c give it a long name
>         call ncaptc(idnc,id_data,'long_name',NCCHAR
>      &             ,lngstr(lname),lname,ier)
>         if ( debug ) print *,'lname ier=',ier
> 
> c give it units
>         call ncaptc(idnc,id_data,'units',NCCHAR
>      &             ,lngstr(units),units,ier)
>         if ( debug ) print *,'units ier=',ier
> 
> !       define valid scaled variables (v) based on max/mins
> !       so that   y=addoff + scalef*v
> !       scalef= (dx-dn)/float(vmax-vmin)
>         scalef= (dx-dn)/(real(vmax)-real(vmin)) ! jlm fix for precision problems
>         addoff= dn-scalef*float(vmin)
> 
>         if ( debug ) then
>           write(6,'("sx,sn,a,s=",1p,6e12.3)')dx,dn,addoff,scalef
>         endif ! debug
> 
>         call ncapt(idnc,id_data,'add_offset'   ,NCFLOAT,1,addoff,ier)
>         call ncapt(idnc,id_data,'scale_factor' ,NCFLOAT,1,scalef,ier)
>         call ncaptc(idnc,id_data,'FORTRAN_format',ncchar,5,'G11.4',ier)
>         call ncapt(idnc,id_data,'valid_min'    ,ncshort,1,vmin,ier)
>         call ncapt(idnc,id_data,'valid_max'    ,ncshort,1,vmax,ier)
>         call ncapt(idnc,id_data,'missing_value',ncshort,1,missval,ier)
> 
>         if ( debug ) print *,'finished attrib'
> 
> * leave define mode
>         call ncendf(idnc,ier)
> 
> * store xdim
>         do i=1,il
>           coord(i)=float(i)
>         enddo ! i
>         idil = ncvid(idnc,'longitude',ier)
>         if(debug)print *,'idil,xdim=',idil,coord(1),coord(il)
>         call ncvpt(idnc,idil,1,il,coord,ier)
> 
> * store ydim
>         do j=1,jl
>           coord(j)=float(j)
>         enddo ! j
>         idjl = ncvid(idnc,'latitude',ier)
>         if(debug)print *,'idjl,ydim=',idjl,coord(1),coord(jl)
>         call ncvpt(idnc,idjl,1,jl,coord,ier)
> 
> c***********************************************************************
>       endif ! nt=1
> c***********************************************************************
> 
>       corner(1) = 1
>       corner(2) = 1
>       corner(3) = nt
>       edges(1) = il
>       edges(2) = jl
>       edges(3) = 1
>       if ( debug ) then
>         print *,'corner=',corner
>         print *,'edges=',edges
>       endif ! debug
> 
>       if ( mthr.ge.0 ) then
> c set time to number of minutes since start = mthr
>         idnt = ncvid(idnc,'time',ier)
>         if ( debug ) print *,'ncvid idnt,ier=',idnt,ier
>         call ncvpt1(idnc,idnt,nt,mthr,ier)
>         if ( debug ) print *,'ncvpt nt,ier=',nt,ier
>       endif ! ( thr.ge.0. ) then
> 
> c find variable index
>       id_data = ncvid(idnc,sname,ier)
>       if ( debug ) then
>         print *,'ncdiv sname,id_data,ier=',sname,id_data,ier
>       endif ! debug
> 
> c get scaling factors for this variable
> !     scalef= (dx-dn)/float(vmax-vmin)
>       scalef= (dx-dn)/(real(vmax)-real(vmin)) ! jlm fix for precision problems
>       addoff= dn-scalef*float(vmin)
> 
>       if ( debug ) write(6,'("sx,sn,a,s=",6f10.2)')dx,dn,addoff,scalef
> 
> c pack data into ipack
>        adx=-1.e29
>        adn= 1.e29
> 
> ! to fix up used 1st row/column
>        do j=1,jl
>          data(1,j)=data(2,j)
>        enddo !j=1,jl
>        do i=1,il
>          data(i,1)=data(i,2)
>        enddo !i=1,il
> 
>        do j=1,jl
>         do i=1,il
>          n=i+(j-1)*il
>          adx=max(adx,data(i,j))
>          adn=min(adn,data(i,j))
>          datg=min(dx,max(dn,data(i,j)))
>          ipack(n)=nint((datg-addoff)/scalef)
>         end do ! i
>        end do ! j
> 
>       if(adx.gt.dx)write(6,*) sname,'## actual adx > dx ##',adx,dx
>       if(adn.lt.dn)write(6,*) sname,'## actual adn > dn ##',adn,dn
> 
>       if ( debug ) then
>         print *,'adx,adn=',adx,adn
>       endif ! debug
> 
> c put packed data into cdf file
>       call ncvpt(idnc,id_data,corner,edges,ipack,ier)
>       if ( debug ) print *,'ier=',ier
>       if(mod(ktau,nmaxpr).eq.0)
>      &    write(6,'("nc2out ",a7,2i4,f10.2,1p,2e12.3)')
>      &                        sname,idnc,nt,thr,adn,adx
> 
>       if(iprint.eq.1)print*,'nc2out: ktau,sname= ',ktau,sname,data
>       return
>       end ! nc2out
> c=======================================================================
>       subroutine moncdf(idmon,timer,mtimer,t35,t00,rainmax,raind,
>      &                  raindc,numcat)
> 
>       include 'newmpar.h'
> 
>       real t35(ifull),t00(ifull)
>       real rainmax(ifull),raind(ifull),raindc(ifull,numcat)
>       character*6 sname
>       character*40 lname
> 
>       print *,"moncdf idmon,timer,mtimer= ",idmon,timer,mtimer
> 
>       nt=1
>       call nc2out(t35,nt,timer,mtimer,idmon
>      &         ,'t35','number of days temperature > 35','none',0.,40.,0)
>       call nc2out(t00,nt,timer,mtimer,idmon
>      &         ,'t00','number of days temperature < 0','none',0.,40.,0)
>       call nc2out(rainmax,nt,timer,mtimer,idmon
>      &         ,'rndmax','maximum daily rainfall','mm',0.,200.,0)
>       call nc2out(raind,nt,timer,mtimer,idmon
>      &         ,'raind','number of days rain > .2mm','none',0.,40.,0)
>       write(6,*)"numcat=",numcat
>       do n = 1, numcat
>         write(sname,'("rd",i3.3)') 20*n
>         write(lname,'("number of days with rain gt",i3,"mm")') 20*n
>         call nc2out(raindc(1,n),nt,timer,mtimer,idmon,sname
>      &             ,lname,'none',0.,40.,0)
>       enddo ! n = 1, numcat
> 
>       call ncsnc(idmon,ier)
> 
>       return
>       end
> c=======================================================================
871,872c1031,1032
<       integer*2 minv, maxv, missval   ! was integer*2
<       parameter(minv = -32500, maxv = 32500, missval = -32501)
---
>       integer*2 vmin, vmax, missval   ! was integer*2
>       parameter(vmin = -32500, vmax = 32500, missval = -32501)
888,889c1048,1049
<       call ncapt(cdfid,idv,'valid_min'    ,ncshort,1,minv,ier)
<       call ncapt(cdfid,idv,'valid_max'    ,ncshort,1,maxv,ier)
---
>       call ncapt(cdfid,idv,'valid_min'    ,ncshort,1,vmin,ier)
>       call ncapt(cdfid,idv,'valid_max'    ,ncshort,1,vmax,ier)
891,893c1051,1053
< !     scalef=(xmax-xmin)/float(maxv - minv)
<       scalef=(xmax-xmin)/(real(maxv)-real(minv)) ! jlm fix for precision problems
<       addoff=xmin-scalef*minv
---
> !     scalef = (xmax - xmin) / float(vmax - vmin)
>       scalef = (xmax - xmin) /(real(vmax)-real(vmin)) ! jlm fix for precision problems
>       addoff = xmin - scalef*vmin
923,924c1083,1084
<       integer*2 minv, maxv, missval ! was integer*2 
<       parameter(minv = -32500, maxv = 32500, missval = -32501)
---
>       integer*2 vmin, vmax, missval ! was integer*2 
>       parameter(vmin = -32500, vmax = 32500, missval = -32501)
938c1098
<       call ncagt(idnc,mid,'scale_factor',scale_f,ier)
---
>       call ncagt(idnc,mid,'scale_factor',sf,ier)
940,942c1100,1102
<       xmin=addoff+scale_f*minv
< !     xmax=xmin+scale_f*float(maxv-minv)
<       xmax=xmin+scale_f*(real(maxv)-real(minv)) ! jlm fix for precision problems
---
>       xmin = addoff + sf*vmin
> !     xmax = xmin + sf*float(vmax - vmin)
>       xmax = xmin + sf*(real(vmax)-real(vmin)) ! jlm fix for precision problems
947a1108
> c         varn=min(varn,var(i,j))
952a1114
> c         varx=max(varx,var(i,j))
958,960c1120,1122
<           pvar = max(xmin,min(xmax,var(i,j))) ! limited output variable
<           ipack(i,j)=nint((pvar-addoff)/scale_f)
<           ipack(i,j)=max(min(ipack(i,j),maxv),minv)
---
>           pvar = max(xmin,min(xmax,var(i,j)))
>           ipack(i,j)=nint((pvar-addoff)/sf)
>           ipack(i,j)=max(min(ipack(i,j),vmax),vmin)
968c1130
<      &      write(6,'("histwrt3 ",a7,i4,f12.4,2i4,f12.4,2i4,f12.4)')
---
>      &      write(6,'("histwrt3 ",a7,i3,f12.4,2i4,f12.4,2i4,f12.4)')
984,985c1146,1147
<       integer*2 minv, maxv, missval ! was integer*2 
<       parameter(minv = -32500, maxv = 32500, missval = -32501)
---
>       integer*2 vmin, vmax, missval ! was integer*2 
>       parameter(vmin = -32500, vmax = 32500, missval = -32501)
1001c1163
<       call ncagt(idnc,mid,'scale_factor',scale_f,ier)
---
>       call ncagt(idnc,mid,'scale_factor',sf,ier)
1003,1005c1165,1167
<       xmin=addoff+scale_f*minv
< !     xmax=xmin+scale_f*float(maxv-minv)
<       xmax=xmin+scale_f*(real(maxv)-real(minv)) ! jlm fix for precision problems
---
>       xmin = addoff + sf*vmin
> c     xmax = xmin + sf*float(vmax - vmin)
>       xmax = xmin + sf*(real(vmax)-real(vmin)) ! jlm fix for precision problems
1012,1014c1174,1176
<           pvar = max(xmin,min(xmax,var(i,j,k))) ! limited output variable
<           ipack(i,j,k)=nint((pvar-addoff)/scale_f)
<           ipack(i,j,k)=max(min(ipack(i,j,k),maxv),minv)
---
>           pvar = max(xmin,min(xmax,var(i,j,k)))
>           ipack(i,j,k)=nint((pvar-addoff)/sf)
>           ipack(i,j,k)=max(min(ipack(i,j,k),vmax),vmin)
1030c1192
<      &      write(6,'("histwrt4 ",a7,i4,2f12.4,3i4)') 
---
>      &      write(6,'("histwrt4 ",a7,i3,2f12.4,3i4)') 
=====================================
 
outfile.f
=====================================
2c2
<      .                   nwrite)
---
>      .        nwrite,nrad)
21c21
<       include 'parmdyn.h'  
---
>       include 'parmdyn.h'  ! morder,ntomg
26c26
<       include 'screen.h'  
---
>       include 'screen.h'  !  tscrn3hr
34c34
<      .    epot_ave(ifull),cbas_ave(ifull),ctop_ave(ifull),
---
>      .    epot_ave(ifull),
78c78
<       endif  ! (ktau.eq.0.and.io_rest.ne.0)
---
>       endif
88c88
<       endif  ! (ktau.eq.nsnowout)
---
>       endif
96c96
<       call mslp(pmsl,psl,zs,t)
---
>       call mslp(pmsl)
147c147
< c           if(land(iq))then
---
>            if(land(iq))then
150,152c150,152
< c           else
< c             aa(iq)=0.
< c           endif
---
>            else
>              aa(iq)=0.
>            endif
207,208c207
<         print *,'writing rtsave and was tscrn3hr'
<         write(iout) rtsave
---
>         print *,'writing rtsave and tscrn3hr'
209a209
>         write(iout) tscrn3hr
230c230
<         if(ktau.gt.1.and.ktau.eq.abs(newsoilm))then
---
>         if(ktau.gt.kstart.and.ktau.eq.abs(newsoilm))then
283c283
<            write (77,'(12f7.2)')((tr(iq,k,ico2),iq=1,ilt*jlt),k=1,klt)
---
>            write (77,'(12f7.2)') (tr(kq,1,ico2),kq=1,ijk)
289c289
<            write (77,'(12f7.1)')((tr(iq,k,iradon),iq=1,ilt*jlt),k=1,klt)
---
>            write (77,'(12f7.1)') (tr(kq,1,iradon),kq=1,ijk)
=====================================
 
pbldif.f
=====================================
2d1
< !     vectorized version      
4d2
<       parameter (nrkmin=2)  !   1 original; 2 new
60,64c58,60
< C     local work arrays (note work3c and work3f stuff passed thru too)
<       common/work3/cgh(ifull,kl), ! counter-gradient term for heat [K/m]
<      .             cgq(ifull,kl), ! counter-gradient term for constituents
<      .             rino(ifull,kl),dum3(ifull,2*kl)
<       common/work3d/zg(ifull,kl)
---
> C     local work arrays
>       real cgh(ifull,kl)           ! counter-gradient term for heat [K/m]
>       real cgq(ifull,kl)           ! counter-gradient term for constituents
66c62
< !     real pblh(ifull)             ! boundary-layer height [m] - in morepbl.h
---
>       real pblh(il)                ! boundary-layer height [m]
77a74
>       integer i                 ! longitude index
80,81c77,78
<       real heatv                ! surface virtual heat flux
<       real thvref               ! reference level virtual temperature
---
>       real heatv(il)            ! surface virtual heat flux
>       real thvref(il)           ! reference level virtual temperature
85,87c82,84
<       real phiminv              ! inverse phi function for momentum
<       real phihinv              ! inverse phi function for heat 
<       real wm                   ! turbulent velocity scale for momentum
---
>       real phiminv(il)          ! inverse phi function for momentum
>       real phihinv(il)          ! inverse phi function for heat 
>       real wm(il)               ! turbulent velocity scale for momentum
89,90c86,87
<       real rkhfs                ! surface kinematic heat flux [mK/s]
<       real rkqfs                ! sfc kinematic constituent flux [m/s]
---
>       real khfs(il)             ! surface kinematic heat flux [mK/s]
>       real kqfs(il)             ! sfc kinematic constituent flux [m/s]
92,96c89,93
<       real rino                 ! bulk Richardson no. from level to ref lev
<       real tlv                  ! ref. level pot tmp + tmp excess
<       real fak1                 ! k*ustar*pblh
<       real fak2                 ! k*wm*pblh
<       real fak3                 ! fakn*wstr/wm 
---
>       real rino(il,kl)          ! bulk Richardson no. from level to ref lev
>       real tlv(il)              ! ref. level pot tmp + tmp excess
>       real fak1(il)             ! k*ustar*pblh
>       real fak2(il)             ! k*wm*pblh
>       real fak3(il)             ! fakn*wstr/wm 
104c101
<       real wstr                 ! w*, convective velocity scale
---
>       real wstr(il)             ! w*, convective velocity scale
106c103
<       real obklen               ! Obukhov length
---
>       real obklen(il)           ! Obukhov length
111c108
< c     logical unstbl(il)        ! pts w/unstbl pbl (positive virtual ht flx)
---
>       logical unstbl(il)        ! pts w/unstbl pbl (positive virtual ht flx)
114,116d110
<       common/work2/heatv(ifull),rkhfs(ifull),rkqfs(ifull),thvref(ifull),
<      .       phihinv(ifull),phiminv(ifull),tlv(ifull),wm(ifull),
<      .       wstr(ifull),obklen(ifull),iflag(ifull),dum2(7*ifull)
122a117
>       real onet    ! 1/3 power in wind gradient expression
133a129,130
>       real qmx(ifull,kl)
>       real zg(ifull,kl)
145a143,145
> C
> C
> C
148a149
>       onet   = 1./3.
157,161c158,164
<        enddo        ! iq loop
<       enddo         ! k  loop
<       cgh(:,:)=0.   ! 3D
<       cgq(:,:)=0.   ! 3D
<       if(ktau.eq.0)print *,'in pbldif nrkmin,npblmin: ',nrkmin,npblmin 
---
>        enddo     ! iq loop
>       enddo      ! k  loop
>       do iq=1,ijk
>             cgh(iq,1)=0.
>             cgq(iq,1)=0.
>             qmx(iq,1)=qg(iq,1)
>       enddo
162a166,167
> C
>       do 2000 j=1,jl
164c169,170
<          do iq=1,ifull
---
>          do i=1,il
> 	    iq=i+(j-1)*il
168,170c174,176
<            rkhfs(iq) = fg(iq)*rrho/cpair           !khfs=w'theta'
<            rkqfs(iq) = eg(iq)*rrho/hl              !kqfs=w'q'
< 
---
>            khfs(i) = fg(iq)*rrho/cpair           !khfs=w'theta'
>            kqfs(i) = eg(iq)*rrho/hl              !kqfs=w'q'
> C
171a178
> C
173,175c180,184
<            thvref(iq) = theta(iq,1)*(1.0 + 0.61*qg(iq,1))
<            heatv(iq)  = rkhfs(iq) + 0.61*theta(iq,1)*rkqfs(iq)
<            wm(iq)     = 0.
---
>            thvref(i) = theta(iq,1)*(1.0 + 0.61*qg(iq,1))
>            heatv(i)  = khfs(i) + 0.61*theta(iq,1)*kqfs(i)
>            wm(i)     = 0.
>            therm     = 0.
>            fak3(i)   = 0.  
177,179c186,190
<            obklen(iq) = -thvref(iq)*ustar(iq)**3/
<      $             (g*vk*(heatv(iq) + sign(1.e-10,heatv(iq))))
<          
---
>            obklen(i) = -thvref(i)*ustar(iq)**3/
>      $             (g*vk*(heatv(i) + sign(1.e-10,heatv(i))))
>            
> C
> C
183,185c194,197
< 
<            pblh(iq) = zg(iq,1)    
<            rino(iq,1) = 0.
---
> C
> C
>            pblh (i) = zg(iq,1)    
>            rino(i,1) = 0.
187a200
> C
193,210c206,229
<           iflag(:)=0
<           do k=2,kmax
<            do iq=1,ifull
<             vvk = (uav(iq,k) - uav(iq,1))**2 
<      $          + (vav(iq,k) - vav(iq,1))**2
<      $          + fac*ustar(iq)**2
< c           vvk = max(vvk,tiny)
<             tkv = theta(iq,k)*(1. + 0.61*qg(iq,k))
<             rino(iq,k) = g*(tkv - thvref(iq))*(zg(iq,k)-zg(iq,1))
<      $                    /max(thvref(iq)*vvk,tiny)
<             if(rino(iq,k).ge.ricr.and.iflag(iq).eq.0)then
<               pblh(iq) = zg(iq,k-1) + (ricr - rino(iq,k-1))/
<      $                                (rino(iq,k) - rino(iq,k-1))
<      $                               *(zg(iq,k) - zg(iq,k-1))
<               iflag(iq)=1
<             endif  ! (rino(iq,k).ge.ricr.and.iflag(iq).eq.0)
<            enddo  ! iq loop
<           enddo   ! k loop
---
>            do k=2,kmax
>             do i=1,il
>    	       iq=i+(j-1)*il
>               vvk = (uav(iq,k) - uav(iq,1))**2 
>      $           + (vav(iq,k) - vav(iq,1))**2
>      $           + fac*ustar(iq)**2
> c              vvk = max(vvk,tiny)
>                tkv = theta(iq,k)*(1. + 0.61*qg(iq,k))
>                rino(i,k) = g*(tkv - thvref(i))*(zg(iq,k)-zg(iq,1))
>      $                                      /max(thvref(i)*vvk,tiny)
>             enddo
>            enddo
>            do i=1,il
> 	     iq=i+(j-1)*il
>             do k=2,kmax
>                if(rino(i,k).ge.ricr) then
>                  pblh(i) = zg(iq,k-1) + (ricr - rino(i,k-1))/
>      $                                   (rino(i,k) - rino(i,k-1))
>      $                                  *(zg(iq,k) - zg(iq,k-1))
>                 goto 100
>                end if
>             end do
> 100        continue
>            enddo        !i=1,il
211a231
> C
214a235
> C
218,221c239,245
<          do iq=1,ifull
<           if(heatv(iq).gt.0.)then  ! unstable case
<             phiminv(iq) =     (1. - binm*pblh(iq)/obklen(iq))**(1./3.)
<             wm(iq)= ustar(iq)*phiminv(iq)
---
>         do i=1,il
> 	   iq=i+(j-1)*il
>           if (heatv(i) .gt. 0.) then
>             unstbl(i) = .true.
> !           phiminv(i) = cbrt(1. - binm*pblh(i)/obklen(i))
>             phiminv(i) =     (1. - binm*pblh(i)/obklen(i))**(1./3.)
>             wm(i)= ustar(iq)*phiminv(i)
224c248
<             therm = heatv(iq)*fak/wm(iq)
---
>             therm = heatv(i)*fak/wm(i)
226c250,252
<             tlv(iq) = thvref(iq) + therm
---
>             tlv(i) = thvref(i) + therm
>           else 
>             unstbl(i) = .false.
229c255
< 
---
> C
232c258
< 
---
> C
234c260,261
<          do iq=1,ifull
---
>          do i=1,il
> 	   iq=i+(j-1)*il
239,241c266,268
<           tkv = theta(iq,k)*(1. + 0.61*qg(iq,k))
<           rino(iq,k) = g*(tkv - tlv(iq))*(zg(iq,k)-zg(iq,1))
<      $                  /max(thvref(iq)*vvk,tiny)     ! (see (4.d.18)
---
>               tkv = theta(iq,k)*(1. + 0.61*qg(iq,k))
>               rino(i,k) = g*(tkv - tlv(i))*(zg(iq,k)-zg(iq,1))
>      $                 /max(thvref(i)*vvk,tiny)     ! (see (4.d.18)
245,258c272,286
<         iflag(:)=0
<         do k=2,kmax
<          do iq=1,ifull
<           if(heatv(iq).gt.0..and.iflag(iq).eq.0)then  ! unstable case
<             pblh(iq) = zg(iq,kl)    ! large default for unstable case
<             if(rino(iq,k).ge.ricr)then
<               pblh(iq) = zg(iq,k-1) + (ricr - rino(iq,k-1))/
<      $                                (rino(iq,k) - rino(iq,k-1))
<      $                                *(zg(iq,k) - zg(iq,k-1))
<               iflag(iq)=1  ! i.e. found it
<             endif ! (rino(iq,k).ge.ricr)
<           endif    ! (heatv(iq).gt.0..and.iflag(iq).eq.0)
<          enddo     ! i loop
<         enddo      ! k loop
---
>         do i=1,il
> 	    iq=i+(j-1)*il
>            if (unstbl(i)) then
>              pblh (i) = zg(iq,kl)   ! large default for unstable case
>              do k=2,kmax
>               if(rino(i,k).ge.ricr) then
>                 pblh(i) = zg(iq,k-1) + (ricr - rino(i,k-1))/
>      $                                  (rino(i,k) - rino(i,k-1))
>      $                                 *(zg(iq,k) - zg(iq,k-1))
>                 go to 200
>               endif
>              enddo  !  k loop
>  200       continue
>           end if
>         end do      !  i loop
277c305,306
<         do iq=1,ifull
---
>         do i=1,il
> 	  iq=i+(j-1)*il
279c308
<          pblh(iq) = max(pblh(iq),min(200.,pblmin))
---
>          pblh(i) = max(pblh(i),min(200.,pblmin))
283c312,313
<         do iq=1,ifull
---
>         do i=1,il
> 	  iq=i+(j-1)*il
285c315
<          pblh(iq) = max(pblh(iq),pblmin)
---
>          pblh(i) = max(pblh(i),pblmin)
288a319,321
>       if(ntest.eq.2)print *,'j,pblh,unstbl,rino,tlv,ustar ',
>      .            j,pblh(id),unstbl(id),rino(id,2),tlv(id),ustar(idjd)
> 
294,299c327,338
<          do iq=1,ifull
<           if(heatv(iq).gt.0.)then  ! unstable case
<             phiminv(iq) =     (1. - binm*pblh(iq)/obklen(iq))**(1./3.)
<             phihinv(iq) = sqrt(1. - binh*pblh(iq)/obklen(iq))
<             wm(iq)      = ustar(iq)*phiminv(iq)
<             wstr(iq)    = (heatv(iq)*g*pblh(iq)/thvref(iq))**(1./3.)
---
>         do i=1,il
> 	   iq=i+(j-1)*il
>           fak1(i) = ustar(iq)*pblh(i)*vk
>           if (unstbl(i)) then
> !           phiminv(i) = cbrt(1. - binm*pblh(i)/obklen(i))
>             phiminv(i) =     (1. - binm*pblh(i)/obklen(i))**(1./3.)
>             phihinv(i) = sqrt(1. - binh*pblh(i)/obklen(i))
>             wm(i)      = ustar(iq)*phiminv(i)
>             fak2(i)    = wm(i)*pblh(i)*vk
> !           wstr(i)    = cbrt(heatv(i)*g*pblh(i)/thvref(i))
>             wstr(i)    =     (heatv(i)*g*pblh(i)/thvref(i))**(1./3.)
>             fak3(i)    = fakn*wstr(i)/wm(i)
310c349
< C zmzp = 0.5*(zm + zp)
---
> C zmzp = 0.5*(zm(i) + zp(i))
312,313c351,352
<            do iq=1,ifull
<               fak1 = ustar(iq)*pblh(iq)*vk
---
>            do i=1,il
> 	       iq=i+(j-1)*il
316,317c355,356
< !             if ( zkmin.eq.0.0 .and. zp.gt.pblh(iq)) zp = pblh(iq) ! zkmin=.01
<               if (zm .lt. pblh(iq)) then
---
> !             if ( zkmin.eq.0.0 .and. zp.gt.pblh(i)) zp = pblh(i)  ! zkmin=.01
>               if (zm .lt. pblh(i)) then
319,320c358,359
<                 zh = zmzp/pblh(iq)
<                 zl = zmzp/obklen(iq)
---
>                 zh = zmzp/pblh(i)
>                 zl = zmzp/obklen(i)
327,328c366
<                 if(heatv(iq).gt.0.)then  ! unstable case
<                   fak2   = wm(iq)*pblh(iq)*vk
---
>                 if (unstbl(i)) then
334c372
<                     pblk = fak1*zh*zzh*term
---
>                     pblk = fak1(i)*zh*zzh*term
339,344c377,381
<                     pblk = fak2*zh*zzh
<                     fak3 = fakn*wstr(iq)/wm(iq)
<                     cgs     = fak3/(pblh(iq)*wm(iq))
<                     cgh(iq,k) = rkhfs(iq)*cgs                 !eq. (4.d.17)
<                     cgq(iq,k) = rkqfs(iq)*cgs                 !eq. (4.d.17)
<                     pr = phiminv(iq)/phihinv(iq) + ccon*fak3/fak
---
>                     pblk = fak2(i)*zh*zzh
>                     cgs     = fak3(i)/(pblh(i)*wm(i))
>                     cgh(iq,k) = khfs(i)*cgs                 !eq. (4.d.17)
>                     cgq(iq,k) = kqfs(i)*cgs                 !eq. (4.d.17)
>                     pr = phiminv(i)/phihinv(i) + ccon*fak3(i)/fak
348c385
<                 else      ! following are stable or neutral
---
>                 else      ! unstbl(i)
352c389,391
<                   pblk = fak1*zh*zzh/(betas + zl)
---
> 
>                   rkmin = vk*ustar(iq)*zmzp*zzh
>                   pblk = fak1(i)*zh*zzh/(betas + zl)
354,366c393,395
<                     pblk = fak1*zh*zzh/(1. + betas*zl)
<                   endif
<                   if(nrkmin.eq.1)rkmin=rkh(iq,k)
<                   if(nrkmin.eq.2)rkmin=vk*ustar(iq)*zmzp*zzh
< 		    if(ntest.eq.1)then
< 		      if(iq.eq.idjd)then
< 		        print *,'in pbldif k,ustar,zmzp,zh,zl,zzh ',
<      .                                   k,ustar(iq),zmzp,zh,zl,zzh
< 		        print *,'rkh_L,rkmin,pblk,fak1,pblh ',
<      .                         rkh(iq,k),rkmin,pblk,fak1,pblh(iq)
< 		      endif  ! (iq.eq.idjd)
< 		    endif    ! (ntest.eq.1)
<                   rkm(iq,k) = max(pblk,rkmin)        
---
>                     pblk = fak1(i)*zh*zzh/(1. + betas*zl)
>                   end if
>                   rkm(iq,k) = max(pblk,rkmin)         !rkh(iq,k))
368,372c397,401
<                 endif      ! unstbl(i)
<              endif         ! zm(i) .lt. pblh(iq)
<            enddo           ! iq=1,ifull
< 
< 1000     continue           !end of k loop
---
>                 end if       !unstbl(i)
>              end if       !zm(i) .lt. pblh(i)
>            end do      ! i=1,il
> C
> 1000     continue      !end of k loop
373a403
> 2000  continue           ! end of level j loop
386c416
<             qg(iq,k) = qg(iq,k) + tmp1*
---
>             qg(iq,k) = qmx(iq,k) + tmp1*
399c429
<          qg(iq,k) = qg(iq,k) + tmp1*
---
>          qg(iq,k) = qmx(iq,k) + tmp1*
417a448,468
> c      do j=2,jl
> c         do i=2,il
> c	    iq=i+(j-1)*il
> c            do k=1,kl
> c              if(qg(iq,k).lt.qgmin) then
> c                print*,'qg<0 for iq,k,ktau= ',iq,k,ktau
> c                print *,'qg ',(qg(iq,kk),kk=1,kl)
> c                print *,'t ',(t(iq,kk),kk=1,kl)
> c                print *,'theta ',(theta(iq,kk),kk=1,kl)
> c                print *,'u ',(u(iq,kk),kk=1,kl)
> c                print *,'v ',(v(iq,kk),kk=1,kl)
> c                do kk=1,kl
> c                  qg(iq,k)=qmx(iq,k)
> c                enddo   ! kk loop
> c                goto 300
> c              endif
> c            enddo       ! k loop
> c300         continue
> c         enddo          ! i loop
> c      enddo             ! j loop
> 
419c470,472
<        qg=max(qg,qgmin)   ! 3D guided by McCormick et al 1993
---
>       do kq=1,ijk
>        qg(kq,1)=max(qg(kq,1),qgmin)  ! guided by McCormick et al 1993
>       enddo
=====================================
 
plotg.f
=====================================
=====================================
 
printa.f
=====================================
2c2
< c     printa has automatic choice of fact if facti=0.
---
> c     printb has printj entry, and automatic choice of fact if facti=0.
5c5
<       dimension a(il,jl),col(il+jl)
---
>       dimension a(il,jl,kl),col(il+jl)
7c7
<       if(facti.eq.0.)fact=10./abs(a((i1+i2)/2,(j1+j2)/2))
---
>       if(facti.eq.0.)fact=10./abs(a((i1+i2)/2,(j1+j2)/2,1))
10c10
<      . '  has been mult by',1pe8.1)
---
>      1 '  has been mult by',1pe8.1)
15,21c15,19
<       do i=i1,i2
<        do j=ja,jb
<         col(j)=(a(i,j)-bias)*fact
<        enddo
<        print 92,i,(col(j),j=ja,jb)
< 92     format(i5,25f6.2)
<       enddo
---
>       do 28 i=i1,i2
>       do 25 j=ja,jb
> 25    col(j)=(a(i,j,1)-bias)*fact
> 28    print 92,i,(col(j),j=ja,jb)
> 92    format(i5,25f6.2)
24a23,41
> 
> c     following entry prints j cross section in standard orientation
>       entry printj(name,a,ktau,jrow,i1,i2,j1,j2,k1,k2,bias,facti)
>       fact=facti
>       if(facti.eq.0.)fact=10./abs(a((i1+i2)/2,(j1+j2)/2,(k1+k2)/2))
>       print 93 ,name,ktau,jrow,bias,fact
> 93    format(/1x,a4,' ktau =',i7,'  for j =',i3,'  addon =',g8.2,
>      1 '  has been mult by',1pe8.1)
>       ia=i1
> 32    ib=min(ia+24,i2)
>       print 91,(i,i=ia,ib)
>       do 38 k=k2,k1,-1
>       do 35 i=ia,ib
> 35    col(i)=(a(i,jrow,k)-bias)*fact
> 38    print 92,k,(col(i),i=ia,ib)
>       if(ib.eq.i2)return
>       ia=ib+1
>       go to 32
> 
=====================================
 
radriv90.f
=====================================
22,32c22,30
<       include 'aalat.h'    ! alat, along
<       include 'arrays.h'      
<       include 'const_phys.h' ! for ldr cloud scheme
<       include 'cparams.h'    ! for ldr cloud scheme
<       include 'dates.h'      ! timer,kdate,ktime,dt,mtimer
<       include 'extraout.h'   ! sintsave, etc
<       include 'kuocom.h'     ! also with kbsav,ktsav
<       include 'latlong.h'    ! rlatt,rlongg
<       include 'liqwpar.h'    ! ifullw
<       include 'map.h'        ! land
<       include 'nsibd.h'      ! rsmin,ivegt,sigmf,tgf,ssdn,res,rmc,tsigmf
---
>       include 'aalat.h'    ! alat, along, slwa, rtt
>       include 'arrays.h'
>       include 'comhtg.h'   ! for compare3 or heating diagnostics
>       include 'dates.h'    ! timer,kdate,ktime,dt,mtimer
>       include 'extraout.h' ! sintsave, etc
>       include 'kuocom.h'   ! also with kbsav,ktsav
>       include 'latlong.h'  ! rlatt,rlongg
>       include 'map.h'      ! land
>       include 'nsibd.h'    ! rsmin,ivegt,sigmf,tgf,ssdn,res,rmc,tsigmf
51d48
<       common/work3d/rtt(ifull,kl) ! just to pass between radriv90 & globpe
54,56c51,52
<      &               rgn_ave (ifull), rgc_ave (ifull), cld_ave (ifull), 
<      &               cll_ave (ifull), clm_ave (ifull), clh_ave (ifull), 
<      &               koundiag
---
>      &               rgn_ave (ifull), cld_ave (ifull), cll_ave (ifull),
>      &               clm_ave (ifull), clh_ave (ifull), koundiag
57a54
>       parameter(stefbo=5.67e-8)
76,83c73,76
<       
< c     Following are for cloud2 routine
<       common/work3f/cfrac(ifull,kl),           ! globpe,leoncld,radriv90
<      &     t2(imax,kl),ql2(imax,kl),qf2(imax,kl),cf2(imax,kl),
<      &     qccon(imax,kl),cd2(imax,kl),p2(imax,kl),
<      &     dp2(imax,kl),cll(imax),clm(imax),clh(imax)
<      &     ,dum3f(2*ifull*kl-8*imax*kl-3*imax)
<       logical land2(imax)
---
> 
> !liq      real qlg(il,kl), qfg(il,kl) !Cloud liq water and cloud ice
> !liq      real clcon(il,kl) !Conv cloud amount
> !liq      real qccon(il,kl) !Conv cloud water mixing ratio
114a108
> c
371,384c365,375
< c           if( sice(iq) )then
< c!            surface albedo for sea ice points
< c             if(tss(iq).gt.273.1)then
< c               cuvrf(i,1)=.55  ! Mark 3 style
< c             else
< c               cuvrf(i,1)=.65  ! Mark 3 style
< c             endif
< c           else           ! over the ocean
< c             cuvrf(i,1) = 0.05/(coszro(i)+0.15)
< c           endif          ! if( sice(iq) )
< !          following for CCAM from 11/6/03
<            cuvrf(i,1)=.65*fracice(iq)+
<      .                (1.-fracice(iq))*.05/(coszro(i)+0.15)
<         endif       ! if( land(iq)) .. else..
---
>            if( sice(iq) )then
> !            surface albedo for sea ice points
>              if(tss(iq).gt.273.1)then
>                cuvrf(i,1)=.55  ! Mark 3 style
>              else
>                cuvrf(i,1)=.65  ! Mark 3 style
>              endif
>            else           ! over the ocean
>              cuvrf(i,1) = 0.05/(coszro(i)+0.15)
>            endif          ! if( sice(iq) )
>          endif            ! if( land(iq)) .. else..
436,457d426
<       
<       if(ifullw.eq.ifull)then  
< c       Stuff needed for cloud2 routine...    
<         qccon(:,:)=0.
<         do k=1,kl   
<           do i=1,imax
<             iq=i+(j-1)*il
<             t2(i,k)=t(iq,k)
<             ql2(i,k)=qlg(iq,k)
<             qf2(i,k)=qfg(iq,k)
<             cf2(i,k)=cfrac(iq,k)
<             if(land(iq))then
<               cd2(i,k)=cdropl
<             else
<               cd2(i,k)=cdrops
<             endif
<             land2(i)=land(iq)
<             p2(i,k)=0.01*ps(iq)*sig(k) !Looks like ps is SI units
<             dp2(i,k)=-0.01*ps(iq)*dsig(k) !dsig is -ve
<           enddo
<         enddo
<       endif  ! (ifullw.eq.ifull)
463,470c432
<         if(ifullw.eq.ifull)then  !Call LDR cloud scheme
< c         write(24,*)coszro2
<           call cloud2(cldoff,1,t2,ql2,qf2,cf2,qccon,
<      &                cd2,land2,sigh,p2,dp2,coszro,      !Inputs
<      &                cll,clm,clh)                       !Outputs
<         else
<           call cloud(cldoff,sig,j) ! jlm
<         endif  ! (ifullw.eq.ifull)
---
>         call cloud(cldoff,sig,j)  ! jlm
485c447
< c     Cloudy sky calculation
---
> c  Cloudy sky calculation
487,501c449
<       if(ifullw.eq.ifull)then  !Call LDR cloud scheme
< c       write(24,*)
< c       write(24,*)coszro2
<         call cloud2(cldoff,1,t2,ql2,qf2,cf2,qccon,
<      &              cd2,land2,sigh,p2,dp2,coszro,      !Inputs
<      &              cll,clm,clh)                       !Outputs
<         do i=1,imax
<           iq=i+(j-1)*il
<           cloudlo(iq)=cll(i)
<           cloudmi(iq)=clm(i)
<           cloudhi(iq)=clh(i)
<         enddo
<       else
<         call cloud(cldoff,sig,j) ! jlm
<       endif  ! (ifullw.eq.ifull)
---
>       call cloud(cldoff,sig,j)  ! jlm
565d512
<       fractss=.05
573c520
< !###     hlwsav(iq,1) = hlwsav(iq,1)-fractss*xxx  ! removed 18/6/03
---
>          hlwsav(iq,1) = hlwsav(iq,1)-xxx
598d544
<          rgc_ave(iq)  = rgc_ave(iq)  + rgclr(i)
637c583
<       do k=1,kl
---
>       do k=2,kl
641a588,594
> c            if ( ncomp.gt.0 ) then
> c!              Note sign flips for the diagnostics dtlw, dtsw.
> c               dtlw(i,j,k) = dtlw(i,j,k) - hlwsav(iq,k) /
> c     &                                     (cong*ps(iq)*dsig(k))
> c               dtsw(i,j,k) = dtsw(i,j,k) - hswsav(iq,k) /
> c     &                                     (cong*ps(iq)*dsig(k))
> c            endif
644,649c597,608
< !     k = 1  ! these 6 lines removed 18/6/03
< !     do i=1,imax
< !      iq=i+(j-1)*il
< !      rtt(iq,k)=(hswsav(iq,k)+hlwsav(iq,k)+fractss*stefbo*tss(iq)**4)/
< !    &           (cong*ps(iq)*dsig(k))
< !     end do
---
>       k = 1
>       do i=1,imax
> 	iq=i+(j-1)*il
>        rtt(iq,k)=(hswsav(iq,k)+hlwsav(iq,k)+stefbo*tss(iq)**4)/
>      &               (cong*ps(iq)*dsig(k))
> c       if ( ncomp.gt.0 ) then
> c         dtlw(i,j,k) = dtlw(i,j,k) -
> c     &      (hlwsav(i,j,k)+stefbo*tss(iq)**4)/(cong*ps(iq)*dsig(k))
> c         dtsw(i,j,k) = dtsw(i,j,k) - hswsav(i,j,k) /
> c     &                  (cong*ps(iq)*dsig(k))
> c       endif
>       end do
=====================================
 
rdparm.f
=====================================
1c1,4
< c $Log$
< c Revision 1.1  2003/08/13 01:24:20  dix043
< c Initial revision
< c
---
> c $Log$
> c Revision 1.1  2003/08/13 01:24:20  dix043
> c Initial revision
> c
> c Revision 1.1.1.1  2002/12/18 23:02:17  dix043
> c Source imported from farrer:~cslm/ccam
> c
=====================================
 
read_ht.f
=====================================
=====================================
 
resetd.f
=====================================
=====================================
 
retopo.f
=====================================
9,10c9,10
<       real psl(ifull),zsold(ifull),zs(ifull)
<       real qg(ifull,kl),t(ifull,kl)
---
>       real psl(il,jl),zsold(il,jl),zs(il,jl)
>       real qg(il,jl,kl),t(il,jl,kl)
12c12,13
<       common/work2/dum(ifull),ps(ifull),psold(ifull),dum2(ifull,15)
---
>       common/work2/dum(il,jl),ps(il,jl),psold(il,jl),dum2(il,jl,14),
>      .             zsgcm(il,jl)   ! for newtop=12 option
16,18c17,19
<        psold(iq)=1.e5*exp(psl(iq))
<        psl(iq)=psl(iq)+(zsold(iq)-zs(iq))/(r*t(iq,1))
<        ps(iq)=1.e5*exp(psl(iq))
---
>        psold(iq,1)=1.e5*exp(psl(iq,1))
>        psl(iq,1)=psl(iq,1)+(zsold(iq,1)-zs(iq,1))/(r*t(iq,1,1))
>        ps(iq,1)=1.e5*exp(psl(iq,1))
20a22,24
> c     print *,'psl ',(psl(ii,ii),ii=1,il)
> c     print *,'ps ',(ps(ii,ii),ii=1,il)
> c     print *,'psold ',(psold(ii,ii),ii=1,il)
22,23c26,27
<         print *,'entering retopo, old t ',(t(idjd,k),k=1,kl)
<         print *,'entering retopo, old qg ',(qg(idjd,k),k=1,kl)
---
>         print *,'entering retopo, old t ',(t(id,jd,k),k=1,kl)
>         print *,'entering retopo, old qg ',(qg(id,jd,k),k=1,kl)
25c29
<      .           zsold(idjd),zs(idjd),psold(idjd),ps(idjd)
---
>      .           zsold(id,jd),zs(id,jd),psold(id,jd),ps(id,jd)
27,47c31,53
<       do iq=1,ifull
<        do k=1,kl
<         qgold(k)=qg(iq,k)
<         told(k)=t(iq,k)
<        enddo  ! k loop
<        do k=1,kl-1
<         sig2=sig(k)*ps(iq)/psold(iq)
<         if(sig2.ge.sig(1))then
< c         assume 6.5 deg/km, with dsig=.1 corresponding to 1 km
<           t(iq,k)=told(1)+(sig2-sig(1))*6.5/.1  
<         else
<           do kkk=2,kl
<            if(sig2.gt.sig(kkk))go to 526
<           enddo
< 526       t(iq,k)=(told(kkk)*(sig(kkk-1)-sig2)+told(kkk-1)*
<      .             (sig2-sig(kkk)))/(sig(kkk-1)-sig(kkk))
<           qg(iq,k)=(qgold(kkk)*(sig(kkk-1)-sig2)
<      .              +qgold(kkk-1)*(sig2-sig(kkk)))/(sig(kkk-1)-sig(kkk))
<         endif
<        enddo  ! k loop
<       enddo   ! iq loop
---
>       do 53 j=1,jl
>       do 53 i=1,il
>       do k=1,kl
>        qgold(k)=qg(i,j,k)
>        told(k)=t(i,j,k)
>       enddo  ! k loop
> c     if(i.eq.id.and.j.eq.jd)print *,id,jd,'told ',id,jd,told
>       do 53 k=1,kl-1
>       sig2=sig(k)*ps(i,j)/psold(i,j)
>       if(sig2.ge.sig(1))then
> c       assume 6.5 deg/km, with dsig=.1 corresponding to 1 km
>         t(i,j,k)=told(1)+(sig2-sig(1))*6.5/.1  ! fixed up Tue  11-28-1995
> c       t(i,j,k)=t(i,j,k)+(zsold(i,j)-zs(i,j))*.0065/g ! old code
>       else
>         do kkk=2,kl
>          if(sig2.gt.sig(kkk))go to 526
>         enddo
> 526     t(i,j,k)=(told(kkk)*(sig(kkk-1)-sig2)+told(kkk-1)*
>      .           (sig2-sig(kkk)))/(sig(kkk-1)-sig(kkk))
>         qg(i,j,k)=(qgold(kkk)*(sig(kkk-1)-sig2)
>      .            +qgold(kkk-1)*(sig2-sig(kkk)))/(sig(kkk-1)-sig(kkk))
>       endif
> 53    continue
49,50c55,56
<         print *,'retopo new t ',(t(idjd,k),k=1,kl)
<         print *,'retopo new qg ',(qg(idjd,k),k=1,kl)
---
>         print *,'retopo new t ',(t(id,jd,k),k=1,kl)
>         print *,'retopo new qg ',(qg(id,jd,k),k=1,kl)
=====================================
 
rnddta.f
=====================================
1c1,4
< c $Log$
< c Revision 1.1  2003/08/13 01:24:20  dix043
< c Initial revision
< c
---
> c $Log$
> c Revision 1.1  2003/08/13 01:24:20  dix043
> c Initial revision
> c
> c Revision 1.1.1.1  2002/12/18 23:02:17  dix043
> c Source imported from farrer:~cslm/ccam
> c
=====================================
 
scamrdn.f
=====================================
=====================================
 
scrnout.f
=====================================
1,2c1,2
<       subroutine scrnout(zo,ustar,fg,eg,factch,qsurf,wetfac,qsttg,  ! arrays
<      .     qgscrn,tscrn,uscrn,u10,scrrel,                           ! arrays
---
>       subroutine scrnout(zo,ustar,fg,eg,factch,qsurf,wetfac,rsts,   ! arrays
>      .     qgscrn,tscrn,uscrn,u3,u10,scrrel,                        ! arrays
23c23
<      . dum3(2*ijk-15*ifull),uav(ifull,kl),vav(ifull,kl),spare(ifull,kl)   
---
>      . dum3(2*ijk-15*ifull),uav(ifull,kl),vav(ifull,kl)   
25,28c25,28
<      .          aft(ifull),aft10(ifull),zlog(ifull),
<      .          af(ifull),af10(ifull),deltheta(ifull),
<      .          afroot(ifull),afroot10(ifull),
<      . dum3b(2*ijk-11*ifull-2*ms*ifull)
---
>      .          aft(ifull),aft3(ifull),aft10(ifull),zlog(ifull),
>      .          af(ifull),af3(ifull),af10(ifull),deltheta(ifull),
>      .          afroot(ifull),afroot3(ifull),afroot10(ifull),
>      . dum3b(2*ijk-14*ifull-2*ms*ifull)
31,32c31,32
<      . ,uscrn(ifull),u10(ifull),scrrel(ifull)
<       real wetfac(ifull),factch(ifull),qsttg(ifull),ustar(ifull)
---
>      . ,uscrn(ifull),u3(ifull),u10(ifull),scrrel(ifull)
>       real wetfac(ifull),factch(ifull),rsts(ifull),ustar(ifull)
53,54c53,54
< c     z3onzt=3.*ztv
< c     chn3=(vkar/log(z3onzt))**2
---
>       z3onzt=3.*ztv
>       chn3=(vkar/log(z3onzt))**2
58,59c58,59
<       if(ntest.eq.1)print *,'scrnout wetfac qsttg ',
<      .                               wetfac(idjd),qsttg(idjd)
---
>       if(ntest.eq.1)print *,'scrnout wetfac rsts ',
>      .                               wetfac(idjd),rsts(idjd)
61,62c61
< !     N.B. qsttg is coming in as before-calling-sib3 value of qs_tss
<       if(nalpha.eq.1) then  ! usual
---
>       if(nalpha.eq.1) then
64,65c63,64
<          qsurf(iq) = wetfac(iq)*qsttg(iq)
<      .      + (1.-wetfac(iq))*min(qg(iq,1),qsttg(iq))  ! for v. cold surfaces
---
>          qsurf(iq) = wetfac(iq)*rsts(iq)
>      .                 + (1.-wetfac(iq))*qg(iq,1)
69c68
<          qtgnet=qsttg(iq)*wetfac(iq) -qg(iq,1)
---
>          qtgnet=rsts(iq)*wetfac(iq) -qg(iq,1)
71c70
<            qsurf(iq) = qsttg(iq)*wetfac(iq)
---
>            qsurf(iq) = rsts(iq)*wetfac(iq)
73c72
<            qsurf(iq) = .1*qsttg(iq)*wetfac(iq) + .9*qg(iq,1)
---
>            qsurf(iq) = .1*rsts(iq)*wetfac(iq) + .9*qg(iq,1)
85,86c84,85
< c      afroot3(iq) = vkar/(log(3.)-zlog(iq))
< c      af3(iq) = afroot3(iq)*afroot3(iq)
---
>        afroot3(iq) = vkar/(log(3.)-zlog(iq))
>        af3(iq) = afroot3(iq)*afroot3(iq)
96c95
< c      aft3(iq)=vkar* afroot3(iq) /(2. + log(3.)-zlog(iq))
---
>        aft3(iq)=vkar* afroot3(iq) /(2. + log(3.)-zlog(iq))
104c103
< c      aft3(iq)=chn3
---
>        aft3(iq)=chn3
120a120,121
>         if(ntest.ne.0.and.iq.eq.idjd)print *,'iq,tss,qsurf,wetfac '
>      .      ,iq,tss(iq),qsurf(iq),wetfac(iq)
131,133c132,134
< c       c3 = -9.806*tstarx*3.*af3(iq)*sqrt(af3(iq))
< c    .        /(aft3(iq)*tss(iq)*ustar(iq)**2)
<         c10= -9.806*tstarx*10.*af10(iq)*sqrt(af10(iq)) ! fixed 1/5/03
---
>         c3 = -9.806*tstarx*3.*af3(iq)*sqrt(af3(iq))
>      .        /(aft3(iq)*tss(iq)*ustar(iq)**2)
>         c10= -9.806*tstarx*10.*af3(iq)*sqrt(af10(iq))
148c149
< c         rich3  = ( -1. + sqrt(1.-4.*bprm*c3) ) /(2.*bprm)
---
>           rich3  = ( -1. + sqrt(1.-4.*bprm*c3) ) /(2.*bprm)
153c154
< c         fm3  = max(fmroot*fmroot,1./(1.+bprm*rich3 )**2)
---
>           fm3  = max(fmroot*fmroot,1./(1.+bprm*rich3 )**2)
184,193c185,194
< cc         iterations for 3 m winds
< c          y3 = sqrt(c3)
< c          root=sqrt(3./zo(iq))
< c          cm3=2.*bprm*cms*af3(iq)*root
< c          ch3=2.*bprm*chs*aft3(iq)*factch(iq)*root
< c          fm3=1.+2.*bprm*y3*y3/(1.+cm3*y3)
< c          fh3=1.+2.*bprm*y3*y3/(1.+ch3*y3)
< cc         y3 = sqrt(c3) * fm3**0.75 / sqrt(fh3)
< c          y3 = sqrt(c3 *sqrt(fm3*fm3*fm3)/fh3)  ! jlm Fri  05-05-1995
< c          fm3=1.+2.*bprm*y3*y3/(1.+cm3*y3)
---
> c         iterations for 3 m winds
>           y3 = sqrt(c3)
>           root=sqrt(3./zo(iq))
>           cm3=2.*bprm*cms*af3(iq)*root
>           ch3=2.*bprm*chs*aft3(iq)*factch(iq)*root
>           fm3=1.+2.*bprm*y3*y3/(1.+cm3*y3)
>           fh3=1.+2.*bprm*y3*y3/(1.+ch3*y3)
> c         y3 = sqrt(c3) * fm3**0.75 / sqrt(fh3)
>           y3 = sqrt(c3 *sqrt(fm3*fm3*fm3)/fh3)  ! jlm Fri  05-05-1995
>           fm3=1.+2.*bprm*y3*y3/(1.+cm3*y3)
214c215
< c       u3(iq) = ustar(iq)/(afroot3(iq)*sqrt(fm3))
---
>         u3(iq) = ustar(iq)/(afroot3(iq)*sqrt(fm3))
228c229
<           print *,'nalpha,fh,fm,fm10 ',nalpha,fh,fm,fm10
---
>           print *,'nalpha,fh,fm,fm3,fm10 ',nalpha,fh,fm,fm3,fm10
243,244c244,254
<        qs= 0.622*es/constz
<        scrrel(iq) = max(0.,100.*(qgscrn(iq)/qs))
---
>        rsts(iq)= 0.622*es/constz
>        scrrel(iq) = max(0.,100.*(qgscrn(iq)/rsts(iq)))
>        if(ntest.ne.0.and.iq.eq.idjd)then
>           print *,'wetfac,rsts,qg(iq,1) ',
>      .             wetfac(iq),rsts(iq),qg(iq,1)
>           print *,'tscrn,uscrn,u3,u10 ',
>      .             tscrn(iq),uscrn(iq),u3(iq),u10(iq)
>           print *,'deltheta,uscrn,qsurf(iq) ',
>      .             deltheta(iq),uscrn(iq),qsurf(iq)
>           print *,'qgscrn,scrrel ',qgscrn(iq),scrrel(iq)
>        endif
261,273d270
<       if(ntest.ne.0.or.diag)then
<         iq=idjd
<         es = establ(tscrn(iq))
<         constz=ps(iq)-es
<         qs= 0.622*es/constz
<         print *,'wetfac,qsttg,qg1 ',
<      .           wetfac(iq),qsttg(iq),qg(iq,1)
<           print *,'tss,tscrn,uscrn,u10 ',
<      .             tss(iq),tscrn(iq),uscrn(iq),u10(iq)
<           print *,'deltheta,qs,qsurf(iq) ',
<      .             deltheta(iq),qs,qsurf(iq)
<           print *,'qgscrn,scrrel ',qgscrn(iq),scrrel(iq)
<        endif
278c275
<        tscrn(iq) = tgg(iq,2) + deltheta(iq)  ! tgg(iq,2) is skin temperature
---
>        tscrn(iq) = tgg(iq,2) + deltheta(iq)
281,282c278,279
<        qsttg(iq)= 0.622*es/constz
<        scrrel(iq) = max(0.,100.*(qgscrn(iq)/qsttg(iq)))
---
>        rsts(iq)= 0.622*es/constz
>        scrrel(iq) = max(0.,100.*(qgscrn(iq)/rsts(iq)))
284,287c281,284
<           print *,'wetfac,qsttg,qg(iq,1) ',
<      .             wetfac(iq),qsttg(iq),qg(iq,1)
<           print *,'tscrn,uscrn,u10 ',
<      .             tscrn(iq),uscrn(iq),u10(iq)
---
>           print *,'wetfac,rsts,qg(iq,1) ',
>      .             wetfac(iq),rsts(iq),qg(iq,1)
>           print *,'tscrn,uscrn,u3,u10 ',
>      .             tscrn(iq),uscrn(iq),u3(iq),u10(iq)
=====================================
 
setxyz.f
=====================================
27c27
<       common/work3b/rlong4(ifull,4),rlat4(ifull,4),dum3d(2*ijk-8*ifull) 
---
>       common/work3d/rlong4(ifull,4),rlat4(ifull,4),dum3d(ijk-8*ifull) 
32,33c32,33
<      .  ,inw(ifull),ies(ifull),iws(ifull)  ! just for bdys
<      .  ,dum3(5*ijk -4*(iquad)*(iquad)-9*ifull) 
---
>      .  ,inw(ifull),isw(ifull),ies(ifull),iws(ifull)  ! just for bdys
>      .  ,dum3(4*ijk -4*(iquad)*(iquad)-10*ifull) 
305,306c305
<        call jimcc
< 	if(ktau.eq.0)then
---
>         call jimcc
313d311
< 	endif  ! (ktau.eq.0)
376c374
< c         if(i.eq.(il+1)/2.and.j.eq.(il+1)/2)print *,'n,xx,yy: ',n,xx,yy
---
>           if(i.eq.(il+1)/2.and.j.eq.(il+1)/2)print *,'n,xx,yy: ',n,xx,yy
417,418c415,416
< c      if(iq.eq.idjd)print *,'iq,x4,y4,z4,xx,yy,zz,long4,lat4 ',
< c    .  iq,x4_iq_m,y4_iq_m,z4_iq_m,xx,yy,zz,rlong4(iq,m),rlat4(iq,m)
---
>        if(iq.eq.idjd)print *,'iq,x4,y4,z4,xx,yy,zz,long4,lat4 ',
>      .  iq,x4_iq_m,y4_iq_m,z4_iq_m,xx,yy,zz,rlong4(iq,m),rlat4(iq,m)
476c474
< c         if(i.eq.(il+1)/2.and.j.eq.(il+1)/2)print *,'xx,yy: ',xx,yy
---
>           if(i.eq.(il+1)/2.and.j.eq.(il+1)/2)print *,'xx,yy: ',xx,yy
479,483c477,479
< 	 if(ktau.eq.0)then
<           print *,'ax6 (1,1,0) & (2,2,0) ',ax6(1,1,0),ax6(2,2,0)
<           print *,'ay6 (1,1,0) & (2,2,0) ',ay6(1,1,0),ay6(2,2,0)
<           print *,'az6 (1,1,0) & (2,2,0) ',az6(1,1,0),az6(2,2,0)
< 	 endif ! (ktau.eq.0)
---
>         print *,'ax6 (1,1,0) & (2,2,0) ',ax6(1,1,0),ax6(2,2,0)
>         print *,'ay6 (1,1,0) & (2,2,0) ',ay6(1,1,0),ay6(2,2,0)
>         print *,'az6 (1,1,0) & (2,2,0) ',az6(1,1,0),az6(2,2,0)
548a545,557
> c                      nn=2
> c                      print *,'x for panel ',nn
> c                      do j=il,1,-1
> c                       print '(i3,30f6.3)',j,(x6(i,j,nn),i=1,il)
> c                      enddo
> c                      print *,'y for panel ',nn
> c                      do j=il,1,-1
> c                       print '(i3,30f6.3)',j,(y6(i,j,nn),i=1,il)
> c                      enddo
> c                      print *,'z for panel ',nn
> c                      do j=il,1,-1
> c                       print '(i3,30f6.3)',j,(z6(i,j,nn),i=1,il)
> c                      enddo
601c610
<       if(ktau.eq.0)print *,'basic grid length ds =',ds
---
>       print *,'basic grid length ds =',ds
613,620c622,629
< c        do n=0,npanels
< c         iqcc=ind((il+1)/2,(il+1)/2,n)
< c         if(iq.eq.iqcc)then
< c           print *,'After Schmidt at centre of face n:',n
< c           print '('' xin,yin,zin,x,y,z ''3f7.3,2x,3f7.3)',
< c    .                 xin,yin,zin,x(iq),y(iq),z(iq)
< c         endif
< c        enddo  ! n loop
---
>          do n=0,npanels
>           iqcc=ind((il+1)/2,(il+1)/2,n)
>           if(iq.eq.iqcc)then
>             print *,'After Schmidt at centre of face n:',n
>             print '('' xin,yin,zin,x,y,z ''3f7.3,2x,3f7.3)',
>      .                 xin,yin,zin,x(iq),y(iq),z(iq)
>           endif
>          enddo  ! n loop
633,673c642,680
<       if(ktau.eq.0)then
<         print *,'On each panel (ntang=0)_em for ',
<      .          '(1,1),(1,2),(1,3),(2,2),(3,2),(ic,ic),(il,il)'
<         do n=0,npanels
<          iq11=ind(1,1,n)
<          iq12=ind(1,2,n)
<          iq13=ind(1,3,n)
<          iq22=ind(2,2,n)
<          iq32=ind(3,2,n)
<          iqcc=ind((il+1)/2,(il+1)/2,n)
<          iqnn=ind(il,il,n)
<          print '(i3,7f8.3)',n,em(iq11),em(iq12),em(iq13),
<      .                        em(iq22),em(iq32),em(iqcc),em(iqnn)
<         enddo
<         print *,'On each panel (ntang=0)_emu for ',
<      .          '(1,1),(1,2),(1,3),(2,2),(3,2),(ic,ic),(il,il)'
<         do n=0,npanels
<          iq11=ind(1,1,n)
<          iq12=ind(1,2,n)
<          iq13=ind(1,3,n)
<          iq22=ind(2,2,n)
<          iq32=ind(3,2,n)
<          iqcc=ind((il+1)/2,(il+1)/2,n)
<          iqnn=ind(il,il,n)
<          print '(i3,7f8.3)',n,emu(iq11),emu(iq12),emu(iq13),
<      .                        emu(iq22),emu(iq32),emu(iqcc),emu(iqnn)
<         enddo
<         print *,'On each panel (ntang=0)_emv for ',
<      .          '(1,1),(1,2),(1,3),(2,2),(3,2),(ic,ic),(il,il)'
<         do n=0,npanels
<          iq11=ind(1,1,n)
<          iq12=ind(1,2,n)
<          iq13=ind(1,3,n)
<          iq22=ind(2,2,n)
<          iq32=ind(3,2,n)
<          iqcc=ind((il+1)/2,(il+1)/2,n)
<          iqnn=ind(il,il,n)
<          print '(i3,7f8.3)',n,emv(iq11),emv(iq12),emv(iq13),
<      .                        emv(iq22),emv(iq32),emv(iqcc),emv(iqnn)
<         enddo
<       endif  ! (ktau.eq.0)
---
>       print *,'On each panel (ntang=0)_em for ',
>      .        '(1,1),(1,2),(1,3),(2,2),(3,2),(ic,ic),(il,il)'
>       do n=0,npanels
>        iq11=ind(1,1,n)
>        iq12=ind(1,2,n)
>        iq13=ind(1,3,n)
>        iq22=ind(2,2,n)
>        iq32=ind(3,2,n)
>        iqcc=ind((il+1)/2,(il+1)/2,n)
>        iqnn=ind(il,il,n)
>        print '(i3,7f8.3)',n,em(iq11),em(iq12),em(iq13),
>      .                  em(iq22),em(iq32),em(iqcc),em(iqnn)
>       enddo
>       print *,'On each panel (ntang=0)_emu for ',
>      .        '(1,1),(1,2),(1,3),(2,2),(3,2),(ic,ic),(il,il)'
>       do n=0,npanels
>        iq11=ind(1,1,n)
>        iq12=ind(1,2,n)
>        iq13=ind(1,3,n)
>        iq22=ind(2,2,n)
>        iq32=ind(3,2,n)
>        iqcc=ind((il+1)/2,(il+1)/2,n)
>        iqnn=ind(il,il,n)
>        print '(i3,7f8.3)',n,emu(iq11),emu(iq12),emu(iq13),
>      .                  emu(iq22),emu(iq32),emu(iqcc),emu(iqnn)
>       enddo
>       print *,'On each panel (ntang=0)_emv for ',
>      .        '(1,1),(1,2),(1,3),(2,2),(3,2),(ic,ic),(il,il)'
>       do n=0,npanels
>        iq11=ind(1,1,n)
>        iq12=ind(1,2,n)
>        iq13=ind(1,3,n)
>        iq22=ind(2,2,n)
>        iq32=ind(3,2,n)
>        iqcc=ind((il+1)/2,(il+1)/2,n)
>        iqnn=ind(il,il,n)
>        print '(i3,7f8.3)',n,emv(iq11),emv(iq12),emv(iq13),
>      .                  emv(iq22),emv(iq32),emv(iqcc),emv(iqnn)
>       enddo
689,698c696,705
< c         if(iq.eq.idjd.or.iq.eq.in(idjd))then
< c           print *,'first guess values for ax,bx'
< c           print *,'iq,ax,ay,az',iq,ax(iq),ay(iq),az(iq)
< c           print *,'iq,bx,by,bz',iq,bx(iq),by(iq),bz(iq)
< c           print *,'iq,x,y,z   ',iq,x(iq),y(iq),z(iq)
< c           print *,'iq,x,y,z n ',iq,x(in(iq)),y(in(iq)),z(in(iq))
< c           print *,'iq,x,y,z e ',iq,x(ie(iq)),y(ie(iq)),z(ie(iq))
< c           print *,'iq,x,y,z w ',iq,x(iw(iq)),y(iw(iq)),z(iw(iq))
< c           print *,'iq,x,y,z s ',iq,x(is(iq)),y(is(iq)),z(is(iq))
< c         endif
---
>          if(iq.eq.idjd.or.iq.eq.in(idjd))then
>            print *,'first guess values for ax,bx'
>            print *,'iq,ax,ay,az',iq,ax(iq),ay(iq),az(iq)
>            print *,'iq,bx,by,bz',iq,bx(iq),by(iq),bz(iq)
>            print *,'iq,x,y,z   ',iq,x(iq),y(iq),z(iq)
>            print *,'iq,x,y,z n ',iq,x(in(iq)),y(in(iq)),z(in(iq))
>            print *,'iq,x,y,z e ',iq,x(ie(iq)),y(ie(iq)),z(ie(iq))
>            print *,'iq,x,y,z w ',iq,x(iw(iq)),y(iw(iq)),z(iw(iq))
>            print *,'iq,x,y,z s ',iq,x(is(iq)),y(is(iq)),z(is(iq))
>          endif
703a711,714
> c        if(iq.gt.0)print *,'b iq,axx,ayy,azz'
> c    .                        ,iq,axx(iq),ayy(iq),azz(iq)
> c        if(iq.gt.0)print *,'b iq,bxx,byy,bzz'
> c    .                        ,iq,bxx(iq),byy(iq),bzz(iq)
705a717,720
> c        if(iq.gt.0)print *,'c iq,axx,ayy,azz'
> c    .                        ,iq,axx(iq),ayy(iq),azz(iq)
> c        if(iq.gt.0)print *,'c iq,bxx,byy,bzz'
> c    .                        ,iq,bxx(iq),byy(iq),bzz(iq)
714a730,732
> c        if(iq.gt.0)print *,'dot,eps',dot,eps
> c        if(iq.gt.0)print *,'d iq,ax,ay,az',iq,ax(iq),ay(iq),az(iq)
> c        if(iq.gt.0)print *,'d iq,bx,by,bz',iq,bx(iq),by(iq),bz(iq)
742,766c760,781
<       
<       if(ktau.eq.0)then
<         do iq=il-2,il
<          print *,'iq,em,emu,emv',iq,em(iq),emu(iq),emv(iq)
<         enddo   ! iq loop
<         if(id.le.il.and.jd.le.jl)then
<           iq=id+il*(jd-1)
<           print *,'values at idjd'
<           print *,'iq,ax,ay,az',iq,ax(iq),ay(iq),az(iq)
<           print *,'iq,bx,by,bz',iq,bx(iq),by(iq),bz(iq)
<           iq=in(id+il*(jd-1))
<           print *,'values at in(idjd)'
<           print *,'iq,ax,ay,az',iq,ax(in(iq)),ay(in(iq)),az(in(iq))
<           print *,'iq,bx,by,bz',iq,bx(in(iq)),by(in(iq)),bz(in(iq))
<           print *,'values at ie(idjd)'
<           print *,'iq,ax,ay,az',iq,ax(ie(iq)),ay(ie(iq)),az(ie(iq))
<           print *,'iq,bx,by,bz',iq,bx(ie(iq)),by(ie(iq)),bz(ie(iq))
<           print *,'values at iw(idjd)'
<           print *,'iq,ax,ay,az',iq,ax(iw(iq)),ay(iw(iq)),az(iw(iq))
<           print *,'iq,bx,by,bz',iq,bx(iw(iq)),by(iw(iq)),bz(iw(iq))
<           print *,'values at is(idjd)'
<           print *,'iq,ax,ay,az',iq,ax(is(iq)),ay(is(iq)),az(is(iq))
<           print *,'iq,bx,by,bz',iq,bx(is(iq)),by(is(iq)),bz(is(iq))
<         endif
<       endif  ! (ktau.eq.0)
---
>       do iq=il-2,il
>        print *,'iq,em,emu,emv',iq,em(iq),emu(iq),emv(iq)
>       enddo   ! iq loop
>       if(id.le.il.and.jd.le.jl)then
>         iq=id+il*(jd-1)
>         print *,'values at idjd'
>         print *,'iq,ax,ay,az',iq,ax(iq),ay(iq),az(iq)
>         print *,'iq,bx,by,bz',iq,bx(iq),by(iq),bz(iq)
>         iq=in(id+il*(jd-1))
>         print *,'values at in(idjd)'
>         print *,'iq,ax,ay,az',iq,ax(in(iq)),ay(in(iq)),az(in(iq))
>         print *,'iq,bx,by,bz',iq,bx(in(iq)),by(in(iq)),bz(in(iq))
>         print *,'values at ie(idjd)'
>         print *,'iq,ax,ay,az',iq,ax(ie(iq)),ay(ie(iq)),az(ie(iq))
>         print *,'iq,bx,by,bz',iq,bx(ie(iq)),by(ie(iq)),bz(ie(iq))
>         print *,'values at iw(idjd)'
>         print *,'iq,ax,ay,az',iq,ax(iw(iq)),ay(iw(iq)),az(iw(iq))
>         print *,'iq,bx,by,bz',iq,bx(iw(iq)),by(iw(iq)),bz(iw(iq))
>         print *,'values at is(idjd)'
>         print *,'iq,ax,ay,az',iq,ax(is(iq)),ay(is(iq)),az(is(iq))
>         print *,'iq,bx,by,bz',iq,bx(is(iq)),by(is(iq)),bz(is(iq))
>       endif
779,782c794
<       if(ktau.eq.0)then
<         print *,'sumwts/ifull ',sumwts/ifull  ! ideally equals 4*pi ??
<         print *,'in setxyz rlong0,rlat0,schmidt ',rlong0,rlat0,schmidt
<       endif  ! (ktau.eq.0)
---
>       print *,'sumwts/ifull ',sumwts/ifull  ! ideally equals 4*pi ??
798a811
> c     print *,'sumwts ',sumwts  ! ideally equals 4*pi/6, 2.09440
799a813
>       print *,'in setxyz rlong0,rlat0,schmidt ',rlong0,rlat0,schmidt
826,828c840,842
< c      if(iq.eq.idjd)print *,'iq,x,y,z,xx,yy,zz,long,lat ',
< c    .  iq,x(iq),y(iq),z(iq),xx,yy,zz,
< c    .  rlongg(iq)*180./pi,rlatt(iq)*180./pi
---
>        if(iq.eq.idjd)print *,'iq,x,y,z,xx,yy,zz,long,lat ',
>      .  iq,x(iq),y(iq),z(iq),xx,yy,zz,
>      .  rlongg(iq)*180./pi,rlatt(iq)*180./pi
838,899c852,911
<       if(ktau.eq.0)then
<         print *,'At centre of the faces:'
<         do n=0,npanels
<          iq=ind((il+1)/2,(il+1)/2,n)
<          print '('' n,iq,x,y,z,long,lat,f ''i3,i5,3f7.3,2f8.2,f9.5)',n,
<      .     iq,x(iq),y(iq),z(iq),
<      .     rlongg(iq)*180./pi,rlatt(iq)*180./pi,f(iq)
<         enddo
<         print *,'At mid-x along edges:'
<         do n=0,npanels
<          iq=ind((il+1)/2,1,n)
<          print '('' n,iq,x,y,z,long,lat,f ''i3,i5,3f7.3,2f8.2,f9.5)',n,
<      .     iq,x(iq),y(iq),z(iq),
<      .     rlongg(iq)*180./pi,rlatt(iq)*180./pi,f(iq)
<         enddo
<         print *,'At mid-y along edges:'
<         do n=0,npanels
<          iq=ind(1,(il+1)/2,n)
<          print '('' n,iq,x,y,z,long,lat,f ''i3,i5,3f7.3,2f8.2,f9.5)',n,
<      .     iq,x(iq),y(iq),z(iq),
<      .     rlongg(iq)*180./pi,rlatt(iq)*180./pi,f(iq)
<         enddo
<         print *,'On each panel final_em for ',
<      .          '(1,1),(1,2),(1,3),(2,2),(3,2),(ic,ic),(il,il)'
<         do n=0,npanels
<          iq11=ind(1,1,n)
<          iq12=ind(1,2,n)
<          iq13=ind(1,3,n)
<          iq22=ind(2,2,n)
<          iq32=ind(3,2,n)
<          iqcc=ind((il+1)/2,(il+1)/2,n)
<          iqnn=ind(il,il,n)
<          print '(i3,7f8.3)',n,em(iq11),em(iq12),em(iq13),
<      .                        em(iq22),em(iq32),em(iqcc),em(iqnn)
<         enddo
<         print *,'On each panel final_emu for ',
<      .          '(1,1),(1,2),(1,3),(2,2),(3,2),(ic,ic),(il,il)'
<         do n=0,npanels
<          iq11=ind(1,1,n)
<          iq12=ind(1,2,n)
<          iq13=ind(1,3,n)
<          iq22=ind(2,2,n)
<          iq32=ind(3,2,n)
<          iqcc=ind((il+1)/2,(il+1)/2,n)
<          iqnn=ind(il,il,n)
<          print '(i3,7f8.3)',n,emu(iq11),emu(iq12),emu(iq13),
<      .                        emu(iq22),emu(iq32),emu(iqcc),emu(iqnn)
<         enddo
<         print *,'On each panel final_emv for ',
<      .          '(1,1),(1,2),(1,3),(2,2),(3,2),(ic,ic),(il,il)'
<         do n=0,npanels
<          iq11=ind(1,1,n)
<          iq12=ind(1,2,n)
<          iq13=ind(1,3,n)
<          iq22=ind(2,2,n)
<          iq32=ind(3,2,n)
<          iqcc=ind((il+1)/2,(il+1)/2,n)
<          iqnn=ind(il,il,n)
<          print '(i3,7f8.3)',n,emv(iq11),emv(iq12),emv(iq13),
<      .                        emv(iq22),emv(iq32),emv(iqcc),emv(iqnn)
<         enddo
<       endif  ! (ktau.eq.0)
---
>       print *,'At centre of the faces:'
>       do n=0,npanels
>        iq=ind((il+1)/2,(il+1)/2,n)
>        print '('' n,iq,x,y,z,long,lat,f ''i3,i5,3f7.3,2f8.2,f9.5)',n,
>      .   iq,x(iq),y(iq),z(iq),
>      .   rlongg(iq)*180./pi,rlatt(iq)*180./pi,f(iq)
>       enddo
>       print *,'At mid-x along edges:'
>       do n=0,npanels
>        iq=ind((il+1)/2,1,n)
>        print '('' n,iq,x,y,z,long,lat,f ''i3,i5,3f7.3,2f8.2,f9.5)',n,
>      .   iq,x(iq),y(iq),z(iq),
>      .   rlongg(iq)*180./pi,rlatt(iq)*180./pi,f(iq)
>       enddo
>       print *,'At mid-y along edges:'
>       do n=0,npanels
>        iq=ind(1,(il+1)/2,n)
>        print '('' n,iq,x,y,z,long,lat,f ''i3,i5,3f7.3,2f8.2,f9.5)',n,
>      .   iq,x(iq),y(iq),z(iq),
>      .   rlongg(iq)*180./pi,rlatt(iq)*180./pi,f(iq)
>       enddo
>       print *,'On each panel final_em for ',
>      .        '(1,1),(1,2),(1,3),(2,2),(3,2),(ic,ic),(il,il)'
>       do n=0,npanels
>        iq11=ind(1,1,n)
>        iq12=ind(1,2,n)
>        iq13=ind(1,3,n)
>        iq22=ind(2,2,n)
>        iq32=ind(3,2,n)
>        iqcc=ind((il+1)/2,(il+1)/2,n)
>        iqnn=ind(il,il,n)
>        print '(i3,7f8.3)',n,em(iq11),em(iq12),em(iq13),
>      .                  em(iq22),em(iq32),em(iqcc),em(iqnn)
>       enddo
>       print *,'On each panel final_emu for ',
>      .        '(1,1),(1,2),(1,3),(2,2),(3,2),(ic,ic),(il,il)'
>       do n=0,npanels
>        iq11=ind(1,1,n)
>        iq12=ind(1,2,n)
>        iq13=ind(1,3,n)
>        iq22=ind(2,2,n)
>        iq32=ind(3,2,n)
>        iqcc=ind((il+1)/2,(il+1)/2,n)
>        iqnn=ind(il,il,n)
>        print '(i3,7f8.3)',n,emu(iq11),emu(iq12),emu(iq13),
>      .                  emu(iq22),emu(iq32),emu(iqcc),emu(iqnn)
>       enddo
>       print *,'On each panel final_emv for ',
>      .        '(1,1),(1,2),(1,3),(2,2),(3,2),(ic,ic),(il,il)'
>       do n=0,npanels
>        iq11=ind(1,1,n)
>        iq12=ind(1,2,n)
>        iq13=ind(1,3,n)
>        iq22=ind(2,2,n)
>        iq32=ind(3,2,n)
>        iqcc=ind((il+1)/2,(il+1)/2,n)
>        iqnn=ind(il,il,n)
>        print '(i3,7f8.3)',n,emv(iq11),emv(iq12),emv(iq13),
>      .                  emv(iq22),emv(iq32),emv(iqcc),emv(iqnn)
>       enddo
=====================================
 
sflux.f
=====================================
6,7c6
< !     parameter (lake=0)    ! 0 usual, 1 for specified lake points
< !                             - replaced by nspecial in parm.h
---
>       parameter (lake=0)    ! 0 usual, 1 for specified lake points
13,14c12,13
< !     Now using tgg(,3) for the tice calculations
< c     with leads option via fracice (using tgg1 and tgg3)
---
> !     Also may be better to use tgg(,,ms) for the tice calculations
> c     with leads option;   aleadfr=0. for no leads (basic scheme) (in parm.h)
24a24
>       include 'aalat.h'    ! slwa
35c35
<       include 'screen.h'   ! tscrn,qgscrn,uscrn,scrrel,u10
---
>       include 'screen.h'   ! tscrn,qgscrn,uscrn,scrrel,u3,u10
47c47
<      . ,factch(ifull),qsttg(ifull),rho(ifull),zo(ifull)
---
>      . ,factch(ifull),rsts(ifull),rho(ifull),zo(ifull)
49,50c49,51
<      . ,gamm(ifull),rg(ifull),vmod(ifull),taftfhg_temp(ifull) ! rg in radriv90
< !     following common block makes available other arrays for diag. output 
---
>      . ,gamm(ifull),rg(ifull),vmod(ifull),taftfhg_temp(ifull)
> !     following common block passes uav, vav from sflux to vertmix
> !     and makes available other arrays for diag. output in this routine
56c57
<      . dum3(5*ijk-20*ifull)
---
>      . dum3(2*ijk-20*ifull),uav(ifull,kl),vav(ifull,kl)
89,114c90,96
<       if(nspecial.eq.1)then
<         do j=68,71  ! Eyre
<          do i=27,28
<           iq=i+(j-1)*il
< 	   sigmf(iq)=0.  ! bare "soil"
< 	   do kk=1,ms
<            wb(iq,kk)=ssat(isoilm(iq))
< 	   enddo
< 	   if(ktau.eq.1)then
< 	     print *,'lake iq,isoilm,ivegt,sigmf,zolnd ',
<      .                    iq,isoilm(iq),ivegt(iq),sigmf(iq),zolnd(iq)
< 	   endif ! (ktau.eq.1)
<          enddo
<         enddo
<         do j=64,67  ! Torrens
<          do i=28,28
<           iq=i+(j-1)*il
< 	   sigmf(iq)=0.  ! bare "soil"
< 	   do kk=1,ms
<            wb(iq,kk)=ssat(isoilm(iq))
< 	   enddo
< 	   if(ktau.eq.1)then
< 	     print *,'lake iq,isoilm,ivegt,sigmf,zolnd ',
<      .                    iq,isoilm(iq),ivegt(iq),sigmf(iq),zolnd(iq)
< 	   endif ! (ktau.eq.1)
<          enddo
---
>       if(lake.eq.1)then
>         do j=29,36
>            do i=11,12
>               iq=i+(j-1)*il
>               wb(iq,1)=ssat(isoilm(iq))
>               wb(iq,ms)=ssat(isoilm(iq))
>            enddo
116c98,103
<       endif   !  (nspecial.eq.1)
---
>         j=34
>         i=12
>         iq=i+(j-1)*il
>         wb(iq,1)=ssat(isoilm(iq))
>         wb(iq,ms)=ssat(isoilm(iq))
>       endif   !  (lake.eq.1)
143a131
>       nperday=nint(24.*3600./dt)
146,167c134,144
<         if(nbd.ne.0)then
< !         update sice from tss (see nestin, which provides tss, tgg1)
< !         check whether present ice points should change to/from sice points
<           do iq=1,ifull
<            if(.not.land(iq))then  
<              if(tss(iq).gt.271.2)then  
<                fracice(iq)=0.
<              else
<                if(fracice(iq).eq.0.)then
< !                N.B. if already a sice point, keep present tice
< !                create values for tice, and set averaged tss
<                  tgg(iq,3)=min(271.2,tss(iq),t(iq,1)+.04*6.5) ! for 40 m level 1
<                  fracice(iq)=.5    
<                endif  ! (fracice(iq).eq.0.)
<                tss(iq)=tgg(iq,3)*fracice(iq)+tgg(iq,1)*(1.-fracice(iq))
<              endif   !  (tss(iq).gt.271.2) ... else ...
<            endif   ! (.not.land(iq))
<           enddo	     ! iq loop
<         endif      ! (nbd.ne.0)
< 	      
<         if(nbd.ne.0.or.namip.ne.0)then ! update surface permutation array
< !         N.B. just done once per day
---
> !       following code is temporary until namip>0 option fully fixed up ! tempry
>         do iq=1,ifull                                                   ! tempry
>           if(land(iq).and.sice(iq))then                             ! tempry
> !          N.B. sea-ice points should not occur over land!              ! tempry
>            sice(iq)=.false.                                           ! tempry
>            print *,'sea-ice pt deleted over land for ktau,iq,zs,snowd= '! tempry
>      .            ,ktau,iq,zs(iq),snowd(iq)                         ! tempry
>           endif       ! (land(iq).and.sice(iq))                     ! tempry
>         enddo                                                           ! tempry
>         if(nsiceup.eq.1)then  ! update sice from tss (see nestin too)
> !         check whether present ice points should change to sea points
168a146,165
>           do ip=ipland+1,ipsice
>            iq=iperm(ip)
>            if(tss(iq).gt.271.2)then
>              sice(iq)=.false.
>              sicedep(iq)=0.
>            endif  !  (tss(iq).gt.271.2)
>           enddo   !  ip loop
> !         check whether present sea points should change to ice points
> !cdir nodep
>           do ip=ipsice+1,ipsea
>            iq=iperm(ip)
>            if(tss(iq).le.271.2)then
>              tgg(iq,1)=tss(iq)     ! setting tice
>              sice(iq)=.true.
>              sicedep(iq)=.5
>            endif  !  (tss(iq).le.271.2)
>           enddo   !  ip loop
>         endif     !  (nsiceup.eq.1)
>         if(nsiceup.eq.1.or.namip.gt.0)then  ! update surface permutation array
> !         N.B. for sice updated via namip>=1, need only do this once a day
177c174
<            if(fracice(iq).gt.0.)then
---
>            if(sice(iq))then
180,181c177,180
<              sice(iq)=.true.
<              sicedep(iq)=2.   
---
> !	      following presently re-set here at beginning of each day
>              tss(iq)=min(271.1,tss(iq),t(iq,1)+.04*6.5) ! for 40 m level 1
>              tgg(iq,1)=tss(iq)
>              alb(iq)=.65       ! not really needed as done in radrive
185,187c184
<              sice(iq)=.false.
<              sicedep(iq)=0.
<            endif  ! (fracice(iq).gt.0.)
---
>            endif  ! (sice(iq))
190c187
<         endif        ! (nbd.ne.0.or.namip.ne.0)
---
>         endif        ! (nsiceup.eq.1.or.namip.gt.0)
210c207,224
< !      *****  check next comment
---
>       if(npanels.eq.0)then     ! for DARLAM
>         do iq=1,ifull
>          zo(iq)=1.  ! just for boundaries for use in scrnout
>         enddo
> !       sflux called at end of time loop, hence savu1, savv1 (check)
>         do k=1,kl              ! N.B. in DARLAM boundary values not really used
>          do iq=1,il            !xxx
>           uav(iq,k)=1.
>           vav(iq,k)=1.
>          enddo
>          do iq=1+il,ifull   !xxx
>           uav(iq,k)=.5*(av_vmod*(u(iq-1,k)+u(iq,k))+
>      .                    (1.-av_vmod)*(savu(iq-1,k)+savu(iq,k)))
>           vav(iq,k)=.5*(av_vmod*(v(iq-il,k)+v(iq,k))+
>      .                    (1.-av_vmod)*(savv(iq-il,k)+savv(iq,k)))
>          enddo
>         enddo     ! k loop
>       else
211a226,230
>         do kq=1,ijk             ! uav and vav used in vertmix too
>          uav(kq,1)=av_vmod*u(kq,1)+(1.-av_vmod)*savu(kq,1) ! 1/7/01
>          vav(kq,1)=av_vmod*v(kq,1)+(1.-av_vmod)*savv(kq,1) ! 1/7/01
>         enddo
>       endif             !  (npanels.eq.0) else ..
214,216d232
<       ga(:)=0.              !  for ocean points in ga_ave diagnostic
<       theta(:)=t(:,1)/srcp
<       rho(:)=ps(:)/(r*tss(:))
218,226c234,250
<        uav=av_vmod*u(iq,1)+(1.-av_vmod)*savu(iq,1)   
<        vav=av_vmod*v(iq,1)+(1.-av_vmod)*savv(iq,1)  
<        ustar(iq)=sqrt(uav**2+vav**2)  ! i.e. vmod for tss_sh
<       enddo
<       if(ndvmod.eq.0)then
<         vmod(:)=max( ustar(:) , vmodmin)
<       else
<         vmod(:)=ndvmod  ! just for tests
<       endif    ! (ndvmod.eq.0)
---
>        theta(iq)=t(iq,1)/srcp
>        rho(iq)=ps(iq)/(r*tss(iq))
>        ustar(iq)=sqrt(uav(iq,1)**2+vav(iq,1)**2)  ! i.e. vmod for tss_sh
>        if(ndvmod.eq.0)then
>          vmod(iq)=max( ustar(iq) , vmodmin)
>        else
>          vmod(iq)=ndvmod  ! just for tests
>        endif    ! (ndvmod.eq.0)
>        if(ngas.gt.0)wspeed(iq) = vmod(iq)
>       enddo  ! iq loop
> 
> !cdir nodep
>       do ip=ipland+1,ipsice  ! all sea-ice points in this prelim. loop    ! sice
> !      this sets water temperature for leads. tice is in tgg array        ! sice
>        iq=iperm(ip)                                                       ! sice
>        tss(iq)=271.2    ! temperature for leads                         ! sice
>       enddo  !  ip=ipland+1,ipsice                                        ! sice
234d257
< !      from June '03 use basic sea temp from tgg1 (so leads is sensible)      
236,238c259,261
<       do ip=ipsea0,ipsea                                                ! sea
< !      all sea points in this big loop; also open water of leads        ! sea
<        iq=iperm(ip)                                                     ! sea
---
>       do ip=ipsea0,ipsea                                                  ! sea
> !      all sea points in this big loop; also open water of leads          ! sea
>        iq=iperm(ip)                                                       ! sea
240c263
< !      tgg2 holds effective skin sst for this loop 
---
> !      tgg(iq,2)=tss(iq)    ! tgg(,2) holds effective tss for this loop ! sea
242,245c265,268
<          dtsol=.01*sgsave(iq)/(1.+.25*ustar(iq)**2)    ! solar heating  ! sea
<          tgg(iq,2)=tgg(iq,1)+tss_sh*min(dtsol,8.)      ! of ssts        ! sea
<        elseif(ntss_sh.eq.1)then                                         ! sea
<          dtsol=tss_sh*.01*sgsave(iq)/                                   ! sea
---
>          dtsol=.01*sgsave(iq)/(1.+.25*ustar(iq)**2)  ! solar heating  ! sea
>          tgg(iq,2)=tss(iq)+tss_sh*min(dtsol,8.)        ! of ssts        ! sea
>        elseif(ntss_sh.eq.1)then
>          dtsol=tss_sh*.01*sgsave(iq)/
247,249c270,272
<          tgg(iq,2)=tgg(iq,1)+min(dtsol,8.)             ! of ssts        ! sea
<        elseif(ntss_sh.eq.3)then                                         ! sea
<          dtsol=tss_sh*.01*sgsave(iq)/                                   ! sea
---
>          tgg(iq,2)=tss(iq)+min(dtsol,8.)               ! of ssts        ! sea
>        elseif(ntss_sh.eq.3)then
>          dtsol=tss_sh*.01*sgsave(iq)/
251,253c274,276
<          tgg(iq,2)=tgg(iq,1)+min(dtsol,8.)             ! of ssts        ! sea
<        elseif(ntss_sh.eq.4)then                                         ! sea
<          dtsol=tss_sh*.01*sgsave(iq)/                                   ! sea
---
>          tgg(iq,2)=tss(iq)+min(dtsol,8.)               ! of ssts        ! sea
>        elseif(ntss_sh.eq.4)then
>          dtsol=tss_sh*.01*sgsave(iq)/
255c278
<          tgg(iq,2)=tgg(iq,1)+min(dtsol,8.)             ! of ssts        ! sea
---
>          tgg(iq,2)=tss(iq)+min(dtsol,8.)               ! of ssts        ! sea
267,269c290,292
< c ***  drag coefficients  for momentum           cduv                   ! sea
< c ***                     for heat and moisture  cdtq                   ! sea
<        es = establ(tgg(iq,2))                                           ! sea
---
> c ***  drag coefficients  for momentum           cduv                     ! sea
> c ***                     for heat and moisture  cdtq                     ! sea
>        es = establ(tgg(iq,2))                                             ! sea
271,272c294,295
<        qsttg(iq)= .622*es/constz                                        ! sea
<        drst=qsttg(iq)*ps(iq)*hlars/(constz*tgg(iq,2)**2)                ! sea
---
>        rsts(iq)= .622*es/constz                                         ! sea
>        drst=rsts(iq)*ps(iq)*hlars/(constz*tgg(iq,2)**2)               ! sea
275,276c298,299
< !      if(ngas.gt.0)stop 'call co2sflux'                                ! sea
< c      this is in-line ocenzo using latest coefficient, i.e. .018       ! sea
---
> !      if(ngas.gt.0)stop 'call co2sflux'                                  ! sea
> c      this is in-line ocenzo using latest coefficient, i.e. .018         ! sea
279c302
<        if(xx(iq).gt.0.)then             ! stable sea points             ! sea
---
>        if(xx(iq).gt.0.)then             ! stable sea points               ! sea
281,282c304,305
<          con=consea*fm                                                  ! sea
<          do it=1,3                                                      ! sea
---
>          con=consea*fm                                                    ! sea
>          do it=1,3                                                        ! sea
284c307
<           af(iq)=afroot**2                                              ! sea
---
>           af(iq)=afroot**2                                                ! sea
287,290c310,313
<      .                                                 (1.-con*daf))    ! sea
<          enddo    ! it=1,3                                              ! sea
<        else                        ! unstable sea points                ! sea
<          do it=1,3                                                      ! sea
---
>      .                                                   (1.-con*daf))    ! sea
>          enddo    ! it=1,3                                                ! sea
>        else                        ! unstable sea points                  ! sea
>          do it=1,3                                                        ! sea
292c315
<           af(iq)=afroot**2                                              ! sea
---
>           af(iq)=afroot**2                                                ! sea
298,302c321,325
<           dfm=2.*bprm*xx(iq)*dden/den**2                                ! sea
<           zo(iq)=max(1.5e-5,zo(iq)-(zo(iq)-consea*af(iq)*fm)/           ! sea
<      .                     (1.-consea*(daf*fm+af(iq)*dfm)))             ! sea
<          enddo    ! it=1,3                                              ! sea
<        endif    ! (xx.gt.0.) .. else..                                  ! sea
---
>           dfm=2.*bprm*xx(iq)*dden/den**2                                  ! sea
>           zo(iq)=max(1.5e-5,zo(iq)-(zo(iq)-consea*af(iq)*fm)/       ! sea
>      .                     (1.-consea*(daf*fm+af(iq)*dfm)))               ! sea
>          enddo    ! it=1,3                                                ! sea
>        endif    ! (xx.gt.0.) .. else..                                    ! sea
307,311c330,334
< c       actually only need zt (& thus factch) for unstable points       ! sea
< c       factch is sqrt(zo/zt) for use in unstable fh                    ! sea
< c       enhanced formula used in Feb '92 Air-Sea conference follows:    ! sea
< c       factch=sqrt(zo*exp(vkar*vkar/(chnsea*log(zmin/zo)))/zmin)       ! sea
<         do iq=1,ifull                                                   ! sea
---
> c       actually only need zt (& thus factch) for unstable points         ! sea
> c       factch is sqrt(zo/zt) for use in unstable fh                      ! sea
> c       enhanced formula used in Feb '92 Air-Sea conference follows:      ! sea
> c       factch=sqrt(zo*exp(vkar*vkar/(chnsea*log(zmin/zo)))/zmin)         ! sea
>         do iq=1,ifull                                                     ! sea
315,317c338,339
< !cdir nodep
<         do ip=ipsea0,ipsea                                              ! sea
<          iq=iperm(ip)                                                   ! sea
---
>         do ip=ipsea0,ipsea                                                ! sea
>          iq=iperm(ip)                                                     ! sea
322,326c344,347
< !cdir nodep
<       do ip=ipsea0,ipsea                                                ! sea
<        iq=iperm(ip)                                                     ! sea
< c      Having settled on zo (and thus af) now do actual fh and fm calcs ! sea
<        if(xx(iq).gt.0.)then                                             ! sea
---
>       do ip=ipsea0,ipsea                                                  ! sea
>        iq=iperm(ip)                                                       ! sea
> c      Having settled on zo (and thus af) now do actual fh and fm calcs   ! sea
>        if(xx(iq).gt.0.)then                                               ! sea
329c350
<        else        ! xx is -ve                                          ! sea
---
>        else        ! xx is -ve                                            ! sea
331c352
< c        First do momentum                                              ! sea
---
> c        First do momentum                                                ! sea
335,343c356,364
< c        Now heat ; allow for smaller zo via aft and factch             ! sea
<          denha=vmod(iq)+chs*2.*bprm*factch(iq)*aft(iq)*root             ! sea
<          fh(iq)=vmod(iq)-(2.*bprm *xx(iq))/denha                        ! sea
<        endif                                                            ! sea
<                                                                         ! sea
<        conh=rho(iq)*aft(iq)*cp                                          ! sea
<        conw=rho(iq)*aft(iq)*hl                                          ! sea
<        fg(iq)=conh*fh(iq)*(tgg(iq,2)-theta(iq))                         ! sea
<        eg(iq)=conw*fh(iq)*(qsttg(iq)-qg(iq,1))    ! *98*qsttg??         ! sea
---
> c        Now heat ; allow for smaller zo via aft and factch               ! sea
>          denha=vmod(iq)+chs*2.*bprm*factch(iq)*aft(iq)*root         ! sea
>          fh(iq)=vmod(iq)-(2.*bprm *xx(iq))/denha                      ! sea
>        endif                                                              ! sea
>                                                                           ! sea
>        conh=rho(iq)*aft(iq)*cp                                        ! sea
>        conw=rho(iq)*aft(iq)*hl                                        ! sea
>        fg(iq)=conh*fh(iq)*(tgg(iq,2)-theta(iq))                     ! sea
>        eg(iq)=conw*fh(iq)*(rsts(iq)-qg(iq,1))    ! *98*rsts??     ! sea
345c366
< c      cduv is now drag coeff *vmod                                     ! sea
---
> c      cduv is now drag coeff *vmod                                       ! sea
347,353c368,374
<        ustar(iq) = sqrt(vmod(iq)*cduv(iq))                              ! sea
< c      Surface stresses taux, tauy: diagnostic only - unstaggered now   ! sea
<        taux(iq)=rho(iq)*cduv(iq)*u(iq,1)                                ! sea
<        tauy(iq)=rho(iq)*cduv(iq)*v(iq,1)                                ! sea
<        if(ntest.eq.1.and.iq.eq.idjd)then                                ! sea
<          print *,'in sea loop for iq,idjd,ip,ipsea0: ',                 ! sea
<      .                            iq,idjd,ip,ipsea0                     ! sea
---
>        ustar(iq) = sqrt(vmod(iq)*cduv(iq))                          ! sea
> c      Surface stresses taux, tauy: diagnostic only - unstaggered now     ! sea
>        taux(iq)=rho(iq)*cduv(iq)*u(iq,1)                          ! sea
>        tauy(iq)=rho(iq)*cduv(iq)*v(iq,1)                          ! sea
>        if(ntest.eq.1.and.iq.eq.idjd)then                                  ! sea
>          print *,'in sea loop for iq,idjd,ip,ipsea0: ',                   ! sea
>      .                            iq,idjd,ip,ipsea0                       ! sea
355c376
<          print *,'xx,ri,es ',xx(iq),ri(iq),es                           ! sea
---
>          print *,'xx,ri,es ',xx(iq),ri(iq),es                             ! sea
357c378
<          print *,'tss,theta,t1 ',tss(iq),theta(iq),t(iq,1)              ! sea
---
>          print *,'tss,theta,t1 ',tss(iq),theta(iq),t(iq,1)          ! sea
360,362c381,383
<          print *,'vmod,cduv,fg ',vmod(iq),cduv(iq),fg(iq)               ! sea
<        endif                                                            ! sea
<       enddo    !  ip=ipsea0,ipsea                                       ! sea
---
>          print *,'vmod,cduv,fg ',vmod(iq),cduv(iq),fg(iq)           ! sea
>        endif                                                              ! sea
>       enddo    !  ip=ipsea0,ipsea                                         ! sea
367,371c388,392
<       do ip=ipland+1,ipsice  ! all sea-ice points in this loop          ! sice
< !      non-leads for sea ice points                                     ! sice
< !      N.B. tgg( ,3) holds tice                                         ! sice
<        iq=iperm(ip)                                                     ! sice
<        es = establ(tgg(iq,3))                                           ! sice
---
>       do ip=ipland+1,ipsice  ! all sea-ice points in this loop            ! sice
> !      non-leads for sea ice points                                       ! sice
> !      N.B. tgg( ,1) holds tice                                           ! sice
>        iq=iperm(ip)                                                       ! sice
>        es = establ(tgg(iq,1))                                             ! sice
373,375c394,396
<        qsttg(iq)= .622*es/constz                                        ! sice
<        drst=qsttg(iq)*ps(iq)*hlars/(tgg(iq,3)*tgg(iq,3)*constz)         ! sice
<        xx(iq)=9.806*zmin*(1.-tgg(iq,3)*srcp/t(iq,1))                    ! sice
---
>        rsts(iq)= .622*es/constz                                         ! sice
>        drst=rsts(iq)*ps(iq)*hlars/(tgg(iq,1)*tgg(iq,1)*constz)        ! sice
>        xx(iq)=9.806*zmin*(1.-tgg(iq,1)*srcp/t(iq,1))                    ! sice
381c402
<        af(iq)=(vkar/zologice)**2                                        ! sice
---
>        af(iq)=(vkar/zologice)**2                                          ! sice
384,387c405,408
<        wetfac(iq)=1+.008*(tgg(iq,3)-273.16)  ! .008*tgg(iq,3)-1.18528   ! sice
<                                                                         ! sice
< c      Having settled on zo (and thus af) now do actual fh and fm calcs ! sice
<        if(xx(iq).gt.0.)then                                             ! sice
---
>        wetfac(iq)=1+.008*(tgg(iq,1)-273.16)  ! .008*tgg(iq,1)-1.18528   ! sice
>                                                                           ! sice
> c      Having settled on zo (and thus af) now do actual fh and fm calcs   ! sice
>        if(xx(iq).gt.0.)then                                               ! sice
390c411
<        else                                                             ! sice
---
>        else                                                               ! sice
392c413
< c        First do momentum                                              ! sice
---
> c        First do momentum                                                ! sice
396,406c417,427
< c        Now heat ; allow for smaller zo via aft and factch             ! sice
<          denha=vmod(iq)+chs*2.*bprm*factch(iq)*aft(iq)*root             ! sice
<          fh(iq)=vmod(iq)-(2.*bprm *xx(iq))/denha                        ! sice
<        endif                                                            ! sice
<                                                                         ! sice
<        conh=rho(iq)*aft(iq)*cp                                          ! sice
<        conw=rho(iq)*aft(iq)*hl                                          ! sice
<        fgice=conh*fh(iq)*(tgg(iq,3)-theta(iq))                          ! sice
<        dfgdt(iq)=conh*fh(iq)                                            ! sice
<        if(ntest.eq.1.and.iq.eq.idjd)then                                ! sice
<          print *,'in sice loop'                                         ! sice
---
> c        Now heat ; allow for smaller zo via aft and factch               ! sice
>          denha=vmod(iq)+chs*2.*bprm*factch(iq)*aft(iq)*root         ! sice
>          fh(iq)=vmod(iq)-(2.*bprm *xx(iq))/denha                      ! sice
>        endif                                                              ! sice
>                                                                           ! sice
>        conh=rho(iq)*aft(iq)*cp                                        ! sice
>        conw=rho(iq)*aft(iq)*hl                                        ! sice
>        fgice=conh*fh(iq)*(tgg(iq,1)-theta(iq))                        ! sice
>        dfgdt(iq)=conh*fh(iq)                                          ! sice
>        if(ntest.eq.1.and.iq.eq.idjd)then                                  ! sice
>          print *,'in sice loop'                                           ! sice
408c429
<          print *,'xx,ri,es ',xx(iq),ri(iq),es                           ! sice
---
>          print *,'xx,ri,es ',xx(iq),ri(iq),es                             ! sice
412,421c433,442
<        endif                                                            ! sice
<                                                                         ! sice
<        if(nalpha.eq.1)then    ! beta scheme         sice here           ! sice
<          egice   =wetfac(iq)*conw*fh(iq)*(qsttg(iq)-qg(iq,1))           ! sice
<          epotice    = conw*fh(iq)*(qsttg(iq)-qg(iq,1))                  ! sice
<          degdt(iq)=wetfac(iq)*conw*fh(iq)*drst                          ! sice
<        else                   ! alpha scheme                            ! sice
< c        following trick reduces -ve evap (dew) to 1/10th value         ! sice
<          qtgnet=qsttg(iq)*wetfac(iq) -qg(iq,1)                          ! sice
<          qtgair=qsttg(iq)*wetfac(iq)-max(qtgnet,.1*qtgnet)              ! sice
---
>        endif                                                              ! sice
>                                                                           ! sice
>        if(nalpha.eq.1)then    ! beta scheme         sice here             ! sice
>          egice   =wetfac(iq)*conw*fh(iq)*(rsts(iq)-qg(iq,1))      ! sice
>          epotice    = conw*fh(iq)*(rsts(iq)-qg(iq,1))               ! sice
>          degdt(iq)=wetfac(iq)*conw*fh(iq)*drst                      ! sice
>        else                   ! alpha scheme                              ! sice
> c        following trick reduces -ve evap (dew) to 1/10th value           ! sice
>          qtgnet=rsts(iq)*wetfac(iq) -qg(iq,1)                       ! sice
>          qtgair=rsts(iq)*wetfac(iq)-max(qtgnet,.1*qtgnet)             ! sice
423c444
<          eg1=conw*fh(iq)*qsttg(iq)                                      ! sice
---
>          eg1=conw*fh(iq)*rsts(iq)                                     ! sice
425,427c446,448
<          epotice    = conw*fh(iq)*(qsttg(iq)-qg(iq,1))                  ! sice
<          deg=wetfac(iq)*conw*fh(iq)*drst                                ! sice
< c        following reduces degdt by factor of 10 for dew                ! sice
---
>          epotice    = conw*fh(iq)*(rsts(iq)-qg(iq,1))               ! sice
>          deg=wetfac(iq)*conw*fh(iq)*drst                              ! sice
> c        following reduces degdt by factor of 10 for dew                  ! sice
429,435c450,456
<        endif                                                            ! sice
<                                                                         ! sice
< c      section to update sea ice surface temperature;                   ! sice
< c      specified sea-ice thickness                                      ! sice
< c      over sea ice, set a minimum depth for this experiment of .1      ! sice
<        sicedep(iq) = max(sicedep(iq) , 0.1)                             ! sice
< c      no snow on the ice assumed for now                               ! sice
---
>        endif                                                              ! sice
>                                                                           ! sice
> c      section to update sea ice surface temperature;                     ! sice
> c      specified sea-ice thickness                                        ! sice
> c      over sea ice, set a minimum depth for this experiment of .1        ! sice
>        sicedep(iq) = max(sicedep(iq) , 0.1)                           ! sice
> c      no snow on the ice assumed for now                                 ! sice
437,443c458,463
<        cie(iq) = 2.04/sicedep(iq)                                       ! sice
<        rgg(iq)=5.67e-8*tgg(iq,3)**4                                     ! sice
< !      gflux here is	flux from ice to water, +ve downwards              ! sice
<        gflux(iq)=cie(iq)*(tgg(iq,3)-271.2)                              ! sice
<        ga(iq)=-slwa(iq)-rgg(iq)-egice-fgice-gflux(iq)                   ! sice
<        dirad(iq)=4.*5.67e-8*tgg(iq,3)**3                                ! sice
<        b1=dirad(iq)+degdt(iq)+dfgdt(iq)+cie(iq)                         ! sice
---
>        cie(iq) = 2.04/sicedep(iq)                                     ! sice
>        rg(iq)=5.67e-8*tgg(iq,1)**4                                      ! sice
>        hicf=cie(iq)*(tgg(iq,1)-271.2)   ! flux through ice to surface   ! sice
>        g=-slwa(iq)-rg(iq)-egice   -fgice-hicf                         ! sice
>        dirad(iq)=4.*5.67e-8*tgg(iq,1)**3                                ! sice
>        b1=dirad(iq)+degdt(iq)+dfgdt(iq)+cie(iq)                   ! sice
445,447c465,467
<        deltat=ga(iq)/gbot                                               ! sice
<        tgg(iq,3)=tgg(iq,3)+deltat                                       ! sice
<        tgg(iq,3)=min(tgg(iq,3),271.2)   ! jlm fix Tue  05-30-2000
---
>        deltat=g/gbot                                                      ! sice
>        tgg(iq,1)=tgg(iq,1)+deltat                                         ! sice
>        tgg(iq,1)=min(tgg(iq,1),271.2)   ! jlm fix Tue  05-30-2000
450c470
<        es = establ(tgg(iq,3))                                           ! sice
---
>        es = establ(tgg(iq,1))                                             ! sice
452,470c472,490
<        qsttg(iq)=.622*es/constz                                         ! sice
<                                                                         ! sice
< !      combine ice and leads contributions here                         ! sice
<        eg(iq) =fracice(iq)*egice + (1.-fracice(iq))*eg(iq)              ! sice
<        fg(iq) = fracice(iq)*fgice + (1.-fracice(iq))*fg(iq)             ! sice
<        cduv(iq) =fracice(iq)*af(iq)*fm + (1.-fracice(iq))*cduv(iq)      ! sice                                                                                 ! sice
<        ustar(iq) = sqrt(vmod(iq)*cduv(iq))                              ! sice
< c      N.B. potential evaporation is now eg+eg2                         ! sice
<        epot(iq) =fracice(iq)*epotice + (1.-fracice(iq))*epot(iq)        ! sice
<        tss(iq) = fracice(iq)*tgg(iq,3)+(1.-fracice(iq))*tgg(iq,1)       ! sice
< c      Surface stresses taux, tauy: diagnostic only - unstaggered now   ! sice
<        taux(iq)=rho(iq)*cduv(iq)*u(iq,1)                                ! sice
<        tauy(iq)=rho(iq)*cduv(iq)*v(iq,1)                                ! sice
<        if(ntest.eq.1.and.iq.eq.idjd)then                                ! sice
<          print *,'ri,vmod,cduv ',ri(iq),vmod(iq),cduv(iq)               ! sice
<          print *,'tss,tgg3,ustar ',tss(iq),tgg(iq,3),ustar(iq)          ! sice
<          print *,'theta,t1,deltat ',theta(iq),t(iq,1),deltat            ! sice
<          print *,'b1,ga,gbot ',b1,ga(iq),gbot                           ! sice
<          print *,'fg,fgice,factch ',fg(iq),fgice,factch(iq)             ! sice
---
>        rsts(iq)=.622*es/constz                                          ! sice
>                                                                           ! sice
> !      combine ice and leads contributions here                           ! sice
>        eg(iq) =fracice(iq)*egice + (1.-fracice(iq))*eg(iq)            ! sice
>        fg(iq) = fracice(iq)*fgice + (1.-fracice(iq))*fg(iq)           ! sice
>        cduv(iq) =fracice(iq)*af(iq)*fm + (1.-fracice(iq))*cduv(iq)    ! sice                                                                                 ! sice
>        ustar(iq) = sqrt(vmod(iq)*cduv(iq))                          ! sice
> c      N.B. potential evaporation is now eg+eg2                           ! sice
>        epot(iq) =fracice(iq)*epotice + (1.-fracice(iq))*epot(iq)          ! sice
>        tss(iq) = fracice(iq)*tgg(iq,1) + (1.-fracice(iq))*tss(iq)     ! sice
> c      Surface stresses taux, tauy: diagnostic only - unstaggered now     ! sice
>        taux(iq)=rho(iq)*cduv(iq)*u(iq,1)                          ! sice
>        tauy(iq)=rho(iq)*cduv(iq)*v(iq,1)                          ! sice
>        if(ntest.eq.1.and.iq.eq.idjd)then                                  ! sice
>          print *,'ri,vmod,cduv ',ri,vmod(iq),cduv(iq)                 ! sice
>          print *,'tss,tgg1,ustar ',tss(iq),tgg(iq,1),ustar(iq)        ! sice
>          print *,'theta,t1,deltat ',theta(iq),t(iq,1),deltat          ! sice
>          print *,'b1,g,gbot ',b1,g,gbot                                   ! sice
>          print *,'fg,fgice,factch ',fg(iq),fgice,factch(iq)           ! sice
472,473c492,493
<        endif   ! (ntest.eq.1.and.iq.eq.idjd)                            ! sice
<       enddo       ! ip=ipland+1,ipsice                                  ! sice
---
>        endif   ! (ntest.eq.1.and.iq.eq.idjd)                              ! sice
>       enddo       ! ip=ipland+1,ipsice                                    ! sice
480,483c500,503
<       do ip=1,ipland  ! all land points in this shared loop             ! land
< c      fh itself was only used outside this loop in sib0 (jlm)          ! land
<        iq=iperm(ip)                                                     ! land
<        zobg=zobgin                                                      ! land
---
>       do ip=1,ipland  ! all land points in this shared loop               ! land
> c      fh itself was only used outside this loop in sib0 (jlm)                ! land
>        iq=iperm(ip)                                                       ! land
>        zobg=zobgin                                                        ! land
486,487c506,507
<        qsttg(iq)=       .622*es/constz     ! only used in scrnout?      ! land
<        xx(iq)=9.806*zmin*(1.-tss(iq)*srcp/t(iq,1))                      ! land
---
>        rsts(iq)=       .622*es/constz                                   ! land
>        xx(iq)=9.806*zmin*(1.-tss(iq)*srcp/t(iq,1))                    ! land
489c509
< c      factch is sqrt(zo/zt) for land use in unstable fh                ! land
---
> c      factch is sqrt(zo/zt) for land use in unstable fh                  ! land
492c512
< !        reduce zo over snow; done in darlam & globpe on 12-06-1996     ! land
---
> !        reduce zo over snow; done in darlam & globpe on Fri  12-06-1996  ! land
494,495c514,515
< !        following line is bit simpler than csiro9                      ! land
<          zo(iq)=max(zolnd(iq) -.001*snowd(iq), .01)                     ! land
---
> !        following line is bit simpler than csiro9                        ! land
>          zo(iq)=max(zolnd(iq) -.001*snowd(iq), .01)                 ! land
498,511c518,531
<          alzz=log(zmin/zobg)                                            ! land
<          if(nblend.eq.1)then ! blended zo for momentum: reduce for snow?! land
<            afland=(vkar/((1.-sigmf(iq))*alzz+sigmf(iq)*zologsnw))**2    ! land
<          else                                                           ! land
<            afland=(vkar/zologsnw)**2                                    ! land
<          endif   !   (nblend.eq.1)                                      ! land
<          aftland=vkar**2/( zologsnw * (2.+zologsnw) )                   ! land
<        else  ! land but not snow                                        ! land
<          zo(iq)=zolnd(iq)                                               ! land
<          alzz=alzzin                                                    ! land
<          if(nblend.eq.1)then  ! blended zo for momentum                 ! land
<            afland=(vkar/                                                ! land
<      .               ((1.-sigmf(iq))*alzz+sigmf(iq)*zolog(iq)))**2      ! land
<          else    ! non-blended zo for momentum                          ! land
---
>          alzz=log(zmin/zobg)                                              ! land
>          if(nblend.eq.1)then   ! blended zo for momentum: reduce for snow?! land
>            afland=(vkar/((1.-sigmf(iq))*alzz+sigmf(iq)*zologsnw))**2  ! land
>          else                                                             ! land
>            afland=(vkar/zologsnw)**2                                      ! land
>          endif   !   (nblend.eq.1)                                        ! land
>          aftland=vkar**2/( zologsnw * (2.+zologsnw) )                     ! land
>        else  ! land but not snow                                          ! land
>          zo(iq)=zolnd(iq)                                             ! land
>          alzz=alzzin                                                      ! land
>          if(nblend.eq.1)then  ! blended zo for momentum                   ! land
>            afland=(vkar/                                                  ! land
>      .               ((1.-sigmf(iq))*alzz+sigmf(iq)*zolog(iq)))**2  ! land
>          else    ! non-blended zo for momentum                            ! land
513,514c533,534
<          endif   ! (nblend.eq.1)                                        ! land
<          aftland=vkar**2/( zolog(iq) * (2.+zolog(iq)) )                 ! land
---
>          endif   ! (nblend.eq.1)                                          ! land
>          aftland=vkar**2/( zolog(iq) * (2.+zolog(iq)) )               ! land
517c537
<        aftlandg=vkar**2/( alzz * (2.+alzz) )                            ! land
---
>        aftlandg=vkar**2/( alzz * (2.+alzz) )                              ! land
522c542
<          af(iq)=afland                                                  ! land
---
>          af(iq)=afland                                                    ! land
524,526c544,546
<                                                                         ! land
< c      Having settled on zo (and thus af) now do actual fh and fm calcs ! land
<        if(xx(iq).gt.0.)then                                             ! land
---
>                                                                           ! land
> c      Having settled on zo (and thus af) now do actual fh and fm calcs   ! land
>        if(xx(iq).gt.0.)then                                               ! land
530c550
<        else                                                             ! land
---
>        else                                                               ! land
532c552
< c        First do momentum                                              ! land
---
> c        First do momentum                                                ! land
536,540c556,560
< c        Now heat ; allow for smaller zo via aft and factch             ! land
<          denha=vmod(iq)+chs*2.*bprm*factch(iq)*aft(iq)*root             ! land
<          fh(iq)=vmod(iq)-(2.*bprm *xx(iq))/denha                        ! land
<          rootbg=sqrt(-xx(iq)*zmin/zobg)                                 ! land
<          denhabg=vmod(iq)+chs*2.*bprm*factch(iq)*aftlandg*rootbg        ! land
---
> c        Now heat ; allow for smaller zo via aft and factch               ! land
>          denha=vmod(iq)+chs*2.*bprm*factch(iq)*aft(iq)*root         ! land
>          fh(iq)=vmod(iq)-(2.*bprm *xx(iq))/denha                      ! land
>          rootbg=sqrt(-xx(iq)*zmin/zobg)                                   ! land
>          denhabg=vmod(iq)+chs*2.*bprm*factch(iq)*aftlandg*rootbg      ! land
542,545c562,565
<        endif                                                            ! land
<        taftfhg_temp(iq)=aftlandg*fhbg  ! uses fmroot above, for sib3    ! land
<                                                                         ! land
< c      cduv is now drag coeff *vmod                                     ! land
---
>        endif                                                              ! land
>        taftfhg_temp(iq)=aftlandg*fhbg  ! uses fmroot above, for sib1,3    ! land
>                                                                           ! land
> c      cduv is now drag coeff *vmod                                       ! land
547,552c567,572
<        ustar(iq) = sqrt(vmod(iq)*cduv(iq))                              ! land
< c      cdtq(iq) =aft(iq)*fh(iq)                                         ! land
< c      Surface stresses taux, tauy: diagnostic only - unstaggered now   ! land
<        taux(iq)=rho(iq)*cduv(iq)*u(iq,1)                                ! land
<        tauy(iq)=rho(iq)*cduv(iq)*v(iq,1)                                ! land
<       enddo     ! ip=1,ipland                                           ! land
---
>        ustar(iq) = sqrt(vmod(iq)*cduv(iq))                          ! land
> c      cdtq(iq) =aft(iq)*fh(iq)                                     ! land
> c      Surface stresses taux, tauy: diagnostic only - unstaggered now     ! land
>        taux(iq)=rho(iq)*cduv(iq)*u(iq,1)                          ! land
>        tauy(iq)=rho(iq)*cduv(iq)*v(iq,1)                          ! land
>       enddo     ! ip=1,ipland                                             ! land
555,558c575,578
<        if(ntest.eq.1.and.iq.eq.idjd)then                                ! land
<          print *,'in main land loop'                                    ! land
<          print *,'zmin,zobg ',zmin,zobg                                 ! land
<          print *,'afland,aftland,alzz ',afland,aftland,alzz             ! land
---
>        if(ntest.eq.1.and.iq.eq.idjd)then                                  ! land
>          print *,'in main land loop'                                      ! land
>          print *,'zmin,zobg ',zmin,zobg                                   ! land
>          print *,'afland,aftland,alzz ',afland,aftland,alzz               ! land
560,562c580,582
<          print *,'tss,theta,t1 ',tss(iq),theta(iq),t(iq,1)              ! land
<          print *,'aft,chnsea,fm,fh,rho,conh '                           ! land
<      .           ,aft(iq),chnsea,fm,fh(iq),rho(iq),conh                 ! land
---
>          print *,'tss,theta,t1 ',tss(iq),theta(iq),t(iq,1)          ! land
>          print *,'aft,chnsea,fm,fh,rho,conh '                             ! land
>      .           ,aft(iq),chnsea,fm,fh(iq),rho(iq),conh             ! land
564,566c584,586
<      .            ri(iq),vmod(iq),cduv(iq),fg(iq)                       ! land
<        endif                                                            ! land
<       if(ntaft.eq.0.or.ktau.eq.1)then
---
>      .            ri(iq),vmod(iq),cduv(iq),fg(iq)                   ! land
>        endif                                                              ! land
>       if(ntaft.eq.0.or.ktau.eq.kstart)then
568c588
<          taftfh(iq)=aft(iq)*fh(iq) ! uses fmroot above                  ! land
---
>          taftfh(iq)=aft(iq)*fh(iq) ! uses fmroot above              ! land
573c593
<          thnew=aft(iq)*fh(iq) ! uses fmroot above                       ! land
---
>          thnew=aft(iq)*fh(iq) ! uses fmroot above                   ! land
598c618
<       endif  ! (ntaft.eq.0.or.ktau.eq.1)  .. else ..
---
>       endif  ! (ntaft.eq.0.or.ktau.eq.kstart)  .. else ..
603c623
<         if(ktau.eq.1)then  !To initialize new nsib=1/3 run (or restart) only
---
>         if(ktau.eq.kstart)then  !To initialize new nsib=1/3 run (or restart) only
614c634,635
<         endif  ! if(ktau.eq.1)
---
>         endif  ! if(ktau.eq.kstart)
>         if(nsib.eq.1)call sib1(nalpha)
616a638
>       if(nsib.eq.2)call sib2   ! (Klara's scam scheme)
626,627c648,649
<       call scrnout(zo,ustar,fg,eg,factch,rho,wetfac,qsttg,   ! arrays
<      .       qgscrn,tscrn,uscrn,u10,scrrel,                 ! arrays
---
>       call scrnout(zo,ustar,fg,eg,factch,rho,wetfac,rsts,   ! arrays
>      .       qgscrn,tscrn,uscrn,u3,u10,scrrel,              ! arrays
650a673,1156
>       subroutine sib1(nalpha)
>       parameter (ntest=0) ! ntest= 0 for diags off; ntest= 1 for diags on
> !     parameter (nalph=2) ! 1 for beta, 2 for alpha; hard-wired here for sib1
> !       but also set nalpha in namelist, for use in scrnout
>       parameter (nfeedbk=0) ! nfeedbk=0 usually, 1 to suppress feedbacks
> !                 2 for no d/dw terms, 3 for no dg/dw but with dE/dw
>       parameter (nsigmf=0) ! 0 for usual tsigmf usage in sib1
>       parameter (ars=461.,cp=1004.64,hl=2.5104e6,r=287.,hlars=hl/ars)
>       parameter (hlfusion=.336e6,tfrz=273.1)
>       parameter (d3=2.5,wgmax=.36,stbo=5.67e-08)
>       parameter (cgsoil=1000.,gksoil=.300e-6,rhog=1600.,d1land=.03)
>       include 'newmpar.h'
>       include 'aalat.h'    ! slwa
>       include 'arrays.h'
>       include 'dates.h' ! ktime,kdate,timer,timeg,xg,yg
>       include 'extraout.h'
>       include 'morepbl.h'
>       include 'nsibd.h'    ! rsmin,ivegt,sigmf,tgf,ssdn,res,rmc,tsigmf
>       include 'parm.h'
>       include 'pbl.h'
>       include 'scamdim.h'  ! dimension of patches
>       include 'screen.h'   ! tscrn etc
>       include 'sigs.h'
>       include 'soil.h'     ! ... zmin zolnd zolog sice alb
>       include 'soilv.h'    ! ssat, clay,..
>       include 'soilsnow.h' ! new soil arrays for scam - tgg too
>       include 'tracers.h'  ! ngas, nllp, ntrac
>       include 'trcom2.h'   ! nstn,slat,slon,istn,jstn
>       common/permsurf/ipsice,ipsea,ipland,iperm(ifull)
>       common/tafts/taftfh(ifull),taftfhg(ifull)
>       common/work2/dirad(ifull),dfgdt(ifull),degdt(ifull)
>      . ,wetfac(ifull),degdw(ifull),cie(ifull)
>      . ,factch(ifull),rsts(ifull),rho(ifull),zo(ifull)
>      . ,aft(ifull),fh(ifull),spare1(ifull),theta(ifull)
>      . ,gamm(ifull),rg(ifull),vmod(ifull),spare(ifull)
>       common/work3/egg(ifull),evapxf(ifull),Ewww(ifull),fgf(ifull),
>      . fgg(ifull),ggflux(ifull),rdg(ifull),rgg(ifull),residf(ifull),
>      . ga(ifull),condxpr(ifull),fev(ifull),fes(ifull),
>      . ism(ifull),fwtop(ifull),epot(ifull),
>      . extin(ifull),af(ifull),ri(ifull),xx(ifull),
>      . dum3(2*ijk-20*ifull),uav(ifull,kl),vav(ifull,kl)
> c     real thetar(kl)
>       dimension c3(9),c1sat(9),c2ref(9),coefb(9),aa(3),bb(3)
>       data c1sat/ .1, .255, .342, .16, .421, .375, .213, .180, .255/ ! for func1
>       data coefb/4.2, 7.1, 11.4, 5.15, 10.4, 10.4, 7.12, 5.83,  7.1/ ! for func1
>       data c2ref/3.8,.6,.3,1.3,.3,.3,.8,.926,.6/
>       data c3/1.255,.334,.138,.521,.231,.199,.375,.623,.334/
>       data     aa/.004,.003,.003/,bb/.006,.004,.004/
>       character*14 fname0
>       save c2ref
> 
>       data dsnow/.1/,scond1sx/.08/,cap1sx/2.e5/
>       common /es_table/ table(0:220)
> c     T is temp in Kelvin, which should lie between 123.16 and 343.16;
> c     TDIFF is difference between T and 123.16, subject to 0 <= TDIFF <= 220
>       tdiff(tm)=min(max(tm-123.16 , 0.) , 220.)
>       establ(tm)=(1.-(tdiff(tm)-aint(tdiff(tm))))*table(int(tdiff(tm)))
>      &           + (tdiff(tm)-aint(tdiff(tm)))*table(int(tdiff(tm))+1)
>       fle(isoil,w)=(w-swilt(isoil))/(sfc(isoil)-swilt(isoil))           ! Eva's
> !     fle(isoil,w)=10.*((w-ssoil(isoil))/ssat(isoil)+.1))               ! an old one
>       func1(isoil,stc)=min(c1sat(isoil)*stc** (-1.-.5*coefb(isoil)),10.)
>       point4(ww)=(12.31+19.13*ww)*ww/(1.+25.73*ww)     ! jlm approx for ww**.4
> 
>       if(ktau.eq.kstart) then
>         print *,'at beginning of sib1'
> c       if(nalph.ne.nalpha)stop 'need to set nalph in sib1'
>         iveg=ivegt(idjd)
>         isoil=isoilm(idjd)
>         print *,'nsib,iveg,isoil,nalpha,nsigmf,nfeedbk,tsigmf ',
>      .           nsib,iveg,isoil,nalpha,nsigmf,nfeedbk,tsigmf(idjd)
>         print *,'sfc,swilt,wb ',
>      .           sfc(isoil),swilt(isoil),(wb(idjd,k),k=1,ms)
>       endif
> 
>       if(nrungcm.eq.3)then
>         c2ref(2)=0.   ! for PIRCS Tue  01-05-1999
>         c2ref(3)=0.   ! for PIRCS Tue  01-05-1999
>       endif
> !***  N.B. nrungcm=2 fix-up for Mark 2 wb moved to indata 6/11/00
> 
>       rmstep=dt/60.
>       d2=sqrt(86400.*3.1415926536*gksoil) - d1land
> !cdir nodep
>       do 681 ip=1,ipland  ! all land points in this nsib=1 loop
>        iq=iperm(ip)
>        iveg=ivegt(iq)
>        isoil = isoilm(iq)
> c      if(isoil.eq.4)sigmf(iq)=.4  ! test for Darwin
> c                      evaluate seasonal impact and the snow depth
> c                      impact on the fractional vegetation cover
>        tsoil=.5*(tgg(iq,2)+tgg(iq,ms))
>        ftsoil=max( 0. , 1.-.0016*(298.-tsoil)*max(0.,298.-tsoil) )
> c         which is same as:  ftsoil=max(0.,1.-.0016*(298.-tsoil)**2)
> c                            if( tsoil .ge. 298. ) ftsoil=1.
>        tsigmf(iq)=max(0.,sigmf(iq)-scveg44(iveg)*(1.-ftsoil))
>        tsigmf(iq)=(1.-snowd(iq)/
>      .            (snowd(iq)+5.*100.*zo(iq)))*tsigmf(iq)
>        if(ntest.eq.1.and.iq.eq.idjd) then
>          print *,'in sib1'
>          print*,'taftfh,taftfhg,tsigmf '
>      .          ,taftfh(iq),taftfhg(iq),tsigmf(iq)
>          print*,'iveg,isoil,sigmf(iq) ',iveg,isoil,sigmf(iq)
>          print*,'scveg44,snowd,zo ',
>      .           scveg44(iveg),snowd(iq),zo(iq)
>          print *,'alb,albsav,ssat ',alb(iq),albsav(iq),ssat(isoil)
>          print*,'c2ref,w2 ',c2ref(isoil),wb(iq,ms)
>        endif ! ntest
> c      dearc2 = max(2.0,min(c2ref(isoil)*wb(iq,ms)/
>        dearc2 = max(1.0,min(c2ref(isoil)*wb(iq,ms)/   ! better for PIRCS isoil=2
>      &       (ssat(isoil)-wb(iq,ms)+0.001),12.0))*dt/86400.
> 
> c      bare ground calculation
>        wb04=wb(iq,1)**.4
> c      wb04=point4(wb(iq,1))
>        scond1=(sand(isoil)*max(aa(1)*wb(iq,1) + bb(1)*wb04,.0007)
>      &    +clay(isoil)*max(aa(2)*wb(iq,1) + bb(2)*wb04,.0007))*418.
>        wb04=wb(iq,ms)**.4
> c      wb04=point4(wb(iq,ms))
>        scond2=(sand(isoil)*max(aa(1)*wb(iq,ms) + bb(1)*wb04,.0007)
>      &    +clay(isoil)*max(aa(2)*wb(iq,ms) + bb(2)*wb04,.0007))*418.
>        scond3 = scond2
>        cap1 = ((1.-ssat(isoil))*2.5e+06 + wb(iq,1)*4.18e+06)
>        cap2 = ((1.-ssat(isoil))*2.5e+06 + wb(iq,ms)*4.18e+06)
>        cap3 = cap2
> 
>        cls=1.
>        if( snowd(iq) .gt. 0. ) then
>            scond1sx = 2.576e-6*ssdn(iq,1)*ssdn(iq,1)+.074
>            cap1sx = ssdn(iq,1) * ( 92.88 + 7.364 * tss(iq) )
>            dsnow = sqrt( 86400. * scond1sx / cap1sx /3.14159)
>            cls=1.+hlfusion/hl
>        endif
>        cfr=min(1.,snowd(iq)/(100.*dsnow))
>        d1=d1land*(1.-cfr)+dsnow*cfr
>        scond1=scond1*(1.-cfr)+scond1sx*cfr
>        cap1=cap1*(1.-cfr)+cap1sx*cfr
>        con1land=d1/scond1
>        con1 = con1land    ! always in sib1
>        con2 = d2 /scond2
>        gamm(iq) =  cap1 * d1
> 
> c      evaluate the scaling evaporation using the Penman-Monteith equation
> c      compute heat capacities
>        dggflux=1.85*2./(con1+con2)
>        ggflux(iq)= (tgg(iq,1)-tgg(iq,2))*dggflux
>        esattg=establ(tgg(iq,1))
>        esatta=establ(t(iq,1))
>        qsttg=.622*esattg/(ps(iq)-esattg)
>        qstta=.622*esatta/(ps(iq)-esatta)
>        dqsttg=qsttg*ps(iq)*hlars/(tgg(iq,1)*tgg(iq,1)*(ps(iq)-
>      &                                                   esattg))
>        wetfac(iq)=max( 0.,min(1.,fle(isoil,wb(iq,1)) ) )
>        rgg(iq) =  stbo*tgg(iq,1)**4
>        dirad(iq)=4.*rgg(iq)/tgg(iq,1)
>        conw_fh=rho(iq)*taftfhg(iq)*hl    ! taftfhg(iq)=aftlandg*fhbg
>      
>        if(nalpha.eq.1)then    ! beta scheme
>          epot(iq) = conw_fh*(qsttg-qg(iq,1))
>          egg(iq)=wetfac(iq)*epot(iq)
>          degdt(iq)=wetfac(iq)*conw_fh*dqsttg
>          degdw(iq)=conw_fh*(qsttg-qg(iq,1))/ssat(isoil)
>        else
> !        following is alpha scheme
>          qtgnet=qsttg*wetfac(iq) -qg(iq,1)
>          qtgair=qsttg*wetfac(iq)-max(qtgnet,.1*qtgnet)
>          qtgairep=qsttg -max(qtgnet,.1*qtgnet)
>          eg2=-conw_fh*qtgair
>          eg2ep = -conw_fh*qtgairep
>          eg1=conw_fh*qsttg
>          degdw(iq)=eg1/ssat(isoil)
> c                                 evaporation from the bare ground
>          egg(iq)=eg1*wetfac(iq) +eg2
>          epot(iq)=eg1 +eg2ep
>          deg=wetfac(iq)*conw_fh*dqsttg
> c        following reduces degdt by factor of 10 for dew
>          degdt(iq)=.55*deg+sign(.45*deg,qtgnet)
>        endif  ! (nalpha.eq.1)
>        dgdw=-degdw(iq)        !not in sib3    *cls for snow too?
> c      egg(iq)=min(egg(iq),wb(iq,1)*1000.*hl/dt)  !** had wb for a while
>        egg(iq)=min(egg(iq),wb(iq,ms)*1000.*hl/dt)
> 
> cgone  if(snowd(iq).gt.1.) egg=tpevap   ! moved up 2 by jlm Wed  01-07-1998
> cgone  if(tpevap.lt.0..and.qsttg.ge.qg(iq,1))egg=0.
> cgone  if(qsttg .lt. qg(iq,1)) egg = tpevap
>        if(snowd(iq).gt.1.) egg(iq)=epot(iq) !moved up 2 by jlm 1-07-1998
>        if(qsttg .lt. qg(iq,1)) egg(iq) = epot(iq)  ! *** not in sib3??
> 
> c                                 sensible heat flux
>        dfgdt(iq)=taftfhg(iq)*rho(iq)*cp
>        fgg(iq)=dfgdt(iq)*(tgg(iq,1)-theta(iq))
>        ga(iq)=-slwa(iq)-rgg(iq)-fgg(iq)-cls*egg(iq)-ggflux(iq)
> c                        calculation of the surface temperature
> c                        is coupled implicitly with the calculation of wg
>        stc=wb(iq,1)/ssat(isoil)
>        dearc1= func1(isoil,stc)
> c      Notes by JMcG: for the 9 soil types, the respective minimum values
> c      for stc are respectively .27, .45, .59, .3, .54, .56, .41, .44, .43
> c      so the first 2 terms of a Taylor series are accurate to within 10%
> cc     pwr=-1.-.5*coefb(isoil)   +4.
> cc     stcm=min(1.-stc, .73)
> cc     dearc1=min( 10. , c1sat(isoil)*( 1.-pwr*stcm*(1.-.5*(pwr-1.)*stcm
> cc   .          *(1.-(pwr-2.)*stcm/3.)) )/stc**4 )
> cc     if(abs(dearc1-dearc1a).gt..1)
> cc   .  print *,'dearc1a,dearc1,iq,isoil,stc,stcm,pwr,c1sat ',
> cc   .           dearc1a,dearc1,iq,isoil,stc,stcm,pwr,c1sat(isoil)
> 
> cgone: cjlm poor:          degdtt = -c1*(dirad(iq)+dggflux)
> cgone: cjlm poor:          degdt(iq) = degdtt*fle(isoil,wb(iq,1))
> cgone:        degdw(iq) = 0.
> cgone:        if(wb(iq,1).lt.swilt(isoil))degdw(iq)=10.*tpevap/ssat(isoil)
> cgone:        if( snowd(iq).gt..01)then
> cgone: cjlm gives wrong sign:            degdt(iq)=degdtt
> cgone:          degdw(iq)=0.
> cgone:        endif
> cgone:        dgdw = -degdw(iq)
>        dgdtg=-(dirad(iq)+dfgdt(iq)+cls*degdt(iq)+dggflux)
> 
>        if(nfeedbk.eq.1)then
>          dfgdt(iq)=0.
>          degdt(iq)=0.
>          degdw(iq)=0.
>          dgdw=0.
>          dgdtg=0.
>        endif
>        if(nfeedbk.eq.2)then
>          degdw(iq)=0.
>          dgdw=0.
>        endif
>        if(nfeedbk.eq.3)then
>          dgdw=0.    ! zero for nalpha=1 in any case
>        endif
> 
> !                 2 for no d/dw terms, 3 for no dg/dw but with dE/dw
>        gbot=gamm(iq)/dt-dgdtg
> c                            calculations of wgp use evaporation only,
> c                            precipitation will be added in surfb
>        c1fact=dearc1*dt/(100.*hl)
>        wbot=1.+c1fact*(dgdw*cls*degdt(iq)/gbot+
>      &                                      degdw(iq))*(1.-tsigmf(iq))
>        wtop=-c1fact*(cls*egg(iq)+cls*degdt(iq)*ga(iq)/gbot)*
>      .              (1.-tsigmf(iq))
>        if(snowd(iq).gt..01)wtop=0.
>        deltaw = wtop/wbot
>        deltat=(ga(iq)+dgdw*deltaw)/gbot
>        wp = max(0., wb(iq,1)+deltaw)
> c              update deep temperatures explicitly, using tau+1 g flux
>        ggflux(iq)=ggflux(iq)+deltat*dggflux
>        gflux23=1.45*(tgg(iq,2)-tgg(iq,ms))*2./(d2/scond2+d3/scond3)
>        fgg(iq)=fgg(iq)+deltat*dfgdt(iq)
>        egg(iq)=egg(iq)+deltat*degdt(iq)+deltaw*degdw(iq)
>        egg(iq)=min(egg(iq),wb(iq,ms)*1000.*hl/dt)
>        tgg(iq,1)=tgg(iq,1)+deltat
>        tgg(iq,2)=tgg(iq,2)+(ggflux(iq)-gflux23)*dt/(cap2*d2)
>        tgg(iq,ms)=tgg(iq,ms)+gflux23*dt/(cap3*d3)
> c
>        rgg(iq)=rgg(iq)+deltat*dirad(iq)
> 
>        condxg=0.
>        if(tsigmf(iq) .le. .01) then
>          evapxf(iq) = egg(iq)
>          fgf(iq)  = fgg(iq)
>          evapf = 0.
>          rdg(iq)=rgg(iq)
>          tgf(iq) = tss(iq)
>        else  !        tsigmf .gt. .01
> c                                             leaf area index
>          rlai= rlaim44(iveg)
>          srlai=rlai
>          rsmin(iq) = rsunc44(iveg)/rlai   ! only done for nvegies=44
> c                                    components of the stomatal resistance
>          sstar = 30.
>          if( zo(iq) .lt. .5 ) sstar = 100.
>          f= 1.1*sgsave(iq)/(rlai*sstar)
> c        f= 1.1*slwa(iq)/(rlai*sstar)
>          rsi = rsmin(iq) * rlai
>          f1= (1.+f)/(f+rsi/5000.)
>          f2=1.0
>          if( wb(iq,ms).le.sfc(isoil))
>      &   f2=max(1.,(sfc(isoil)-swilt(isoil))/
>      &           max( wb(iq,ms)-swilt(isoil),.0000001))
>          f4=max(1.-.0016*(298.-t(iq,1))**2,.05)
>          f124=f1*f2/f4
>          airr = 1./taftfh(iq)
>          cc = condx(iq)
> c        if( cc*(1440./rmstep) .gt.  4.) cc = 4./(1440./rmstep)
>          cc =min(cc, 4./(1440./rmstep))  ! jlm speedup
> c                       depth of the reservoir of water on the canopy
>          rmcmax = max(3.,srlai) * .2
>          omc = rmc(iq)  ! value from previous timestep as starting guess
> 
> c        ncount=0  ! for diags only
>          easss=qg(iq,1)*ps(iq)/.622
>          f3=max(1.-.00025*(esatta-easss),.2)                  ! sib1
>          res(iq)=rsmin(iq)*f124/f3  ! not defined for tsigmf(iq) .le. .01
>          do icount=1,5
> c         ncount=ncount+1  ! for diags only
>           rmc(iq) = omc
>           esatf = establ(tgf(iq))
>           qsatgf=.622*esatf/(ps(iq)-esatf)
> c                                                   wet evaporation
>           Ew = rho(iq)/airr *(qsatgf-qg(iq,1))
>           if(qsatgf.ge.qg(iq,1)) then
>             Ewi  = min(rmc(iq)/dt,rmc(iq)/rmcmax * Ew)
>             rmc(iq) = omc+cc-Ewi*dt
>           else
>             Ewi=Ew
>             rmc(iq)=omc+cc -dt*Ew
>           endif         ! qsatgf.ge.qg(iq,1)
> c                       precipitation reaching the ground under the canopy
> c                                          water interception by the canopy
>           rmc(iq) = min( max(rmc(iq),0.), rmcmax)
>           beta =  min(rmc(iq)/rmcmax,1.)
>           if( qsatgf .lt. qg(iq,1) ) beta = 1.
> c                                          transpiration
>           Etr=rho(iq)/(airr +res(iq))*(qsatgf-qg(iq,1))
>           Ewww(iq) = Ewi
>           evapxf(iq) = ((1.-beta)*Etr + Ewww(iq))*hl
> c                                            sensible heat flux
>           prz = rho(iq)*cp/airr
>           fgf(iq) = prz*(tgf(iq)-theta(iq))
> ! i.e.    fgf(iq) = (tgf(iq)-theta(iq))*rho()*aft(iq)*fh(iq)*cp
>           evapf = (1.-beta)*Etr * dt
> c         tddd = max(Ewww(iq)*dt,0.)                   ! total wet evap.
> 
>           rdg(iq) =  stbo*tgf(iq)**4
>           residf(iq) = -slwa(iq)- rdg(iq)-fgf(iq) - evapxf(iq)
>           if( abs(residf(iq)) .lt. 3. )go to 110
>           dirad1 = 4.*rdg(iq)/tgf(iq)
> c                                                   Calculate dE/dTg
>           dqg=qsatgf*hlars/tgf(iq)**2
>           devf= hl*rho(iq)*dqg*( (1.-beta)/(airr + res(iq))
>      &                        +beta/airr ) ! re-factored by jlm
>           residp = -(dirad1 + devf + prz)
>           sstgf = tgf(iq)
>           tgf(iq)=tgf(iq)-residf(iq)/residp
>           tgf(iq)=min(tgf(iq),sstgf+ 1.)   ! jlm speedup
>           tgf(iq)=max(tgf(iq),sstgf- 1.)   ! jlm speedup
>          enddo   !  icount=1,5
> 110      continue
>          if(condx(iq).gt.0.) condxg=max( condx(iq)-cc+
>      &                                max(0.,rmc(iq)-rmcmax),0.)
>        endif          ! tsigmf .le. .01
> c                                               combined fluxes
>        eg(iq) = tsigmf(iq)*evapxf(iq) + (1. - tsigmf(iq))*egg(iq)
>        if( snowd(iq).gt.1.) eg(iq)=tsigmf(iq)*evapxf(iq) + egg(iq)
>        if(nsigmf.eq.0)fg(iq) = tsigmf(iq)*fgf(iq)
>      .                           +(1. - tsigmf(iq))*fgg(iq)
>        if(nsigmf.eq.1)fg(iq) = tsigmf(iq)*fgf(iq)+ fgg(iq)
>        if(ntest.eq.1.and.iq.eq.idjd)then
>         print *,'further down sib1'
>         print *,'eg,evapxf,egg ',eg(iq),evapxf(iq),egg(iq)
>         print *,'fgf,fgg,fg ',fgf(iq),fgg(iq),fg(iq)
>         print *,'wbot,wtop,wb(iq,1),deltaw ',wbot,wtop,wb(iq,1),deltaw
>         print *,'isoil,ssat,tsigmf,rlai ',
>      .           isoil,ssat(isoil),tsigmf(iq),rlai
>         print *,'qstta,t1,qg1 ',qstta,t(iq,1),qg(iq,1)
>         print *,'theta ',theta(iq)
>         print *,'stc ',stc
>         print *,'deltat,degdt,degdw ',deltat,degdt(iq),degdw(iq)
>         print *,'dfgdt,taftfhg,rho ',dfgdt(iq),taftfhg(iq),rho(iq)
>         print *,'dearc1,dearc2 ',dearc1,dearc2
>        endif
> 
>        if(tsigmf(iq).le. .01) then   ! can these be moved up with other if()?
>          tss(iq) = tgg(iq,1)
>          tgf(iq) = tgg(iq,1)
>        else
>          tss(iq)=tsigmf(iq)*tgf(iq)+(1.-tsigmf(iq))*tgg(iq,1)
>        endif       ! tsigmf.le. .01
> 
> c                                           snow accumulation
>         if(t(iq,2).le.273.1.and.tgg(iq,1).le.273.1)then
>           snowd(iq)=max(snowd(iq) + (1.-tsigmf(iq))*condx(iq)+
>      &              tsigmf(iq)*condxg,0.)
> c         update soil temperatures explicitly for extra snow g fluxes
> c         to allow for freezing of rain at surface
>           snowflx=condx(iq)*hlfusion/dt
>           tgg(iq,1)=tgg(iq,1)+snowflx*dt/gamm(iq)
>           condx(iq)=0.
>           condxg=0.
>         endif
>         smelt=0.
>         evapsn=0.
> 
> C       LAND WITH AND WITHOUT SNOW COVER
>         if(snowd(iq).gt.0.)then
> C         SNOW COVERED LAND
>           evapsn=min(snowd(iq),dt*egg(iq)/hl)
>           snowd(iq)=snowd(iq)-evapsn
>           if(tgg(iq,1).ge.tfrz)then
> c           snow melting
>             snowflx=(tgg(iq,1)-tfrz)*gamm(iq)
> c           prevent snow depth going negative
>             smelt= min(snowflx/hlfusion ,snowd(iq))
>             snowd(iq)=snowd(iq)-smelt
>             tgg(iq,1)= tgg(iq,1)-smelt*hlfusion/gamm(iq)
>           endif
>         endif
>         totwet=(1.-tsigmf(iq))*condx(iq)+smelt
>      .           + tsigmf(iq)*condxg ! total wetness
>         rnof1=0.       ! always zero   why?
>         weting=totwet-rnof1
> 
>         wp=wp+dearc1*weting/100.-dearc2*(wb(iq,1)-wb(iq,ms))
> cc----  update ground wetness time levels (forward adjustment
>         wb(iq,1)=max(wp,.01)
>         wb(iq,1)=min(ssat(isoil) , wb(iq,1))
> c       new drainage scheme for wb
>         dwb=0.
>         if( tgg(iq,2).gt. 273.1.and.tgg(iq,ms).gt.273.1)
>      &  dwb=max(wb(iq,ms)-min(sfc(isoil)+.05,ssat(isoil)),0.)*
>      &       c3(isoil)*1000./1000./86400.    !  min added Wed  07-05-1995
>         rnof2=1000.*dwb*dt
> c                                                   bulk moisture
>         segg=egg(iq)
>         if(evapsn.gt.0.) segg=0.
>         wbtp1=max(0. , wb(iq,ms)+weting/1000.-segg*dt/(1000.*hl)*
>      &       (1.-tsigmf(iq))-dwb*dt - evapf*tsigmf(iq)/1000.)
> c       if ground saturated, then runoff
>         rnof3=1000.*max(wbtp1-ssat(isoil),0.)
>         wb(iq,ms)=min(wbtp1,ssat(isoil))
>         wb(iq,ms)=max(wb(iq,ms),.01)
> c                                                   surface moisture
>         runoff(iq)=runoff(iq)+rnof1+rnof2+rnof3
>         tss(iq)=tsigmf(iq)*tgf(iq)+(1.-tsigmf(iq))*tgg(iq,1)
> 
> !       if(ngas.gt.0)stop 'call co2sflux'
> 681   continue   !  end of land loop
> 
> c      if(mstn.eq.2)then
> c        if(ktau.eq.kstart)then
> c         if(nstn.gt.0)then
> c           fname0(1:4)='noct'
> c           fname0(10:10)='.'
> c           write(fname0(4:9),'(i6)')kdate
> c           do nn=1,nstn
> c            write(fname0(11:12),'(i2)')iunp(nn)
> c            open(iunp(nn),file=fname0,form='formatted',status='unknown')
> c           enddo
> c          do nn=1,nstn2
> c           write(fname0(11:12),'(i2)')iunp2(nn)
> c           open(iunp2(nn),file=fname0,form='formatted',status='unknown')
> c          enddo
> c         endif    ! (nstn.gt.0)
> c        endif         ! (ktau.eq.kstart)then
> c        if(nstn.gt.0)then  ! special writes for land points
> c          do nn=1,nstn
> c           i=istn(nn)
> c           j=jstn(nn)
> cc          do k=1,kl
> cc           thetar(k)=t(i,j,k)/sig(k)**(r/cp)
> cc          enddo
> c           cls=1.
> c           if( snowd(iq) .gt. 0. ) then
> c             scond1sx = 2.576e-6*ssdn(iq,1)*ssdn(iq,1)+.074
> c             cap1sx = ssdn(iq,1) * ( 92.88 + 7.364 * tss(iq) )
> c             dsnow = sqrt( 86400. * scond1sx / cap1sx /3.14159)
> c             cls=1.+hlfusion/hl
> c           endif
> c           write(iunp(nn),8447) kdate,ktau,i,j,
> c     &     tss(i,j),tgf(i,j),tgg(i+(j-1)*il,2),tgg(i+(j-1)*il,ms)
> c     &    ,t(i,j,1),t(i,j,2),qg(i,j,1),qg(i,j,2),ps(i,j),
> c     &     u(i-1,j,1),u(i,j,1),v(i,j-1,1),v(i,j,1),
> c     &     (tr(i,j,l,1),l=1,11),(tr(i,j,l,2),l=1,11),
> c     &     condx(i,j),wb(i+(j-1)*il,1),wb(i+(j-1)*il,ms)
> c8447       format(i7,i5,i3,i2,7f6.1,2f7.4,f8.0,4f6.1,11f6.1,11f6.1,
> c     &     f7.3,2f7.3)
> c          enddo  ! nn=1,nstn
> c          do nn=1,nstn2   ! nnstn2 usually set to 3 in trcom2.h
> c           i=istn2(nn)
> c           j=jstn2(nn)
> c           write(iunp2(nn),8446) kdate,timeg,ktau,i,j,
> c     &      tss(i,j),t(i,j,1),t(i,j,2),qg(i,j,1),qg(i,j,2),ps(i,j),
> c     &      u(i-1,j,1),u(i,j,1),v(i,j-1,1),v(i,j,1),
> c     &      (tr(i,j,l,iRADON),l=1,11),(tr(i,j,l,iCO2),l=1,11)
> c     &      ,condx(i,j)
> c8446       format(i7,f4.1,i5,i3,i2,3f6.1,2f7.4,f8.0,4f5.1,
> c     &      11f6.1,11f6.1,f7.3,f5.2,f6.1,3f6.1,f6.1)
> c          enddo  ! nn=1,nstn2
> c        endif    ! (nstn.gt.0)
> c      endif      ! (mstn.eq.2)
>       return
>       end
> 
663a1170
>       include 'aalat.h'    ! slwa
685c1192
<      . ,factch(ifull),qsttg(ifull),rho(ifull),zo(ifull)
---
>      . ,factch(ifull),rsts(ifull),rho(ifull),zo(ifull)
693,700c1200,1202
<      . dum3(5*ijk-20*ifull)
<       common/work3c/airr(ifull),cc(ifull),condxg(ifull),delta_tx(ifull),
<      . evapfb1(ifull),evapfb2(ifull),evapfb3(ifull),evapfb4(ifull),
<      . evapfb5(ifull),evapfb1a(ifull),evapfb2a(ifull),evapfb3a(ifull),
<      . evapfb4a(ifull),evapfb5a(ifull),otgf(ifull),rmcmax(ifull),
<      . tgfnew(ifull),evapfb(ifull)
<       common/work3d/dqsttg(ifull),tstom(ifull),rlai(ifull),
<      .   cls(ifull),omc(ifull),dum3d(ijk-5*ifull)  ! allows L9
---
>      . dum3(2*ijk-20*ifull),uav(ifull,kl),vav(ifull,kl)
>       common/work3d/qsttg(ifull),dqsttg(ifull),tstom(ifull),rlai(ifull),
>      .   cls(ifull),dum3d(ijk-5*ifull)  ! allows L9
729c1231
<       if(ktau.eq.1)then
---
>       if(ktau.eq.kstart)then
761c1263
<         rsmin(idjd)=rsunc44(iveg)/rlai_d ! now always done
---
>         if(rlai_d.ne.0.)rsmin(idjd)=rsunc44(iveg)/rlai_d ! now always done
763c1265
<       endif           ! (ktau.eq.1)
---
>       endif           ! (ktau.eq.kstart)
767c1269
< c      following loop needed to be split off from the one after it
---
> c      following loop needs to be split off from the one after it
786d1287
< !cdir nodep
796c1297
<        tsigmf(iq)=max(.001,  sigmf(iq)-scveg44(iveg)*(1.-ftsoil)) ! 13/5/03
---
>        tsigmf(iq)=max(0.,  sigmf(iq)-scveg44(iveg)*(1.-ftsoil))
809d1309
< !cdir nodep
814,816c1314
< !      extin(iq)=exp(-0.6*max(1.,rlai(iq)))  ! good approx uses next 2 (jlm)
< 	xxx=.6*max(1.,rlai(iq))
< 	extin(iq)=1.-xxx/(1. +.5*xxx +xxx*xxx/12.) 
---
>        extin(iq)=exp(-0.6*max(1.,rlai(iq)))
921d1418
< !cdir nodep
1043a1541,1550
> c      if(ktau.gt.1)then  ! to reduce risk of oscillations, esp. over snow
> c        do ip=1,ipland  
> c         dgdtg(iq)=.5*(dgdtg(iq)+dgdtgsav(iq))
> c        enddo   ! ip=1,ipland
> c      endif
> c      do ip=1,ipland  ! save for next time stop
> c       dgdtgsav(iq)=dgdtg(iq)
> c      enddo   ! ip=1,ipland
>  
> c     print *,'before main loop'
1045,1046d1551
< ! ----------------------------------------------
<       if(itnmeth.eq.0) then  ! old, not vectorized
1048,1051c1553,1565
<        do ip=1,ipland  ! all land points in this nsib=3 loop
<         iq=iperm(ip)
<         isoil = isoilm(iq)
<         iveg=ivegt(iq)
---
>       do ip=1,ipland  ! all land points in this nsib=3 loop
>        iq=iperm(ip)
>        isoil = isoilm(iq)
>        iveg=ivegt(iq)
>        condxg=0.
>        if(tsigmf(iq) .le. .0101) then
>          evapxf(iq) = egg(iq)
>          fgf(iq)  = fgg(iq)
>          evapf = 0.
>          rdg(iq)=rgg(iq)
>          tgf(iq) = tss(iq)
>          Ewww(iq) = 0.
>        else  !        tsigmf .gt. .01
1053,1063c1567,1577
<           srlai=rlai(iq)+rlais44(iveg)
<           rsmin(iq) = rsunc44(iveg)/rlai(iq)   ! now always done
< c                                    components of the stomatal resistance
<           sstar = 30.
<           if( zo(iq) .lt. .5 ) sstar = 150.
<           f= 1.1*sgsave(iq)/(rlai(iq)*sstar)
< c         f= 1.1*slwa(iq)/(rlai(iq)*sstar)
<           rsi = rsmin(iq) * rlai(iq)
<           f1= (1.+f)/(f+rsi/5000.)
<           den=sfc(isoil)-swilt(isoil)                          ! sib3
<           wbav=(max(0.,froot(1)*(wb(iq,1)-swilt(isoil)))+
---
>          srlai=rlai(iq)+rlais44(iveg)
>          rsmin(iq) = rsunc44(iveg)/rlai(iq)   ! now always done
> c                                    components of the atal resistance
>          sstar = 30.
>          if( zo(iq) .lt. .5 ) sstar = 150.
>          f= 1.1*sgsave(iq)/(rlai(iq)*sstar)
> c        f= 1.1*slwa(iq)/(rlai(iq)*sstar)
>          rsi = rsmin(iq) * rlai(iq)
>          f1= (1.+f)/(f+rsi/5000.)
>          den=sfc(isoil)-swilt(isoil)                          ! sib3
>          wbav=(max(0.,froot(1)*(wb(iq,1)-swilt(isoil)))+
1068,1073c1582,1587
<           f2=max(1. , .5/ max( wbav,1.e-7)) ! N.B. this is equiv to next 2 (jlm)
< c         f2=1.0
< c         if(wbav.lt.0.5) f2=max(1.0 , 0.5/ max( wbav,1.e-7))
<           f4=max(1.-.0016*(tstom(iq)-t(iq,1))**2 , .05) ! zero for delta_t=25
<           airr(iq) = 1./taftfh(iq)
<           cc(iq) =min(condx(iq) , 4./(1440./rmstep))  ! jlm speedup
---
>          f2=max(1. , .5/ max( wbav,1.e-7)) ! N.B. this is equiv to next 2 (jlm)
> c        f2=1.0
> c        if(wbav.lt.0.5) f2=max(1.0 , 0.5/ max( wbav,1.e-7))
>          f4=max(1.-.0016*(tstom(iq)-t(iq,1))**2 , .05) ! zero for delta_t=25
>          airr = 1./taftfh(iq)
>          cc =min(condx(iq) , 4./(1440./rmstep))  ! jlm speedup
1075,1077c1589,1591
<           rmcmax(iq) = max(0.5,srlai) * .1
<           omc(iq) = rmc(iq)  ! value from previous timestep as starting guess
<           f3=max(1.-.00025*(establ(t(iq,1))-qg(iq,1)*ps(iq)/.622)
---
>          rmcmax = max(0.5,srlai) * .1
>          omc = rmc(iq)  ! value from previous timestep as starting guess
>          f3=max(1.-.00025*(establ(t(iq,1))-qg(iq,1)*ps(iq)/.622)
1079,1080c1593,1594
<           res(iq)=max(30.,rsmin(iq)*f1*f2/(f3*f4))
<           if(ntest.eq.1.and.iq.eq.idjd)then
---
>          res(iq)=max(30.,rsmin(iq)*f1*f2/(f3*f4))
>          if(ntest.eq.1.and.iq.eq.idjd)then
1084c1598
<           endif
---
>          endif
1086c1600,1601
<           otgf(iq)=tgf(iq)
---
>          otgf=tgf(iq)
>          if(itnmeth.eq.0)then  
1089c1604
<             rmc(iq) = omc(iq)
---
>             rmc(iq) = omc
1095c1610
<               Ewww(iq)  = min(rmc(iq)/dt , rmc(iq)*Ewww(iq)/rmcmax(iq) )
---
>               Ewww(iq)  = min(rmc(iq)/dt , rmc(iq)*Ewww(iq)/rmcmax )
1097c1612
<             rmc(iq)=omc(iq)+cc(iq) -Ewww(iq)*dt
---
>             rmc(iq)=omc+cc -Ewww(iq)*dt
1100,1104c1615,1617
<             condxg(iq)=max(condx(iq)-cc(iq)+
<      .                 max(0.,rmc(iq)-rmcmax(iq)),0.) ! keep here
<             rmc(iq) = min( max(rmc(iq),0.), rmcmax(iq))
< !           beta =  min(rmc(iq)/rmcmax(iq),1.)   ! not needed
<             beta =      rmc(iq)/rmcmax(iq)
---
>             rmc(iq) = min( max(rmc(iq),0.), rmcmax)
> !           beta =  min(rmc(iq)/rmcmax,1.)   ! not needed
>             beta =      rmc(iq)/rmcmax
1107c1620
<             Etr=rho(iq)/(airr(iq) +res(iq))*(qsatgf-qg(iq,1))
---
>             Etr=rho(iq)/(airr +res(iq))*(qsatgf-qg(iq,1))
1109,1121c1622,1634
<             evapfb1(iq)=min(betetrdt*froot(1),max(0.,
<      &                  (wb(iq,1)-swilt(isoil))*zse(1)*1000.))
<             evapfb2(iq)=min(betetrdt*froot(2),max(0.,
<      &                  (wb(iq,2)-swilt(isoil))*zse(2)*1000.))
<             evapfb3(iq)=min(betetrdt*froot(3),max(0.,
<      &                  (wb(iq,3)-swilt(isoil))*zse(3)*1000.))
<             evapfb4(iq)=min(betetrdt*froot(4),max(0.,
<      &                  (wb(iq,4)-swilt(isoil))*zse(4)*1000.))
<             evapfb5(iq)=min(betetrdt*froot(5),max(0.,
<      &                  (wb(iq,5)-swilt(isoil))*zse(5)*1000.))
<             evapfb(iq)=(evapfb1(iq)+evapfb2(iq)+evapfb3(iq)+evapfb4(iq)+
<      &                  evapfb5(iq))/tsigmf(iq)
<             evapxf(iq) = (evapfb(iq)/dt + Ewww(iq))*hl
---
>             evapfb1=min(betetrdt*froot(1),max(0.,
>      &              (wb(iq,1)-swilt(isoil))*zse(1)*1000.))
>             evapfb2=min(betetrdt*froot(2),max(0.,
>      &              (wb(iq,2)-swilt(isoil))*zse(2)*1000.))
>             evapfb3=min(betetrdt*froot(3),max(0.,
>      &              (wb(iq,3)-swilt(isoil))*zse(3)*1000.))
>             evapfb4=min(betetrdt*froot(4),max(0.,
>      &              (wb(iq,4)-swilt(isoil))*zse(4)*1000.))
>             evapfb5=min(betetrdt*froot(5),max(0.,
>      &              (wb(iq,5)-swilt(isoil))*zse(5)*1000.))
> 
>             evapfb=(evapfb1+evapfb2+evapfb3+evapfb4+evapfb5)/tsigmf(iq)
>             evapxf(iq) = (evapfb/dt + Ewww(iq))*hl
1138,1139c1651,1652
<             devf= hl*rho(iq)*dqg*( (1.-beta)/(airr(iq) + res(iq))
<      &                          +beta/airr(iq) ) ! re-factored by jlm
---
>             devf= hl*rho(iq)*dqg*( (1.-beta)/(airr + res(iq))
>      &                          +beta/airr ) ! re-factored by jlm
1144,1145c1657
<               print *,'icount,omc,rmc,otgf ',
<      .                 icount,omc(iq),rmc(iq),otgf(iq)
---
>               print *,'icount,omc,rmc,otgf ',icount,omc,rmc(iq),otgf
1153,1155c1665,1667
<            if(ntest.eq.1)print *,'iq,otgf(iq),tgf,residf '
<      .                           ,iq,otgf(iq),tgf(iq),residf(iq)
< c          tgf(iq)=0.5*(otgf(iq)+tgf(iq))
---
>            if(ntest.eq.1)print *,'iq,otgf,tgf,residf '
>      .                           ,iq,otgf,tgf(iq),residf(iq)
> c          tgf(iq)=0.5*(otgf+tgf(iq))
1157,1210c1669,1677
<        enddo  !  ip=1,ipland
<       endif  ! (itnmeth.eq.0) 
< 
< 
<       if(itnmeth.gt.0) then  ! new, vectorized
< !cdir nodep
<        do ip=1,ipland  ! all land points in this nsib=3 loop
<         iq=iperm(ip)
<         isoil = isoilm(iq)
<         iveg=ivegt(iq)
< c                                          leaf area index
<         srlai=rlai(iq)+rlais44(iveg)
<         rsmin(iq) = rsunc44(iveg)/rlai(iq)   ! now always done
< c                                  components of the stomatal resistance
< !       sstar = 30.
< !       if( zo(iq) .lt. .5 ) sstar = 150.
< 	 sstar=90.+sign(60.,.5-zo(iq))  ! equiv to above 2 lines
<         f= 1.1*sgsave(iq)/(rlai(iq)*sstar)
< c       f= 1.1*slwa(iq)/(rlai(iq)*sstar)
<         rsi = rsmin(iq) * rlai(iq)
<         f1= (1.+f)/(f+rsi/5000.)
<         den=sfc(isoil)-swilt(isoil)                          ! sib3
<         wbav=(max(0.,froot(1)*(wb(iq,1)-swilt(isoil)))+
<      &        max(0.,froot(2)*(wb(iq,2)-swilt(isoil)))+
<      &        max(0.,froot(3)*(wb(iq,3)-swilt(isoil)))+
<      &        max(0.,froot(4)*(wb(iq,4)-swilt(isoil)))+
<      &        max(0.,froot(5)*(wb(iq,5)-swilt(isoil)))   )/den
<         f2=max(1. , .5/ max( wbav,1.e-7)) ! N.B. this is equiv to next 2 (jlm)
< c       f2=1.0
< c       if(wbav.lt.0.5) f2=max(1.0 , 0.5/ max( wbav,1.e-7))
<         f4=max(1.-.0016*(tstom(iq)-t(iq,1))**2 , .05) ! zero for delta_t=25
<         airr(iq) = 1./taftfh(iq)
<         cc(iq) =min(condx(iq) , 4./(1440./rmstep))  ! jlm speedup
< c                     depth of the reservoir of water on the canopy
<         rmcmax(iq) = max(0.5,srlai) * .1
<         omc(iq) = rmc(iq)  ! value from previous timestep as starting guess
<         f3=max(1.-.00025*(establ(t(iq,1))-qg(iq,1)*ps(iq)/.622)
<      .                                                        ,.05)
<         res(iq)=max(30.,rsmin(iq)*f1*f2/(f3*f4))
<         if(ntest.eq.1.and.iq.eq.idjd)then
<           print *,'rlai,srlai,wbav,den ',rlai(iq),srlai,wbav,den
<           print *,'f1,f2,f3,f4 ',f1,f2,f3,f4
<           print *,'f,f124,rsi,res ',f,f1*f2/f4,rsi,res(iq)
<         endif
<         otgf(iq)=tgf(iq)
<         tgfnew(iq)=tgf(iq)
<         delta_tx(iq)=10.   ! just to supply max change of 5 deg first time
<         evapfb1a(iq)=max(0.,wb(iq,1)-swilt(isoil)) *zse(1)*1000.
<         evapfb2a(iq)=max(0.,wb(iq,2)-swilt(isoil)) *zse(2)*1000.
<         evapfb3a(iq)=max(0.,wb(iq,3)-swilt(isoil)) *zse(3)*1000.
<         evapfb4a(iq)=max(0.,wb(iq,4)-swilt(isoil)) *zse(4)*1000.
<         evapfb5a(iq)=max(0.,wb(iq,5)-swilt(isoil)) *zse(5)*1000.
<        enddo
<        do icount=1,itnmeth     ! jlm new iteration
---
>          else                      ! faster itnmeth=1+ section
>            tgfnew=tgf(iq)
>            delta_tx=10.   ! just to supply max change of 5 deg first time
>            evapfb1a=max(0.,wb(iq,1)-swilt(isoil)) *zse(1)*1000.
>            evapfb2a=max(0.,wb(iq,2)-swilt(isoil)) *zse(2)*1000.
>            evapfb3a=max(0.,wb(iq,3)-swilt(isoil)) *zse(3)*1000.
>            evapfb4a=max(0.,wb(iq,4)-swilt(isoil)) *zse(4)*1000.
>            evapfb5a=max(0.,wb(iq,5)-swilt(isoil)) *zse(5)*1000.
>            do icount=1,itnmeth     ! jlm new iteration
1212,1310c1679,1761
< !cdir nodep
<         do ip=1,ipland  ! all land points in this nsib=3 loop
<          iq=iperm(ip)
<          esatf = establ(tgfnew(iq))
<          qsatgf=.622*esatf/(ps(iq)-esatf)
< c                                                  wet evaporation
<          Ewww(iq) = rho(iq) *(qsatgf-qg(iq,1))/airr(iq)
< !        if(qsatgf.ge.qg(iq,1)) then  ! no dew
< !          Ewww(iq)  = min(omc(iq)/dt , Ewww(iq)*omc(iq)/rmcmax(iq) )
< !        endif         ! qsatgf.ge.qg(iq,1)
< !        above 3 lines are equivalent to:
<          Ewww(iq)=min(Ewww(iq),omc(iq)/dt,Ewww(iq)*omc(iq)/rmcmax(iq))
< !                        dew(-ve)  no_dew          no_dew
< !        rmc is reservoir on leaf
<          rmc(iq)=omc(iq)+cc(iq) -Ewww(iq)*dt
< c                      precipitation reaching the ground under the canopy
< c                                         water interception by the canopy
<          condxg(iq)=max(condx(iq)-cc(iq)+max(0.,rmc(iq)-rmcmax(iq)),0.) ! keep 
<          rmc(iq) = min( max(0.,rmc(iq)), rmcmax(iq))
< !        beta =  min(rmc(iq)/rmcmax(iq),1.)   ! min not needed
<          beta =      rmc(iq)/rmcmax(iq)
< !!       if( qsatgf .lt. qg(iq,1) ) beta = 1.   ! i.e. dew
<          Etr=rho(iq)*(qsatgf-qg(iq,1))/(airr(iq) +res(iq))
<          Etr=rho(iq)*max(0.,qsatgf-qg(iq,1))/(airr(iq) +res(iq))  ! jlm
<          betetrdt =(1.-beta)*Etr*dt*tsigmf(iq)   ! fixed 23/5/01
<          evapfb1(iq)=min(betetrdt*froot(1),evapfb1a(iq))
<          evapfb2(iq)=min(betetrdt*froot(2),evapfb2a(iq))
<          evapfb3(iq)=min(betetrdt*froot(3),evapfb3a(iq))
<          evapfb4(iq)=min(betetrdt*froot(4),evapfb4a(iq))
<          evapfb5(iq)=min(betetrdt*froot(5),evapfb5a(iq))
<          evapfb(iq)=(evapfb1(iq)+evapfb2(iq)+evapfb3(iq)+evapfb4(iq)+
<      &               evapfb5(iq))/tsigmf(iq)
<          evapxf(iq) = (evapfb(iq)/dt + Ewww(iq))*hl  ! converting to W/m**2
<          prz = rho(iq)*cp*taftfh(iq)
<          if(newfgf.eq.0)fgf(iq) = prz*(tgfnew(iq)-theta(iq))  ! original
<          if(newfgf.eq.1)fgf(iq) = prz*(tgfnew(iq)-tscrn(iq))
<          if(newfgf.eq.2)fgf(iq)=rho(iq)*aft(iq)*cp*
<      .                             (tgfnew(iq)-tscrn(iq))
<          rdg(iq) =  stbo*tgfnew(iq)**4
<          residf(iq) = -slwa(iq) - rdg(iq) - fgf(iq) - evapxf(iq)
<          dirad1 = 4.*rdg(iq)/300.
< !        next 2 expressions can be approximated without effects
< c        dqg=qsatgf*hlars/300.**2
< ca       devf= hl*rho(iq)*dqg*( (1.-beta)/(airr(iq) + res(iq))
< ca   &                       +beta/airr(iq) ) ! re-factored by jlm
< !        according to jlm prints, devf has only small effect
<          devf= (hl*hlars/300.**2)*qsatgf*(1.-beta)/res(iq)
<          delta_t0=residf(iq)/(dirad1 + devf + prz)
< !!       delta_t=sign(min(abs(delta_t0),5.),delta_t0) ! max 5 deg 1st it
< !!       following lines assist convergence sometimes
< !!       if(icount.gt.1)then
< !!         delta_t=sign(min(abs(delta_t),                    !  jlmnew
< !!   .                     .5*abs(tgfnew(iq)-tgf(iq))) , delta_t0)
< !!       endif      ! icount.gt.1
< !        above few lines equivalent to next one:
<          delta_t=sign(min(abs(delta_t0),.5*abs(delta_tx(iq))),delta_t0)
<          tgfnew(iq)=tgfnew(iq)+delta_t
<          delta_tx(iq)=tgfnew(iq)-tgf(iq)
<          if(ntest.eq.1.and.iq.eq.idjd)then
<            print *,'icount,iq,omc(iq),rmc ',icount,iq,omc(iq),rmc(iq)
<            print *,'theta,tscrn,slwa ',
<      .              theta(iq),tscrn(iq),slwa(iq)
<            print *,'taftfh,condxg(iq) ',taftfh(iq),condxg(iq)
<            print *,'Ewww,Etr,evapfb ',Ewww(iq),Etr,evapfb(iq)
<            print *,'rdg,fgf,evapxf ',
<      .              rdg(iq),fgf(iq),evapxf(iq)
<            print *,'dirad1,devf,prz ',dirad1,devf,prz
<            print *,'beta,airr(iq),res ',beta,airr(iq),res(iq)
<            print *,'delta_t0,delta_t ',
<      .              delta_t0,delta_t
<            print *,'otgf(iq),tgfnew(iq),residf ',
<      .              otgf(iq),tgfnew(iq),residf(iq)
<          endif
< 	 enddo  ! ip loop
<        enddo   !  icount=1,5
<       endif    ! (itnmeth.gt.0) 
< 
< !cdir nodep
<       do ip=1,ipland  ! all land points in this nsib=3 loop
<        iq=iperm(ip)
<        if(tsigmf(iq) .le. .0101) then
<          condxpr(iq)=condx(iq)
<          evapfb(iq) = 0.
<          evapxf(iq) = egg(iq)
<          fgf(iq)  = fgg(iq)
<          rdg(iq)=rgg(iq)
<           tgf(iq) = tss(iq)
<           Ewww(iq) = 0.
<        else
<          tgf(iq)=tgfnew(iq)
<          wb(iq,1)=wb(iq,1)-evapfb1(iq)/(zse(1)*1000.)
<          wb(iq,2)=wb(iq,2)-evapfb2(iq)/(zse(2)*1000.)
<          wb(iq,3)=wb(iq,3)-evapfb3(iq)/(zse(3)*1000.)
<          wb(iq,4)=wb(iq,4)-evapfb4(iq)/(zse(4)*1000.)
<          wb(iq,5)=wb(iq,5)-evapfb5(iq)/(zse(5)*1000.)
<          condxpr(iq)=(1.-tsigmf(iq))*condx(iq)+ tsigmf(iq)*condxg(iq)
<          if(ntest.eq.1.and.abs(residf(iq)).gt.3.)
<      .      print *,'iq,otgf(iq),tgf,delta_tx,residf '
<      .              ,iq,otgf(iq),tgf(iq),delta_tx(iq),residf(iq)
---
>             esatf = establ(tgfnew)
>             qsatgf=.622*esatf/(ps(iq)-esatf)
> c                                                     wet evaporation
>             Ewww(iq) = rho(iq) *(qsatgf-qg(iq,1))/airr
> !           if(qsatgf.ge.qg(iq,1)) then  ! no dew
> !             Ewww(iq)  = min(omc/dt , Ewww(iq)*omc/rmcmax )
> !           endif         ! qsatgf.ge.qg(iq,1)
> !           above 3 lines are equivalent to:
>             Ewww(iq)  = min(Ewww(iq), omc/dt , Ewww(iq)*omc/rmcmax ) ! jlm
> !                           dew(-ve)  no_dew          no_dew
> !           rmc is reservoir on leaf
>             rmc(iq)=omc+cc -Ewww(iq)*dt
> c                         precipitation reaching the ground under the canopy
> c                                            water interception by the canopy
>             condxg=max(condx(iq)-cc+max(0.,rmc(iq)-rmcmax) , 0.) ! keep here
>             rmc(iq) = min( max(0.,rmc(iq)), rmcmax)
> !           beta =  min(rmc(iq)/rmcmax,1.)   ! min not needed
>             beta =      rmc(iq)/rmcmax
> !!          if( qsatgf .lt. qg(iq,1) ) beta = 1.   ! i.e. dew
> 
> !!          Etr=rho(iq)*(qsatgf-qg(iq,1))/(airr +res(iq))
>             Etr=rho(iq)*max(0.,qsatgf-qg(iq,1))/(airr +res(iq))  ! jlm
>             betetrdt =(1.-beta)*Etr*dt*tsigmf(iq)   ! fixed 23/5/01
>             evapfb1=min(betetrdt*froot(1),evapfb1a)
>             evapfb2=min(betetrdt*froot(2),evapfb2a)
>             evapfb3=min(betetrdt*froot(3),evapfb3a)
>             evapfb4=min(betetrdt*froot(4),evapfb4a)
>             evapfb5=min(betetrdt*froot(5),evapfb5a)
> 
>             evapfb=(evapfb1+evapfb2+evapfb3+evapfb4+evapfb5)/tsigmf(iq) ! in mm water
>             evapxf(iq) = (evapfb/dt + Ewww(iq))*hl  ! converting to W/m**2
>             prz = rho(iq)*cp*taftfh(iq)
>             if(newfgf.eq.0)fgf(iq) = prz*(tgfnew-theta(iq))  ! original
>             if(newfgf.eq.1)fgf(iq) = prz*(tgfnew-tscrn(iq))
>             if(newfgf.eq.2)fgf(iq)=rho(iq)*aft(iq)*cp*
>      .                                (tgfnew-tscrn(iq))
>             rdg(iq) =  stbo*tgfnew**4
>             residf(iq) = -slwa(iq) - rdg(iq) - fgf(iq) - evapxf(iq)
>             dirad1 = 4.*rdg(iq)/300.
> !           next 2 expressions can be approximated without effects
> c           dqg=qsatgf*hlars/300.**2
> ca          devf= hl*rho(iq)*dqg*( (1.-beta)/(airr + res(iq))
> ca   &                          +beta/airr ) ! re-factored by jlm
> !           according to jlm prints, devf has only small effect
>             devf= (hl*hlars/300.**2)*qsatgf*(1.-beta)/res(iq)
>             delta_t0=residf(iq)/(dirad1 + devf + prz)
> !!          delta_t=sign(min(abs(delta_t0),5.),delta_t0) ! max 5 deg 1st it
> !!          following lines assist convergence sometimes
> !!          if(icount.gt.1)then
> !!            delta_t=sign(min(abs(delta_t),                    !  jlmnew
> !!   .                        .5*abs(tgfnew-tgf(iq))) , delta_t0)
> !!          endif      ! icount.gt.1
> !           above few lines equivalent to next one:
>             delta_t=sign(min(abs(delta_t0),.5*abs(delta_tx)) , delta_t0)
>             tgfnew=tgfnew+delta_t
>             delta_tx=tgfnew-tgf(iq)
>             if(ntest.eq.1.and.iq.eq.idjd)then
>               print *,'icount,iq,omc,rmc ',icount,iq,omc,rmc(iq)
>               print *,'theta,tscrn,slwa ',
>      .                 theta(iq),tscrn(iq),slwa(iq)
>               print *,'taftfh,condxg ',taftfh(iq),condxg
>               print *,'Ewww,Etr,evapfb ',Ewww(iq),Etr,evapfb
>               print *,'rdg,fgf,evapxf ',
>      .                 rdg(iq),fgf(iq),evapxf(iq)
>               print *,'dirad1,devf,prz ',dirad1,devf,prz
>               print *,'beta,airr,res ',beta,airr,res(iq)
>               print *,'delta_t0,delta_t ',
>      .                 delta_t0,delta_t
>               print *,'otgf,tgfnew,residf ',otgf,tgfnew,residf(iq)
>             endif
>            enddo   !  icount=1,5
>            tgf(iq)=tgfnew
>            if(ntest.eq.1.and.abs(residf(iq)).gt.3.)
>      .       print *,'iq,otgf,tgf,delta_t,residf '
>      .               ,iq,otgf,tgf(iq),delta_t,residf(iq)
>          endif   !  (itnmeth.eq.0 ... else ...
> !        following lines moved from soilsnow   23/5/01
>          wb(iq,1)=wb(iq,1)-evapfb1/(zse(1)*1000.)
>          wb(iq,2)=wb(iq,2)-evapfb2/(zse(2)*1000.)
>          wb(iq,3)=wb(iq,3)-evapfb3/(zse(3)*1000.)
>          wb(iq,4)=wb(iq,4)-evapfb4/(zse(4)*1000.)
>          wb(iq,5)=wb(iq,5)-evapfb5/(zse(5)*1000.)
> c        evapf =  evapfb
1312,1313c1763,1771
<        fev(iq)=evapfb(iq)/dt*hl*tsigmf(iq) ! passed to soilsnow to update wb
<        fes(iq)=(1.-tsigmf(iq))*egg(iq)*cls(iq)  ! also passed to soilsnow
---
> 
>        fev(iq)=evapfb/dt*hl*tsigmf(iq) ! passed to soilsnow to update wb
>        fes(iq)=(1.-tsigmf(iq))*egg(iq)*cls(iq)    ! 9/5/02
>        condxpr(iq)=(1.-tsigmf(iq))*condx(iq)+ tsigmf(iq)*condxg
> !      if(isflag(iq).eq.1)then
> !        otgsoil(iq)=tggsn(iq,1)
> !      else
> !        otgsoil(iq)=tgg(iq,1)
> !      endif        ! replace these by:
1316,1329c1774,1785
<          isoil = isoilm(iq)
<          iveg=ivegt(iq)
<          print *,'in sib3 before soilsnowv'
<          print *,'evapxf,epot,egg,fev,wetfac '
<      .           ,evapxf(iq),epot(iq),egg(iq),fev(iq),wetfac(iq)
<          print *,'fgf,fgg,fes ',fgf(iq),fgg(iq),fes(iq)
<          print *,'isoil,ssat,tsigmf,rlai ',
<      .            isoil,ssat(isoil),tsigmf(iq),rlai(iq)
<          print *,'tgg1,t1,theta,tscrn '
<      .           ,tgg(iq,1),t(iq,1),theta(iq),tscrn(iq)
<          print *,'qg1,qsttg,Ewww '
<      .           ,qg(iq,1),qsttg(iq),Ewww(iq)
<          print *,'dfgdt,taftfhg,rho ',dfgdt(iq),taftfhg(iq),rho(iq)
<          print *,'rmc,rmcmax(iq),qsatgf ',rmc(iq),rmcmax(iq),qsatgf
---
>         print *,'in sib3 before soilsnowv'
>         print *,'evapxf,epot,egg,fev,wetfac '
>      .       ,evapxf(iq),epot(iq),egg(iq),fev(iq),wetfac(iq)
>         print *,'fgf,fgg,fes ',fgf(iq),fgg(iq),fes(iq)
>         print *,'isoil,ssat,tsigmf,rlai ',
>      .           isoil,ssat(isoil),tsigmf(iq),rlai(iq)
>         print *,'tgg1,t1,theta,tscrn '
>      .          ,tgg(iq,1),t(iq,1),theta(iq),tscrn(iq)
>         print *,'qg1,qsttg,Ewww '
>      .          ,qg(iq,1),qsttg(iq),Ewww(iq)
>         print *,'dfgdt,taftfhg,rho ',dfgdt(iq),taftfhg(iq),rho(iq)
>         print *,'rmc,rmcmax,qsatgf ',rmc(iq),rmcmax,qsatgf
1332c1788
< !-------------------------------------
---
>  
1382c1838
<         print *,'evapfb,fev,Ewww ',evapfb(iq),fev(iq),Ewww(iq)
---
>         print *,'evapf,fev,Ewww ',evapf,fev(iq),Ewww(iq)
1388a1845,1850
> c      w(iq)     =  wb(iq,1)       ! eta top
> c      w2(iq)    =  wb(iq,ms)      ! eta bottom
> c      ts(iq,2)  =  tgg(iq,2)      ! ts2 top soil temp
> c      ts(iq,1)  =  tgg(iq,3)      ! ts3 second layer temp
> !     snowd(iq) =  snoww(iq)       ! snow depth for darlam
> 
1399c1861
< !eak       snost=ntau+1-1
---
> !eak       snost=ntau+1-kstart
1418a1881,2200
> 
>       subroutine sib2
>       parameter (neva=0)  ! neva= 0 for diags off; neva= 1 for eva's diags on
>       parameter (ntest=0)  ! ntest= 0 for diags off; ntest= 1 for diags on
> c                                   2 to write idjd output every time step
>       parameter (ars=461.,cp=1004.64,hl=2.5104e6,r=287.,hlars=hl/ars)
>       parameter (bprm=5.,cms=5.,chs=2.6,vkar=.4)
>       parameter (hlfusion=.336e6,tfrz=273.1)
>       parameter (d3=2.5,wgmax=.36,stbo=5.67e-08)
>       parameter (cgsoil=1000.,gksoil=.300e-6,rhog=1600.,d1land=.03)
>       parameter (cgsnow=2090,gksnow=.1e-6,rhosnow=100.)
>       parameter (fmroot=.57735)   ! was .4 till 7 Feb 1996
>       include 'newmpar.h'
>       include 'arrays.h'
>       include 'dates.h' ! ktime,kdate,timer,timeg,xg,yg
>       include 'extraout.h'
>       include 'map.h'      ! land
>       include 'morepbl.h'
>       include 'nsibd.h'    ! rsmin,ivegt,sigmf,tgf,ssdn,res,rmc,tsigmf
>       include 'parm.h'
>       include 'pbl.h'
>       include 'scamdim.h'  ! dimension of patches
>       include 'scampar.h'  ! dimension of input,store,output
>       include 'scamco2.h'  ! common block for scam CO2 net flux
>       include 'screen.h'   ! tscrn etc
>       include 'sigs.h'
>       include 'soil.h'     ! ... zmin zolnd zolog sice alb
>       include 'soilsnow.h' ! new soil arrays for scam - tgg too
>       include 'tracers.h'  ! ngas, nllp, ntrac
>       include 'trcom2.h'   ! nstn,slat,slon,istn,jstn
>       common/permsurf/ipsice,ipsea,ipland,iperm(ifull)
>       common/work2/dirad(ifull),dfgdt(ifull),degdt(ifull)
>      . ,wetfac(ifull),degdw(ifull),cie(ifull)
>      . ,factch(ifull),rsts(ifull),rho(ifull),zo(ifull)
>      . ,aft(ifull),fh(ifull),spare1(ifull),theta(ifull)
>      . ,gamm(ifull),rg(ifull),vmod(ifull),spare(ifull)
>       real thetar(kl)
>       character*14 fname0
> 
>       if(neva.eq.1.and.ktau.eq.kstart.and.mstn.ge.2)then
>         fname0(1:3)='noct'
>         fname0(10:10)='.'
>         write(fname0(4:9),'(i6)')kdate
>         do k=1,nstn
>          write(fname0(11:12),'(i2)')iunp(k)
>          open(iunp(k),file=fname0,form='formatted',status='unknown')
>         enddo
>         do k=1,nstn2
>          write(fname0(11:12),'(i2)')iunp2(k)
>          open(iunp2(k),file=fname0,form='formatted',status='unknown')
>         enddo
>       endif
>       nnstn=1 ! set first station number for extra output (not for leads)
>       nnstn2=1 ! set first station number for extra output (not for leads)
> 
>       fgmax=-99.0
>       fgmin=999.0
>       egmax=-99.0
>       egmin=999.0
>       cdmax=-99.0
>       cdmin=999.0
>       tsmax=-99.0
>       tsmin=999.0
>       tgmax=-99.0
>       tgmin=999.0
>       tcmax=-99.0
>       tcmin=999.0
>       gfmax=-99.0
>       gfmin=999.0
>       kperday = int(86400/dt)
> 
> !cdir nodep
>       do 682 ip=1,ipland  ! all land points in this nsib=2 loop
>        iq=iperm(ip)
> c          tSigmF(iq) = 1.0                   ! for use in CO2.f
> 
>           fsd    = sgsave(iq)/(1.-alb(iq))! short wave down (positive) W/m^2
>           fld    = -rgsave(iq)              ! long wave down  ---"---
> c         fld    = -slwa(iq) - sgsave(iq) ! long wave down  ---"---
> cc**      ta     = t(iq,1) - 273.16         ! temperature at reference height
>           ta     = theta(iq) - 273.16       ! temperature at reference height
>           qa     = qg(iq,1)                 ! specific humidity in kg/kg
> !         if(ngas.gt.0)stop 'call co2sflux'
> c when co2 used          if ( iCO2.gt.0 ) then
> c            ca     = 1.e-6*tr(iq,1,iCO2) ! co2 concentration
> c          else
>             ca     = 360.e-6                ! co2 concentration needed for SCAM
> c          endif
>           ua     = vmod(iq)               ! total wind speed at ref height
>           pmb    = .01*ps(iq)             ! pressure in mb at ref height
>           rainsc = condx(iq)              ! in mm not mm/sec
>           if (ktau.eq.kstart) rainsc = 0.
>           zeta0  = 0.
>           t0v0   = ta                       ! veg surface temperature
>           timi   = ktau+1-kstart            ! time step counter for infiltration
>           npij   = 1 !npatch(i,1)           ! number of patches within grid cell
> c         index  = i + (j-1)*il - 1 !index2d(i,1) - 1 ! 1d array of grid cell index
>           index  = iq - 1     !index2d(i,1) - 1 ! 1d array of grid cell index
>           init   = 0
>           if(mod(ktau,7*kperday).eq.1)init=1 ! daily recalculation of lai in sscam
>           if(isflag(index+1).eq.1)init=1     ! recalculation of lai because snow
>           if(ktau.eq.kstart)init=-1          ! initialization of soilmodel etc
> 
>           param0(1) = -R*t(iq,1)*log(sig(1))/9.806   ! reference height
> c         param2(index+1,1) = ivegt(iq)
> c         param2(index+1,2) = isoilm(iq) + 30 ! offset for soil type (gcm + 30)
> c         param2(index+1,3) = 1.          ! zsm
> c         param2(index+1,4) = 1.          ! fraction of gridpoint
> c test only **********************************************************
>           param1(12) = alb(iq)           ! using specified albedo in scam
> c ********************************************************************
> c        if(ntest.eq.1)then
>          if(ntest.eq.1.and.iq.eq.idjd)then
>            print*,'in sib2 before call scam at ktau,iq ',ktau,iq
>            print *,'w,w2: ',wb(iq,1),wb(iq,ms)
>            print *,'land,alb,rgsave,sgsave',
>      .              land(iq),alb(iq),rgsave(iq),sgsave(iq)
>            print *,'fsd,fld,ta,qa,ca,ua,pmb,rainsc,t(iq,1) ',
>      &              fsd,fld,ta,qa,ca,ua,pmb,rainsc,t(iq,1)
>            print *,'npara0,param0',npara0,param0
>            print *,'npara1,param1',npara1,param1
>            print *,'npara2,param2',npara2,(param2(iq,nn),nn=1,npara2)
>            print *,'store ', (store(iq,kk),kk=1,1)
>          endif
> 
>          if(ntest.eq.2.and.iq.eq.idjd)then
>            if(ktau.eq.kstart)write (23,*)
>      .              'ktau    fsd   fld  rainsc   ta   ua    pmb    qa;
>      .               iq = ',iq
>            write (23,923) ktau,fsd,fld,rainsc,ta,ua,pmb,qa
> 923        format(i5,2f8.2,f8.4,2f7.2,f8.2,f8.5)
>          endif
>          call sscam (timi,npij,index,
>      &               fsd,fld,ta,qa,ca,ua,pmb,rainsc,
>      &               init,zeta0,t0v0,zo)
> 
> c         Grid cell averaged output for scam21d
>           fg(iq)    =  outij(3)
>           eg(iq)    =  outij(4)
> !         runoff has deep drainage, maybe with surface runoff
>           runoff(iq)= runoff(iq)+outij(12)
>           cduv(iq)  =  outij(48)
>           wb(iq,1)    =  wb(index+1,1)       !eta top
>           wb(iq,ms)   =  wb(index+1,6)       !eta bottom
>           tss(iq)   =  outij(49) + 273.16  !trad radiative temperature
>           tggij       =  tgg(index+1,1)      !ts1 top soil temp
> c         ts(iq,2)  =  tgg(index+1,2)      !ts2 top soil temp
>           tgg(iq,2)   =  tgg(index+1,2)      !ts2 top soil temp
>           tgg(iq,ms)  =  tgg(index+1,3)      !ts3 second layer temp
>           tcanops     =  outij(31) + 273.16  !tv veg temperature
>           fco2sc(iq)=  outij(5)            !net co2 flux by scam [kgCO2/m2/s]
>           ustar(iq) =  sqrt(outij(6))
>           tscrn(iq) =  outij(50) + 273.16  ! screen temperature
>           scrrel(iq)=  outij(51)           ! screen wind speed
>           uscrn(iq) =  outij(52)           ! screen wind speed
>           u3(iq)    =  outij(53)           ! 3m wind speed
>           u10(iq)   =  outij(54)           ! 10m wind speed
> !to fix   snowd(iq) =  snoww(index+1)      ! snow depth for darlam
> 
> c         Soil heat flux not needed by darlam, but good for diagnostic
>           gfluxkf      = outij(2)  ! soil heat flux (+ down)     [W/m2]
>  
> c         Surface stresses taux, tauy: diagnostic only
>           taux(iq) = rho(iq)*cduv(iq)*u(iq,1)
>           tauy(iq) = rho(iq)*cduv(iq)*v(iq,1)
> 
> c         roughness length after initialization *******************************
>           if (init.ne.0) then
>              zolnd(iq) = zo(iq)
>              zolog(iq) = log(zmin/zolnd(iq)) ! for use in latest sflux
>           endif             ! end of ktau.eq.kstart
> 
> c         compute max/min of quantities returned to darlam from scam
>           fgmax=max(fg(iq),fgmax)
>           fgmin=min(fg(iq),fgmin)
>           egmax=max(eg(iq),egmax)
>           egmin=min(eg(iq),egmin)
>           cdmax=max(cduv(iq),cdmax)
>           cdmin=min(cduv(iq),cdmin)
>           tsmax=max(tss(iq),tsmax)
>           tsmin=min(tss(iq),tsmin)
>           tgmax=max(tgg(iq,1),tgmax)
>           tgmin=min(tgg(iq,1),tgmin)
>           tcmax=max(tcanops ,tcmax)
>           tcmin=min(tcanops ,tcmin)
>           gfmax=max(gfluxkf   ,gfmax)
>           gfmin=min(gfluxkf   ,gfmin)
> 
> c         **************************************************************
> c         Scam specific output (writen to files scama.prn, scamb.prn, scamc.prn)
> c         for grid point id,jd only:
> c         write computed global params and headers to detailed output file,
>           if(ntest.eq.3.and.iq.eq.idjd)then
>             fnsc    = outvar(1 ,1)  ! ACTUAL net irrad (+ down)   [W/m2]
>             gfluxkf = outvar(1 ,2)  ! soil heat flux (+ down)     [W/m2]
>             fhsc    = outvar(1 ,3)  ! sensible heat flux          [W/m2]
>             fesc    = outvar(1 ,4)  ! latent heat flux            [W/m2]
>             fcsc    = outvar(1 ,5)  ! mass CO2 flux         [mgCO2/m2/s]
>             us2     = outvar(1 ,6)  ! (friction velocity)**2      [m2/s2]
>             zeta    = outvar(1 ,7)  ! Monin-Obukhov za/L          [-]
>             rbv     = outvar(1 ,8)  ! veg-bulk bound-layer resist [s/m]
>             rsv     = outvar(1 ,9)  ! veg-bulk atal resist    [s/m]
>             rt0     = outvar(1 ,10) ! turb resistance: (0,d)      [s/m]
>             rt1     = outvar(1 ,11) ! turb resistance: (d,za)     [s/m]
>             runo    = outvar(1 ,12) ! runoff in this step         [mm]
>             rinfil  = outvar(1 ,13) ! surface infilt this step    [mm]
>             rexfil  = outvar(1 ,14) ! exfilt (deep drainage)      [mm]
>             evapsc  = outvar(1 ,15) ! total evaporation this step [mm]
>             fnv     = outvar(1 ,16) ! veg  parts of fn,fh,fe      [W/m2]
>             fhv     = outvar(1 ,17)
>             fev     = outvar(1 ,18)
>             fns     = outvar(1 ,19) ! soil parts of fn,fh,fe
>             fhs     = outvar(1 ,20)
>             fes     = outvar(1 ,21)
>             fesatm  = outvar(1 ,22) ! atm-lim, soil-lim soil fe
>             fessoi  = outvar(1 ,23)
>             fevc    = outvar(1 ,24)
>             fevw    = outvar(1 ,25)
>             fsu     = outvar(1 ,26)
>             flu     = outvar(1 ,27)
>             t0vsc   = outvar(1 ,28)       ! veg surface t[C], q,deficit[kg/kg]
>             q0vsc   = outvar(1 ,29)       ! veg surface t[C], q,deficit[kg/kg]
>             d0vsc   = outvar(1 ,30)       ! veg surface t[C], q,deficit[kg/kg]
>             tvsc    = outvar(1 ,31)
>             qvsc    = outvar(1 ,32)
>             dvsc    = outvar(1 ,33)
> 
>             zetar(1)  = outvar(1,34) ! iterations toward zeta
>             zetar(2)  = outvar(1,35)
>             zetar(3)  = outvar(1,36)
>             zetar(4)  = outvar(1,37)
>             zetar(5)  = outvar(1,38)
> 
>             ts1sc      = tgg(index+1,1)
>             ts2sc      = tgg(index+1,2)
>             eta1     = wb(index+1,1)
>             eta2     = wb(index+1,2)
>             eta3     = wb(index+1,3)
>             eta4     = wb(index+1,4)
>             eta5     = wb(index+1,5)
>             cansto   = store(index+1,1)
>             totsto   = 0. ! total water store (end of step i)
>             totsti   = 0. ! initial tot water (start of step i)
>             watbal  = rainsc-runo-rexfil-evapsc
>      &                   -totsto+totsti
> c         on last spin and for first print day only
>             if (ktau.eq.kstart) then
>               write(2,125) (hold(1 ,jh),hname(jh),jh=1,10)
>  125          format(' COMPUTED parameters (array hold):',/,
>      &             (5(f10.5,1x,a8,1x)))
>               write(2,102)
>  102          format(/,' ENDtimeRsd:Wm2Rld:Wm2 Rn:Wm2 G:W/m2',
>      &             ' FH:W/m2 FE:W/m2 FCmgm2s     T:C  Q:g/kg',
>      &             '   C:ppm  d:g/kg   u:m/s   us*10    za/L',
>      &             ' rbv:s/m rsv:s/m rt0:s/m rt1:s/m',
>      &             '   ts1:C   ts2:C')
>               write(3,108)
>  108          format(' ENDtimeFHv:Wm2FEv:Wm2FHs:Wm2FEs:Wm2',
>      &           '    eta1    eta2',
>      &           ' canstmm prec:mm rnoffmm',
>      &           ' infilmm exfilmm evap:mm watblmm',
>      &           ' Rnv:Wm2 Rns:Wm2',
>      &           '     T0v      Tv     Q0v      Qv')
>               write(4,106)
>  106          format(' ENDtime zeta(1) zeta(2) zeta(3)',
>      &           ' zeta(4) zeta(5) zeta:fin  FCtot ')
>             end if
> 
>             tday = ktau*dt/86400.      ! time axis (days)
>             d = 0. ! qsatf(t(i),pmb(i))-q(i)  ! sat def at ref height (kg/kg)
>             write(2,103) tday,fsd,fld,fnsc,gfluxkf,
>      &                 fhsc,fesc,fco2sc(iq),ta,1000*qa,
>      &                 ca,1000*d,ua,10*sqrt(us2),zeta,
>      &                 rbv,rsv,rt0,rt1,ts1sc,ts2sc
>             write(3,103) tday,fhv,fev,fhs,fes,
>      &                 eta1,eta2,
>      &                 cansto,rainsc,runo,
>      &                 rinfil,rexfil,evapsc,watbal,
>      &                 fnv,fns,
>      &                 t0vsc,tvsc,1000*q0vsc,1000*qvsc
>             write(4,103) tday,(zetar(iter),iter=1,5),zeta
>  103        format(21e11.4)
>             write(7,*)tday,fsd,fld,rainsc,ta,ua,pmb,qa
> 
>           endif   !  (ntest.eq.3.and.iq.eq.idjd)
> 
> c        if(neva.eq.1.and.ktau.gt.kstart.and.mstn.ge.2)then
> c          j=iq/il+1
> c          i=iq-(j-1)*il
> c          if(i.eq.istn(nnstn).and.j.eq.jstn(nnstn))then
> c            do k=1,kl
> c             thetar(k)=t(i,j,k)/sig(k)**(r/cp)
> c           enddo
> c          iveg=ivegt(iq)
> c           isoil=isoilm(iq,1)
> c           write(iunp(nnstn),8447) timeg,ktau,i,j,
> c     &        (tr(i,j,l,18),l=1,4),
> c     &        (thetar(l),l=1,4),
> c     &        (qg(i,j,l),l=1,4),
> c     &        (u(i,j,l),l=1,4),
> c     &        (v(i,j,l),l=1,4),
> c     &        ps(i,j),condx(i,j),wb(i+(j-1)*il,1)
> c     &       ,wb(i+(j-1)*il,ms),isoil,
> c     &        tss(i,j),tgg(iq,1),t(i,j,1),
> c     &        eg(i,j),fg(i,j),iveg,tcanops
> c8447       format(f4.1,i5,i3,i2,4f5.0,4f6.1,
> c     &     4f7.4,4f5.1,4f5.1,f8.0,f6.3,2f5.2,i2,3f6.1,1x,2f6.1,i3,f6.1)
> c           nnstn=min(nnstn+1,nstn)
> c          endif  !  (i.eq.istn(nnstn).and.j.eq.jstn(nnstn))
> c        endif    ! (neva.eq.1.and.ktau.gt.kstart.and.mstn.ge.2)
> 
> c ***************************************** end of scam specific output 
> 682   continue
> 
>       if (ntest.eq.1)
>      &print*,'max,min ',fgmax,fgmin,egmax,egmin,cdmax,cdmin,tsmax,tsmin,
>      &                 tgmax,tgmin,tcmax,tcmin,gfmax,gfmin
>       return
>       end
> 
=====================================
 
skill_cc.f
=====================================
=====================================
 
so2.f
=====================================
2c2
< c     so2.f bundles together so2accumulate, so2dry, so2inisrc,
---
> c     so2.f bundles together SO2accumulate, SO2Dry, SO2inisrc,
4c4
<       subroutine so2accumulate
---
>       subroutine SO2accumulate
6c6
< * clobber the so2 tracer & accumulate it
---
> * clobber the SO2 tracer & accumulate it
13,14c13,15
<         if( tr(i,1,max(1,iso2)).lt.0. ) then
<            tr(i,1,max(1,iso2)) = 0.
---
>         if( tr(i,1,iSO2).LT.0. ) then
> *          write(*,*)'darlam: i, tr(i,1,iSO2)', i, tr(i,1,1,iSO2)
>            tr(i,1,iSO2) = 0.
16c17
<            sumtr(i,1) = sumtr(i,1) + tr(i,1,max(1,iso2))
---
>            sumtr(i,1) = sumtr(i,1) + tr(i,1,iSO2)
19c20
<       nsumtr = nsumtr + 1
---
>       nSumTr = nSumTr + 1
21c22
< c      write(*,*)' so2accumulate: clobbered tr(so2), nsumtr =', nsumtr
---
> c      write(*,*)' SO2accumulate: clobbered tr(SO2), nSumTr =', nSumTr
25c26
<       subroutine so2dry( kappa_d )
---
>       subroutine SO2Dry( kappa_d )
28,29c29,30
< c ---  this routine computes vertical tracer (so2) transport with rain
< c --- coupled with the modified routine conjob
---
> c ---  This routine computes vertical tracer (SO2) transport with rain
> c --- coupled with the modified routine CONJOB
31c32
< * ............ updates dtr
---
> * ............ UPDATES dTr
38c39
<       common/work3/vmixarrs(ifull,kl,3),trsrc(ifull,kl),spare(ifull,kl)
---
>       common/work3/vmixarrs(ifull,kl,3),trsrc(ifull,kl)
40,42c41,43
<       real    l, beta_0, f_0, f_k_max, kappa_w, kappa_d
<       data    l/5.0e-4/
<       data    f_k_max/0./, f_0/0.8/
---
>       real    L, beta_0, f_0, f_k_Max, kappa_w, kappa_d
>       data    L/5.0e-4/
>       data    f_k_Max/0./, f_0/0.8/
44c45
<       save f_k, f_k_max, f_0, l
---
>       save f_k, f_k_Max, f_0, L
46c47
<       common/so2block/ i, j, k, beta_0, psong, drain, rainb, dtr
---
>       common/SO2block/ i, j, k, beta_0, PsOnG, dRain, rainB, dTr
49c50
< * note:
---
> * NOTE:
55c56
<       entry so2drywet( kappa_d, rk_wet, frac, dtrdry, dtrwt )
---
>       Entry SO2DryWet( kappa_d, k_Wet, frac, dTrDry, dTrWt )
59,61c60,62
< 10    if( tr(iq,k,max(1,iso2)).le.0. ) then
<         tr(iq,k,max(1,iso2)) = 0.
<         dtr = (-trsrc(iq,k)/kappa_d)*(exp(-kappa_d)-1.)
---
> 10    if( tr(iq,k,iSO2).LE.0. ) then
>         tr(iq,k,iSO2) = 0.
>         dTr = (-trsrc(iq,k)/kappa_d)*(exp(-kappa_d)-1.)
63c64
<         dtr = (tr(iq,k,max(1,iso2))-trsrc(iq,k)/kappa_d)*
---
>         dTr = (tr(iq,k,iSO2)-trsrc(iq,k)/kappa_d)*
67c68
<       if(idry.eq.1) return           ! only dry deposition required
---
>       if(idry.EQ.1) return           ! only dry deposition required
69c70
<       dtrdry = dtr
---
>       dTrDry = dTr
74c75
<       entry so2wet( kappa_d )
---
>       Entry SO2Wet( kappa_d )
77c78
< 20    f_k = f_k_max
---
> 20    f_k = f_k_Max
79c80
<       if( drain.gt.0. ) then         ! drain > 0   indicates cloud water
---
>       if( dRain.GT.0. ) then         ! dRain > 0   indicates cloud water
81,83c82,84
<         rainonl = drain/l
<         f_k     = f_0/(1.+beta_0/rainonl)
<         f_k_max = max(f_k,f_k_max)
---
>         rainOnL = dRain/L
>         f_k     = f_0/(1.+beta_0/rainOnL)
>         f_k_Max = MAX(f_k,f_k_Max)
87c88
<         rainonl =  cem*rainb
---
>         rainOnL =  CEm*rainB
91,92c92,93
<       rainonl = rainonl*psong
<       temp = rainonl/f_k
---
>       rainOnL = rainOnL*PsOnG
>       temp = rainOnL/f_k
95c96
<       if ( tr(iq,k,max(1,iso2)).le.0. ) tr(iq,k,max(1,iso2)) = 0.
---
>       if ( tr(iq,k,iSO2).LE.0. ) tr(iq,k,iSO2) = 0.
97c98
<       if( idry.eq.0 ) then
---
>       if( idry.EQ.0 ) then
99,100c100,101
<         rk_wet = temp
<         dtrwt = f_k*(tr(iq,k,max(1,iso2))-trsrc(iq,k)/kappa_w)*
---
>         k_wet = temp
>         dTrWt = f_k*(tr(iq,k,iSO2)-trsrc(iq,k)/kappa_w)*
102,103c103,104
<         dtrdry = (1.-f_k)*dtr
<         dtr = dtrwt + dtrdry
---
>         dTrDry = (1.-f_k)*dTr
>         dTr = dTrWt + dTrDry
105c106
<         dtr = f_k*(tr(iq,k,max(1,iso2))-trsrc(iq,k)/kappa_w)*
---
>         dTr = f_k*(tr(iq,k,iSO2)-trsrc(iq,k)/kappa_w)*
107c108
<      .      (1.-f_k)*dtr
---
>      .      (1.-f_k)*dTr
112c113
<       subroutine so2inisrc
---
>       subroutine SO2inisrc
115c116
< c ----   the purpose of this routine is to initialise the tracer (so2) source block
---
> c ----   The purpose of this routine is to initialise the tracer (SO2) source block
123c124
<       common/work3/vmixarrs(ifull,kl,3),trsrc(ifull,kl),spare(ifull,kl)
---
>       common/work3/vmixarrs(ifull,kl,3),trsrc(ifull,kl)
125,127c126,128
<       logical firstcall
<       save    firstcall
<       data    firstcall/.true./
---
>       logical firstCall
>       save    firstCall
>       data    firstCall/.TRUE./
131,137c132,138
<       if( firstcall ) then
<         oneab = 1. - alpha - beta
<         do k=1,nso2lev
<           do ix=iso2lev(k-1)+1,iso2lev(k)
<             so2em(iso2emindex(ix)) = so2em(iso2emindex(ix)) *
<      .          oneab * (-so2fact(k))
<           end do !      do ix=iso2lev(k-1)+1,iso2lev(k)
---
>       if( firstCall ) then
>         OneAB = 1. - alpha - beta
>         do k=1,nSO2lev
>           do ix=iSO2lev(k-1)+1,iSO2lev(k)
>             SO2em(iSO2emIndex(ix)) = SO2em(iSO2emIndex(ix)) *
>      .          OneAB * (-SO2fact(k))
>           end do !      do ix=iSO2lev(k-1)+1,iSO2lev(k)
139c140
<           oneab = 1. - beta	! at levels above one there is no immediate fallout at present
---
>           OneAB = 1. - beta	! at levels above one there is no immediate fallout at present
141,142c142,143
<         end do !     do k=2,nso2lev
<         firstcall = .not.firstcall
---
>         end do !     do k=2,nSO2lev
>         firstCall = .NOT.firstCall
145,148c146,149
<       do k=1,nso2lev
<         do ix=iso2lev(k-1)+1,iso2lev(k)
<           i = iso2em(1,iso2emindex(ix))
<           j = iso2em(2,iso2emindex(ix))
---
>       do k=1,nSO2lev
>         do ix=iSO2lev(k-1)+1,iSO2lev(k)
>           i = iSO2em(1,iSO2emIndex(ix))
>           j = iSO2em(2,iSO2emIndex(ix))
150,152c151,153
<           trsrc(iq,k) = trsrc(iq,k) + so2em(iso2emindex(ix))/ps(iq)
<         end do !      do ix=iso2lev(k-1)+1,iso2lev(k)
<       end do !     do k=2,nso2lev
---
>           trsrc(iq,k) = trsrc(iq,k) + SO2em(iSO2emIndex(ix))/ps(iq)
>         end do !      do ix=iSO2lev(k-1)+1,iSO2lev(k)
>       end do !     do k=2,nSO2lev
157c158
<       subroutine so2sflux
---
>       subroutine SO2SFlux
164,174c165,175
<       common/work3/vmixarrs(ifull,kl,3),trsrc(ifull,kl),spare(ifull,kl)
<       logical firstcall
<       save    firstcall
< c     data    firstcall/.true./,j/1/,k/1/
<       data    firstcall/.true./
< 
< * so2background --- emissions per unit time step
< 
<       if( firstcall ) then
<         so2background = so2background * (-so2fact(1))
<         firstcall = .not.firstcall
---
>       common/work3/vmixarrs(ifull,kl,3),trsrc(ifull,kl)
>       logical firstCall
>       save    firstCall
> c     data    firstCall/.TRUE./,j/1/,k/1/
>       data    firstCall/.TRUE./
> 
> * SO2BackGround --- emissions per unit time step
> 
>       if( firstCall ) then
>         SO2BackGround = SO2BackGround * (-SO2fact(1))
>         firstCall = .NOT.firstCall
180c181
<           trsrc(iq,1)   = so2background / ps(iq)
---
>           trsrc(iq,1)   = SO2BackGround / ps(iq)
196c197
<       subroutine so2vmix( updtr )
---
>       Subroutine SO2vmix( updTr )
203c204
<       include 'parm.h'		! ktau
---
>       include 'parm.h'		! ktau, kstart
207c208
<       common/work3/vmixarrs(ifull,kl,3),trsrc(ifull,kl),spare(ifull,kl)
---
>       common/work3/vmixarrs(ifull,kl,3),trsrc(ifull,kl)
209,233c210,234
< * land use indices
<       parameter ( ibrlfevrgrtr =  1,
<      .            ibrlfdecidtr =  2,
<      .            ibrlfneedltr =  3,
<      .            ineedevrgrtr =  4,
<      .            ineeddecidtr =  5,
<      .            ibrlfgrdcvtr =  6,
<      .            igrdcvonly   =  7,
<      .            ibrlfgrdcvsh =  8,
<      .            ibrlfbrsoish =  9,
<      .            idwarfshrbtr = 10,
<      .            ibaresoil    = 11,
<      .            iwnwhbrlfdtr = 12,
<      .            isea         = 13)
< 
< 
< c     real vdrydepso2(13)
< c     data vdrydepso2/6*0.7e-2,0.3e-2,0.5e-2,2*0.3e-2,0.2e-2,0.5e-2,
< c    .                  1.0e-2/ ! so2 dry deposition velocities in m/s
< * vegetation height map
<       parameter ( ibaregrnd = 1,
<      .            ilowveg   = 2,
<      .            imedveg   = 3,
<      .            ihighveg  = 4,
<      .            iocean    = 5)
---
> * Land use indices
>       parameter ( iBrLfEvrGrTR =  1,
>      .            iBrLfDecidTR =  2,
>      .            iBrLfNeedlTR =  3,
>      .            iNeedEvrGrTR =  4,
>      .            iNeedDecidTR =  5,
>      .            iBrLfGrdCvTR =  6,
>      .            iGrdCvOnly   =  7,
>      .            iBrLfGrdCvSH =  8,
>      .            iBrLfBrSoiSH =  9,
>      .            iDwarfShrbTR = 10,
>      .            iBareSoil    = 11,
>      .            iWnWhBrLfDTR = 12,
>      .            iSea         = 13)
> 
> 
> c     real vDryDepSO2(13)
> c     data vDryDepSO2/6*0.7e-2,0.3e-2,0.5e-2,2*0.3e-2,0.2e-2,0.5e-2,
> c    .                  1.0e-2/ ! SO2 dry deposition velocities in m/s
> * Vegetation height map
>       parameter ( iBareGrnd = 1,
>      .            iLowVeg   = 2,
>      .            iMedVeg   = 3,
>      .            iHighVeg  = 4,
>      .            iOcean    = 5)
235,236c236,237
<       real vdrydepso2(5)
<       data vdrydepso2/0.2e-2, 0.3e-2, 0.5e-2, 0.7e-02, 1.0e-2/ ! so2 dry deposition velocities in m/s
---
>       real vDryDepSO2(5)
>       data vDryDepSO2/0.2e-2, 0.3e-2, 0.5e-2, 0.7e-02, 1.0e-2/ ! SO2 dry deposition velocities in m/s
239,241c240,242
<       data imap/7*ihighveg,5*imedveg,15*ilowveg,imedveg,3*ibaregrnd,
<      .          6*ihighveg,ilowveg,imedveg,2*ilowveg,ibaregrnd,imedveg,
<      .          iocean/
---
>       data imap/7*iHighVeg,5*iMedVeg,15*iLowVeg,iMedVeg,3*iBareGrnd,
>      .          6*iHighVeg,iLowVeg,iMedVeg,2*iLowVeg,iBareGrnd,iMedVeg,
>      .          iOcean/
243,244c244,245
< c      data imap/6*ihighveg,ilowveg,imedveg,2*ilowveg,ibaregrnd,imedveg,
< c     .            iocean/
---
> c      data imap/6*iHighVeg,iLowVeg,iMedVeg,2*iLowVeg,iBareGrnd,iMedVeg,
> c     .            iOcean/
247c248
<       real    updtr(ifull,kl)
---
>       real    updTr(ifull,kl)
249c250
<       real    c, emis, cem, r_t, r_tdt
---
>       real    C, Emis, CEm, r_t, r_tDt
251c252
<       data    c/5.2/, emis/0.1/
---
>       data    C/5.2/, Emis/0.1/
253,254c254,255
<       logical firstcall
<       data    firstcall/.true./
---
>       logical firstCall
>       data    firstCall/.TRUE./
256c257
<       save r_t, r_tdt, firstcall
---
>       save r_t, r_tDt, firstCall
258c259
<       common/so2block/ i, j, k, beta_0, psong, drain, rainb, dtr
---
>       common/SO2block/ i, j, k, beta_0, PsOnG, dRain, rainB, dTr
260c261
< * note:
---
> * NOTE:
262c263
< *	r_tdt   --- so2 <---> so4 conversion rate per time step
---
> *	r_tDt   --- SO2 <---> SO4 conversion rate per time step
266c267
<       if( firstcall ) then
---
>       if( firstCall ) then
270c271
<         r_tdt = r_t*dt
---
>         r_tDt = r_t*dt
272,273c273,274
<         cem   = c*emis
<         firstcall = .not.firstcall
---
>         CEm   = C*Emis
>         firstCall = .NOT.firstCall
275c276
< * --- initialise trsrc's with so2 emission sources
---
> * --- initialise trsrc's with SO2 emission sources
277c278
<       call so2inisrc
---
>       call SO2inisrc
282c283
<           psong     = ps(iq)/g
---
>           PsOnG     = ps(iq)/g
287,288c288,289
<             vdryso2 =     tsigmf(iq) *vdrydepso2(imap(ivegt(iq))) +
<      .                (1.-tsigmf(iq))*vdrydepso2(       ibaregrnd)
---
>             vDrySO2 =     tsigmF(iq) *vDryDepSO2(imap(ivegt(iq))) +
>      .                (1.-tsigmF(iq))*vDryDepSO2(       iBareGrnd)
290c291
<             vdryso2 = vdrydepso2( imap(isea) )
---
>             vDrySO2 = vDryDepSO2( imap(iSea) )
293,295c294,296
< * ---               rho dz = - ps dsigma / g
< * ---               p = rho r t
< * ---               condrag = - g dt / r dsig
---
> * ---               rho dz = - Ps dSigma / g
> * ---               p = rho R T
> * ---               condrag = - g dt / R dsig
297c298
<           vdryso2 = - vdryso2 * condrag / t(iq,1)
---
>           vDrySO2 = - vDrySO2 * condrag / t(iq,1)
300,301c301,302
< * --- 	do so2 for all the layers above bottom one
<           sumdtr  = 0.
---
> * --- 	do SO2 for all the layers above bottom one
>           sumDTr  = 0.
303c304
<           raint = 0.
---
>           rainT = 0.
305,307c306,308
< *           rain(iq,k) = 0.  !!!!!!!!!!!!!!!!!!! temporary
<             rainb = rain(iq,k)
<             drain = rainb - raint
---
> *           rain(iq,k) = 0.  !!!!!!!!!!!!!!!!!!! TEMPORARY
>             rainB = rain(iq,k)
>             dRain = rainB - rainT
310,312c311,313
<             if( drain.lt.0. ) then
<               evfrac  = sumdtr*drain/raint
<               trsrc(iq,k) = trsrc(iq,k) + evfrac/(-dsig(k))
---
>             if( dRain.LT.0. ) then
>               evFrac  = sumDTr*dRain/rainT
>               trsrc(iq,k) = trsrc(iq,k) + evFrac/(-dsig(k))
314c315
<             dtr = trsrc(iq,k)
---
>             dTr = trsrc(iq,k)
316,318c317,319
<             if( rainb.ne.0. ) then   ! drain > 0 indicates cloud water, < 0 rain evaporation
<               call so2wet( r_tdt )
<               sumdtr = sumdtr + (-dsig(k))*(dtr-trsrc(iq,k))
---
>             if( rainB.NE.0. ) then   ! dRain > 0 indicates cloud water, < 0 rain evaporation
>               call SO2Wet( r_tDt )
>               sumDTr = sumDTr + (-dsig(k))*(dTr-trsrc(iq,k))
320,321c321,322
<               if(tr(iq,k,max(1,iso2)).lt.0.) tr(iq,k,max(1,iso2)) = 0.
<               sumdtr = 0.
---
>               if(tr(iq,k,iSO2).LT.0.) tr(iq,k,iSO2) = 0.
>               sumDTr = 0.
324,325c325,326
<             updtr(iq,k) = tr(iq,k,max(1,iso2)) + dtr
<             raint = rainb
---
>             updTr(iq,k) = tr(iq,k,iSO2) + dTr
>             rainT = rainB
329c330
< * --- 	do so2 for the bottom layer
---
> * --- 	do SO2 for the bottom layer
331,334c332,335
<           kappa_d = r_tdt + vdryso2
< *         rain(iq,k) = 0.  !!!!!!!!!!!!!!!!!!! temporary
<           rainb   = rain(iq,k)
<           drain   = rainb - raint
---
>           kappa_d = r_tDt + vDrySO2
> *         rain(iq,k) = 0.  !!!!!!!!!!!!!!!!!!! TEMPORARY
>           rainB   = rain(iq,k)
>           dRain   = rainB - rainT
337,339c338,340
<           if( drain.lt.0. ) then
<             evfrac  = sumdtr*drain/raint
<             trsrc(iq,k) = trsrc(iq,k) + evfrac/(-dsig(k))
---
>           if( dRain.LT.0. ) then
>             evFrac  = sumDTr*dRain/rainT
>             trsrc(iq,k) = trsrc(iq,k) + evFrac/(-dsig(k))
342,343c343,344
<           if( rainb.ne.0. ) then     ! drain > 0 indicates cloud water, < 0 rain evaporation
<             call so2drywet( kappa_d, rk_wet, frac, dtrdry, dtrwt )
---
>           if( rainB.NE.0. ) then     ! dRain > 0 indicates cloud water, < 0 rain evaporation
>             call SO2DryWet( kappa_d, k_Wet, frac, dTrDry, dTrWt )
349,352c350,353
<             tmp = psong*(src - dtrwt) * (-dsig(k))/(kappa_d + rk_wet)
<             sumtr(iq,iwetdep) = sumtr(iq,iwetdep) +
<      .                         (tmp*rk_wet - sumdtr*psong)
<             sumtr(iq,irain)   = sumtr(iq,irain)   + rain(iq,k)*psong
---
>             tmp = PsOnG*(src - dTrWt) * (-dsig(k))/(kappa_d + k_Wet)
>             sumTr(iq,iWETDEP) = sumTr(iq,iWETDEP) +
>      .                         (tmp*k_Wet - sumDTr*PsOnG)
>             sumTr(iq,iRAIN)   = sumTr(iq,iRAIN)   + rain(iq,k)*PsOnG
355c356
<             call so2dry( kappa_d )
---
>             call SO2Dry( kappa_d )
357c358
<             dtrdry = dtr
---
>             dTrDry = dTr
361c362
<           tmp  = tmp + psong*(src - dtrdry)*(-dsig(k))/kappa_d
---
>           tmp  = tmp + PsOnG*(src - dTrDry)*(-dsig(k))/kappa_d
365,366c366,367
<           sumtr(iq,idrydep)=sumtr(iq,idrydep) + tmp*vdryso2
<           updtr(iq,k) = tr(iq,k,max(1,iso2)) + dtr
---
>           sumTr(iq,iDRYDEP)=sumTr(iq,iDRYDEP) + tmp*vDrySO2
>           updTr(iq,k) = tr(iq,k,iSO2) + dTr
371,376c372,377
<         do ix=iso2lev(k-1)+1,iso2lev(k)
<           i = iso2em(1,iso2emindex(ix))
<           j = iso2em(2,iso2emindex(ix))
<           sumtr(iq,idrydep) = sumtr(iq,idrydep) +
<      .                                     alpha*so2em(iso2emindex(ix))
<         end do !      do ix=iso2lev(k-1)+1,iso2lev(k)
---
>         do ix=iSO2lev(k-1)+1,iSO2lev(k)
>           i = iSO2em(1,iSO2emIndex(ix))
>           j = iSO2em(2,iSO2emIndex(ix))
>           sumTr(iq,iDRYDEP) = sumTr(iq,iDRYDEP) +
>      .                                     alpha*SO2em(iSO2emIndex(ix))
>         end do !      do ix=iSO2lev(k-1)+1,iSO2lev(k)
=====================================
 
soilsnow.f
=====================================
24c24
<       include 'parm.h'      ! ktau,dt
---
>       include 'parm.h'      ! kstart,ktau,dt
36c36
<      . dum3(5*ijk-16*ifull)
---
>      . dum3(2*ijk-16*ifull),uav(ifull,kl),vav(ifull,kl)
62c62
< *cdir nodep
---
> *     vdir nodep
226c226
< *cdir nodep
---
> *     vdir nodep
309c309
< !     parameter (nglacier=2)  ! 0 original, 1 off, 2 new from Eva; to parm.h
---
>       parameter (nglacier=2)  ! 0 original, 1 off, 2 new from Eva
313c313
<       include 'parm.h'      ! ktau,dt
---
>       include 'parm.h'      ! kstart,ktau,dt
327c327
<      . dum3(5*ijk-16*ifull)
---
>      . dum3(2*ijk-16*ifull),uav(ifull,kl),vav(ifull,kl)
354c354
< *cdir nodep
---
> *     vdir nodep
362,401c362,374
<          if(isflag(iq).eq.0)then
< 	    if(t(iq,2).lt.tfrz.and.tgg(iq,1).lt.tfrz)then
<              snowd(iq)=max(snowd(iq) + condxpr(iq), 0.)
< 	      sno(iq)=sno(iq)+condxpr(iq)  ! snow precip accum in mm
< !            update air temperatures to allow for freezing of rain
<              dtemp=hlf*g*condxpr(iq)/
<      .                (cp*(sigmh(kl/3)-sigmh(kl/2+1))*ps(iq))
<              do k=kl/3,kl/2    ! 6,9 for 18 level
<               t(iq,k)=t(iq,k)+dtemp    ! jlm suggestion
<              enddo ! k loop
<              condxpr(iq)=0.
< 	    elseif(t(iq,2).ge.tfrz.and.tgg(iq,1).lt.tfrz )then
<              snowd(iq)=max(snowd(iq) + condxpr(iq), 0.)
< 	      sno(iq)=sno(iq)+condxpr(iq)  ! snow precip accum in mm
<              tgg(iq,1)=tgg(iq,1)+condxpr(iq)*hlf/gammzz(iq,1)
<              condxpr(iq)=0.
< 	      endif   ! (t(iq,2).lt.tfrz.and.tgg(iq,1).lt.tfrz ) 
<         else  ! i.e. isflag(iq)=1
< 	    if(t(iq,2).lt.tfrz)then
<              snowd(iq)=max(snowd(iq) + condxpr(iq), 0.)
< 	      sno(iq)=sno(iq)+condxpr(iq)  ! snow precip accum in mm
< !            update air temperatures to allow for freezing of rain
<              dtemp=hlf*g*condxpr(iq)/
<      .                (cp*(sigmh(kl/3)-sigmh(kl/2+1))*ps(iq))
<              do k=kl/3,kl/2    ! 6,9 for 18 level
<               t(iq,k)=t(iq,k)+dtemp    ! jlm suggestion
<              enddo ! k loop
<              condxpr(iq)=0.
< 	    elseif(t(iq,2).ge.tfrz)then
<              snowd(iq)=max(snowd(iq) + condxpr(iq), 0.)
< 	      sno(iq)=sno(iq)+condxpr(iq)  ! snow precip accum in mm
< 	      do k=1,3
<               sgamm  = ssdn(iq,k)*2105. * sdepth(iq,k)
<               tggsn(iq,k)=tggsn(iq,k)+condxpr(iq)*hlf*smass(iq,k)/
<      &                                           (sgamm*osnowd(iq))
<              enddo
<              condxpr(iq)=0.
< 	    endif   ! (t(iq,2).lt.tfrz) 
<          endif     ! (isflag(iq).eq.0) ... else ...
<        endif       ! (condxpr(iq).gt.0.)
---
>          if(isflag(iq).eq.1.or.            
>      .                  (t(iq,2).lt.tfrz.and.tgg(iq,1).lt.tfrz ) )then
>            snowflx=condxpr(iq)
>            snowd(iq)=max(snowd(iq) + snowflx, 0.)
> !          update air temperatures to allow for freezing of rain
>            dtemp=hlf*g*condxpr(iq)/
>      .              (cp*(sigmh(kl/3)-sigmh(kl/2+1))*ps(iq))
> c         print *,'iq,condxpr,ps,dtemp ',iq,condxpr(iq),ps(iq),dtemp
>            do k=kl/3,kl/2    ! 6,9 for 18 level
>             t(iq,k)=t(iq,k)+dtemp    ! jlm suggestion
>            enddo
>          endif  ! (isflag(iq).eq.1.or. ...)
>        endif    ! (condxpr(iq).gt.0.)
415a389
> 
428c402
<          else     ! 3-layer scheme,  isflag=1
---
>          else     ! 3-layer scheme
474c448
< *cdir nodep
---
> *     vdir nodep
481a456,460
> 
> !      dwb=max( (wb(iq,ms)-(sfc(isoil)))*c3(isoil)*zse(ms)*1000.
> !    &           , 0.)/1000./zse(ms)/86400.
> !      dwb=dwb*0.5
> !!     dwb=max(.5*(wb(iq,ms)-sfc(isoil))*c3(isoil)/86400. , 0.)
489c468
<       enddo               ! ip loop
---
> c      snowd(iq)=min(snowd(iq),1000.)
491,493c470,472
< c---  glacier formation
<       if(nglacier.eq.0)then  ! crashes with tggsn1 going v cold
<         do iq=1,ifull
---
> C----  glacier FORMATION
> c      SNOWD(MG)=MIN( SNOWD(MG), 400.)
>        if(nglacier.eq.0)then  ! crashes with tggsn1 going v cold
501,525c480,502
<          endif ! (snowd(iq).gt.400.)
< 	 enddo  ! iq loop
<       endif    ! (nglacier.eq.0)
<       if(nglacier.eq.2)then  ! new from Eva 3/10/02           
<         do iq=1,ifull
<          if(snowd(iq).gt.400.)then
<            rnof5=snowd(iq)-400.
<            runoff(iq)=runoff(iq)+rnof5
< c----      change local tg to account for energy - clearly not best method
<            if(isflag(iq).eq.0)then
<              tgg(iq,1)= tgg(iq,1)-rnof5*hlf/gammzz(iq,1)
<              snowd(iq)=400.
<            else
<              smasstot=smass(iq,1)+smass(iq,2)+smass(iq,3)
<              do k=1,3
<               sgamm   = ssdn(iq,k)*2105. * sdepth(iq,k)
<               smelt1(k)= min(rnof5*smass(iq,k)/smasstot,0.9*smass(iq,k))
<               smass(iq,k) = smass(iq,k) - smelt1(k)
<               snowd(iq)=snowd(iq)-smelt1(k)
<               tggsn(iq,k)= tggsn(iq,k)-smelt1(k)*hlf/sgamm
<              enddo
<            endif ! (isflag(iq).eq.0) ... else ...
<          endif   ! (snowd(iq).gt.400.)
< 	 enddo    ! iq loop
<        endif     ! (nglacier.eq.2)
---
>          endif
>        endif   ! (nglacier.eq.0)
>        if(nglacier.eq.2)then  ! new from Eva 3/10/02           
>         if(snowd(iq).gt.400.)then
>          rnof5=snowd(iq)-400.
>          runoff(iq)=runoff(iq)+rnof5
> c----     change local tg to account for energy - clearly not best method
>           if(isflag(iq).eq.0) then
>            tgg(iq,1)= tgg(iq,1)-rnof5*hlf/gammzz(iq,1)
>            snowd(iq)=400.
>           else
>            smasstot=smass(iq,1)+smass(iq,2)+smass(iq,3)
>            do k=1,3
>             sgamm   = ssdn(iq,k)*2105. * sdepth(iq,k)
>             smelt1(k)= min(rnof5*smass(iq,k)/smasstot,0.9*smass(iq,k))
>             smass(iq,k) = smass(iq,k) - smelt1(k)
>             snowd(iq)=snowd(iq)-smelt1(k)
>             tggsn(iq,k)= tggsn(iq,k)-smelt1(k)*hlf/sgamm
>            enddo
>           endif
>          endif
>        endif   ! (nglacier.eq.2)
>       enddo               ! ip loop
552c529
<       include 'parm.h'      ! ktau,dt
---
>       include 'parm.h'      ! kstart,ktau,dt
567c544
<       dimension wbh(ms+1),z1(ms+1),z2(ms+1),z3(ms+1)
---
>       dimension wbh(ms+1),z1(ms+1),z2(ms+1),z3(ms+1),dtt(ms)
573c550
<      . dum3(5*ijk-16*ifull)
---
>      . dum3(2*ijk-16*ifull),uav(ifull,kl),vav(ifull,kl)
577,578d553
<       common/work3f/fluxh(ifull,0:ms),delt(ifull,0:ms),dtt(ifull,ms),
<      .              dum3f(3*ijk-3*ifull*ms-2*ifull)
580,581c555,556
<       real pwb_min(mxst),ssatcurr(ms)
<       real z1mult(ms+1)
---
>       real pwb_min(mxst),ssatcurr(ms),wbl(ms),speed(ms)
>       real z1mult(ms+1),fluxh(0:ms),delt(0:ms)
608,611c583,586
<       do k=1,ms ! preset to allow for non-land & snow points in trimb
<        at(:,k)=0.
<        bt(:,k)=1.
<        ct(:,k)=0.
---
>       do kq=1,ifull*ms ! preset to allow for non-land & snow points in trimb
>        at(kq,1)=0.
>        bt(kq,1)=1.
>        ct(kq,1)=0.
619a595,608
> *     vdir nodep
>       do ip=1,ipland  ! all land points in this nsib=1 or 3 loop
>        iq=iperm(ip)
>        isoil = isoilm(iq)
>        wbficemx=0.
>        do k=1,ms
>         ssatcurr(k)=ssat(isoil)-wbice(iq,k)
> !       this defn of wblf has different meaning from previous one in surfbv
> !       N.B. are imposing wbice<wb, so wblf <1
>         wblf(iq,k)=(wb(iq,k)-wbice(iq,k))/ssatcurr(k)
>         wbfice(iq,k)=wbice(iq,k)/ssat(isoil)
>         wbficemx=max(wbficemx,wbfice(iq,k))
>         dtt(k)=dt/(zse(k)*ssatcurr(k))
>        enddo
621,643c610,639
<       if(nmeth.le.0)then    ! ip loop split March '03
< !      jlm split TVD version
< !cdir nodep
<        do ip=1,ipland  ! all land points 
<         iq=iperm(ip)
<         delt(iq,0)=0.
<         fluxh(iq,0)=0.
<         fluxh(iq,ms)=0.
<       enddo   ! ip loop
<       do k=1,ms-1
< !cdir nodep
<        do ip=1,ipland  ! all land points 
<         iq=iperm(ip)
<         isoil = isoilm(iq)
<          wbl_k=wb(iq,k)-wbice(iq,k)      ! for calc. speed etc
<          wbl_kp=wb(iq,k+1)-wbice(iq,k+1)    
<          delt(iq,k)=wbl_kp-wbl_k         
< !        wh=(zse(k+1)*wbl(k)+zse(k)*wbl(k+1))/(zse(k)+zse(k+1))
< !        especially to allow for isolated frozen layers, use min speed
<          wh=min(wbl_k,wbl_kp)
< !        with 50% wbice, reduce hyds by 1.e-5
<          hydss=hyds(isoil)*(1.-min(2.*wbice(iq,k)/wb(iq,k),.99999))
<          speed_k=hydss*(wh/ssat(isoil))**(i2bp3(isoil)-1)
---
>        if(nmeth.le.0)then   ! jlm split TVD version
>          delt(0)=0.
>          fluxh(0)=0.
>          fluxh(ms)=0.
>          do k=1,ms
>           wbl(k)=wb(iq,k)-wbice(iq,k)      ! for calc. speed etc
>          enddo
>          do k=1,ms-1
> !         wh=(zse(k+1)*wbl(k)+zse(k)*wbl(k+1))/(zse(k)+zse(k+1))
> !         especially to allow for isolated frozen layers, use min speed
>           wh=min(wbl(k),wbl(k+1))
> !         with 50% wbice, reduce hyds by 1.e-5
>           hydss=hyds(isoil)*(1.-min(2.*wbice(iq,k)/wb(iq,k),.99999))
>           speed(k)=hydss*(wh/ssat(isoil))**(i2bp3(isoil)-1)
> !         update wb by TVD method
>           delt(k)=wbl(k+1)-wbl(k)
>           rat=delt(k-1)/(delt(k)+sign(1.e-20,delt(k)))
>           phi=max(0.,min(1.,2.*rat),min(2.,rat)) ! 0 for -ve rat
>           fluxhi=wh
>           fluxlo=wbl(k)
> 	   if(ntest.gt.0.and.iq.eq.idjd)then
> 	    print *,'in TVD for k= ',k
> 	    print *,'wbl,wh,hydss ',wbl(k),wh,hydss
> 	    print *,'speeda,speedb,fluxhi,fluxlo,delt,rat,phi ',
>      .              speed(k),.5*zse(k)/dt,fluxhi,fluxlo,delt(k),rat,phi
> 	   endif
> !         scale speed to grid lengths per dt & limit speed for stability
>           speed(k)=min(speed(k),.5*zse(k)/dt)  !  1. OK too for stability
>           fluxh(k)=speed(k)*(fluxlo+phi*(fluxhi-fluxlo))
>          enddo
645,666c641,645
<          rat=delt(iq,k-1)/(delt(iq,k)+sign(1.e-20,delt(iq,k)))
<          phi=max(0.,min(1.,2.*rat),min(2.,rat)) ! 0 for -ve rat
<          fluxhi=wh
<          fluxlo=wbl_k
< 	  if(ntest.gt.0.and.iq.eq.idjd)then
<   	   print *,'in TVD for k= ',k
< 	   print *,'wbl,wh,hydss ',wbl_k,wh,hydss
< 	   print *,'speeda,speedb,fluxhi,fluxlo,delt,rat,phi ',
<      .             speed_k,.5*zse(k)/dt,fluxhi,fluxlo,delt(iq,k),rat,phi
<  	  endif
< !        scale speed to grid lengths per dt & limit speed for stability
<          speed_k=min(speed_k,.5*zse(k)/dt)  !  1. OK too for stability
<          fluxh(iq,k)=speed_k*(fluxlo+phi*(fluxhi-fluxlo))
<         enddo    ! ip loop
<        enddo  ! k loop
< 	 
< !      update wb by TVD method
<        do k=ms,1,-1
< !cdir nodep
<         do ip=1,ipland  ! all land points 
<          iq=iperm(ip)
<          isoil = isoilm(iq)
---
>          if(nmeth.eq.0)then
>            do k=1,ms
>             wb(iq,k)=wb(iq,k)+dt*(fluxh(k-1)-fluxh(k))/zse(k)
>            enddo
>          endif   ! (nmeth.eq.0)
668,669c647,651
<            fluxh(iq,k-1)=min(fluxh(iq,k-1),
<      .	                 (ssat(isoil)-wb(iq,k))*zse(k)/dt +fluxh(iq,k))
---
>            do k=ms,1,-1
>             fluxh(k-1)=min(fluxh(k-1),
>      .	                    (ssat(isoil)-wb(iq,k))*zse(k)/dt +fluxh(k))
>             wb(iq,k)=wb(iq,k)+dt*(fluxh(k-1)-fluxh(k))/zse(k)
>            enddo
671d652
<          wb(iq,k)=wb(iq,k)+dt*(fluxh(iq,k-1)-fluxh(iq,k))/zse(k)
673,703c654,685
<          ssatcurr_k=ssat(isoil)-wbice(iq,k)
<          dtt(iq,k)=dt/(zse(k)*ssatcurr_k)
< !        this defn of wblf has different meaning from previous one in surfbv
< !        N.B. are imposing wbice<wb, so wblf <1
<          wblf(iq,k)=(wb(iq,k)-wbice(iq,k))/ssatcurr_k
<         enddo   ! ip loop
<        enddo    ! k=ms,1,-1 loop
< 	 
<        do k=2,ms ! wbh_k represents wblf(k-.5)
< !cdir nodep
<         do ip=1,ipland  ! all land points in this nsib=1 or 3 loop
<          iq=iperm(ip)
<          isoil = isoilm(iq)
<          ssatcurr_k=ssat(isoil)-wbice(iq,k)
<          wbh_k=(zse(k)*wblf(iq,k-1)+zse(k-1)*wblf(iq,k))
<      .          /(zse(k)+zse(k-1))
< !        wbh_k=min(wblf(iq,k-1),wblf(iq,k)) ! jlm to avoid wbice problems
<          fact=wbh_k**(ibp2(isoil)-1)   ! i.e. wbh**(bch+1)
< !        with 50% wbice, reduce hbsh by 1.e-5
<          wbicefrac=max(wbice(iq,k-1)/wb(iq,k-1),wbice(iq,k)/wb(iq,k))
<          hsbhh=hsbh(isoil)*(1.-min(2.*wbicefrac,.99999))
<          pwb_wbh=hsbhh*max( pwb_min(isoil),wbh_k*fact )
< !        moisture diffusivity (D) is  wbh*pwb; hsbh includes b
<          z3_k=pwb_wbh/zshh(k)            !  i.e. D(k-.5)/zshh(k)
<          at(iq,k) = -dtt(iq,k)*z3_k  ! where dtt=dt/(zse(k)*ssatcurr_k)
<          ct(iq,k-1) = -dtt(iq,k-1)*z3_k
<         enddo   ! ip loop
<        enddo   ! k loop
<       
<        do k=1,ms
<         do iq=1,ifull  ! can do all points
---
>          do k=1,ms
> !         this defn of wblf has different meaning from previous one in surfbv
> !         N.B. are imposing wbice<wb, so wblf <1
>           wblf(iq,k)=(wb(iq,k)-wbice(iq,k))/ssatcurr(k)
>          enddo
> 	  if(ntest.gt.0.and.iq.eq.idjd)then
> 	    print *,'midway through nmeth<=0'
> 	    print *,'fluxh ',(fluxh(k),k=1,ms)
>            write (6,"('wb   ',6f8.3)") (wb(idjd,k),k=1,ms)
>            write (6,"('wblf ',6f8.3)") (wblf(idjd,k),k=1,ms)    
>            totwbla=0.
>            do k=1,ms
>             totwbla=totwbla+zse(k)*wblf(iq,k)     ! diagnostic
>            enddo
>   	  endif
> 
>          do k=2,ms ! wbh(k) represents wblf(k-.5)
>           wbh(k)=(zse(k)*wblf(iq,k-1)+zse(k-1)*wblf(iq,k))
>      .           /(zse(k)+zse(k-1))
> !         wbh(k)=min(wblf(iq,k-1),wblf(iq,k)) ! jlm to avoid wbice problems
>           fact=wbh(k)**(ibp2(isoil)-1)   ! i.e. wbh**(bch+1)
> !         with 50% wbice, reduce hbsh by 1.e-5
>           wbicefrac=max(wbice(iq,k-1)/wb(iq,k-1),wbice(iq,k)/wb(iq,k))
>           hsbhh=hsbh(isoil)*(1.-min(2.*wbicefrac,.99999))
>           pwb_wbh=hsbhh*max( pwb_min(isoil),wbh(k)*fact )
> !         moisture diffusivity (D) is  wbh*pwb; hsbh includes b
>           z1(k)=0.                         ! zshh(k)= z(k)-z(k-1)
>           z3(k)=pwb_wbh/zshh(k)            !  i.e. D(k-.5)/zshh(k)
>           at(iq,k) = -dtt(k)*z3(k)  ! where dtt=dt/(zse(k)*ssatcurr(k))
>           ct(iq,k-1) = -dtt(k-1)*z3(k)
>          enddo
>          do k=1,ms
705,706c687,688
<         enddo   ! iq loop
<        enddo    ! k loop
---
>          enddo
>        endif   ! (nmeth.le.0)
708,783c690,726
< c        if(ntest.gt.0)then
< c          do k=1,ms
< c           if(wblf(iq,k).gt.wblfmx)then
< c             wblfmx=wblf(iq,k)
< c            iqmx=iq
< c          endif
< c           if(wblf(iq,k).lt.wblfmn)then
< c             wblfmn=wblf(iq,k)
< c             iqmn=iq
< c           endif
< c          enddo
< c        endif
<         if(ntest.gt.0)then
< 	   print *,'midway through nmeth<=0'
< 	   print *,'fluxh ',(fluxh(iq,k),k=1,ms)
<           write (6,"('wb   ',6f8.3)") (wb(idjd,k),k=1,ms)
<           write (6,"('wblf ',6f8.3)") (wblf(idjd,k),k=1,ms)    
< c          totwbla=0.
< c          do k=1,ms
< c           totwbla=totwbla+zse(k)*wblf(iq,k)     ! diagnostic
< c          enddo
<           totwbb=0.
<           totwblb=0.
<           do k=1,ms
<            totwbb=totwbb+zse(k)*wb(idjd,k)         ! diagnostic
<            totwblb=totwblb+zse(k)*wblf(idjd,k)     ! diagnostic
<           enddo
<           print *,'nmeth, b+2, 2b+3: ',nmeth,ibp2(isoil),i2bp3(isoil)
<           write (6,"('wb   ',6f8.3)") (wb(idjd,k),k=1,ms)
<           write (6,"('wbice',6f8.3)") (wbice(idjd,k),k=1,ms)
<           write (6,"('wblf ',6f8.3)") (wblf(idjd,k),k=1,ms)
<           write (6,"('ssatcurr',6f8.3)") ssatcurr
< c	   print *,'pwb_wbh,pwb_min* for ms ',
< c     .             pwb_wbh,hsbh(isoil)*pwb_min(isoil)
< c          print *,'wblfmx,wblfmn,iqmx,iqmn ',wblfmx,wblfmn,iqmx,iqmn
< c          print *,'dtt ',dtt
<           print *,'zse ',zse
< c          print *,'zshh ',zshh
<           print *,'at ',(at(idjd,k),k=1,ms)
<           print *,'bt ',(bt(idjd,k),k=1,ms)
<           print *,'ct ',(ct(idjd,k),k=1,ms)
<         endif  ! (ntest.gt.0)
< 
< !  xcdir nodep
<        do ip=1,ipland  ! all land points 
<         iq=iperm(ip)
<         isoil = isoilm(iq)
< c       ssatcurr_1=ssat(isoil)-wbice(iq,1)  
< c       dtt_1=dt/(zse(1)*ssatcurr_1)       ! needed for nodep on SX5!!
<         wblf(iq,1)=wblf(iq,1)+dtt(iq,1)*fwtop(iq)/rhowat
< c       rhs(1) = wblf(iq,1)      ! for A
<        enddo   ! ip loop
<       endif    ! (nmeth.le.0)
< c          write (6,"('wb   ',6f8.3)") (wb(idjd,k),k=1,ms)
< c          write (6,"('wbice',6f8.3)") (wbice(idjd,k),k=1,ms)
< c*          write (6,"('wblfa ',6f8.3)") (wblfa(idjd,k),k=1,ms)
< c          write (6,"('wblf ',6f8.3)") (wblf(idjd,k),k=1,ms)
< c          print *,'at ',(at(idjd,k),k=1,ms)
< c          print *,'bt ',(bt(idjd,k),k=1,ms)
< c          print *,'ct ',(ct(idjd,k),k=1,ms)
< 
<       if(nmeth.gt.0)then    ! ip loop split March '03
< !cdir nodep
<        do ip=1,ipland  ! all land points in this nsib=1 or 3 loop
<         iq=iperm(ip)
<         isoil = isoilm(iq)
<         wbficemx=0.
<         do k=1,ms
<          ssatcurr(k)=ssat(isoil)-wbice(iq,k)
< !        this defn of wblf has different meaning from previous one in surfbv
< !        N.B. are imposing wbice<wb, so wblf <1
<          wblf(iq,k)=(wb(iq,k)-wbice(iq,k))/ssatcurr(k)
<          wbfice(iq,k)=wbice(iq,k)/ssat(isoil)
<          wbficemx=max(wbficemx,wbfice(iq,k))
<          dtt(iq,k)=dt/(zse(k)*ssatcurr(k))
<         enddo
---
>        if(nmeth.eq.1)then  ! full implicit method
>          do k=2,ms
> !         wbh(k)=min(1.,ww(k)*wblf(iq,k-1)+(1.-ww(k))*wblf(iq,k))
> !         jlm: this is same as:
>           wbh(k)=(zse(k)*wblf(iq,k-1)+zse(k-1)*wblf(iq,k))
>      .           /(zse(k)+zse(k-1))
>           fact=wbh(k)**(ibp2(isoil)-1)   ! i.e. wbh**(bch+1)
>           fact2=fact*fact
>           pwb = hsbh(isoil)*fact
> !         moisture diffusivity (D) is  wbh*pwb
> !         other term (K) is wbh*hyds(isoil)*fact2
>           z1(k)=wbh(k)*( (i2bp3(isoil)-1)*hyds(isoil)*fact2
>      &      -ibp2(isoil)*pwb*(wblf(iq,k)-wblf(iq,k-1))/zshh(k) )
>           z2(k)=-i2bp3(isoil)*hyds(isoil)*fact2
>      &      + ibp2(isoil)*pwb*(wblf(iq,k)-wblf(iq,k-1))/zshh(k)
>           z3(k)=pwb*wbh(k)/zshh(k)
> !         the above pwb, z1, z2, z3 are equivalent to:
> !         pwb = max(hsbh(isoil)*(wbh(k)**(ibp2(isoil)-1)),eps)
> !         z1(k)=(-1.+i2bp3(isoil))*hyds(isoil) *wbh(k)**i2bp3(isoil)
> !    &      -ibp2(isoil)*pwb*wbh(k)*(wblf(iq,k)-wblf(iq,k-1))/zshh(k)
> !         z2(k)=-i2bp3(isoil)*hyds(isoil) *wbh(k)**(i2bp3(isoil)-1)
> !    &      + ibp2(isoil)*pwb*(wblf(iq,k)-wblf(iq,k-1))/zshh(k)
> !         z3(k)=pwb*wbh(k)/zshh(k)
>           at(iq,k) = dtt(k)*( z2(k)*.5*zse(k)/zshh(k) -z3(k) )
>          enddo
>          do k=1,ms-1
>             ml = max (k-1,1)
>             ct(iq,k)=dtt(k)*( -z2(k+1)*.5*zse(k)/zshh(k+1) -z3(k+1) )
> !           c3(k)=ct(iq,k)     ! for A
>             bt(iq,k)=1.+dtt(k)*( -z2(k+1)*.5*zse(k+1)/zshh(k+1)
>      &               + z2(k)*.5*zse(ml)/zshh(k)+z3(k+1)+z3(k) )
>          enddo
>          bt(iq,ms)=1.+dtt(ms)*( z2(ms)*.5*zse(ms)/zshh(ms) +z3(ms) )
>          do k=1,ms
>           wblf(iq,k) = wblf(iq,k)+dtt(k)*( z1(k+1) - z1(k) )
>          enddo
>        endif   ! (nmeth.eq.1)  ! full implicit method
785,926c728,831
<         if(nmeth.eq.1)then  ! full implicit method
<           do k=2,ms
< !          wbh(k)=min(1.,ww(k)*wblf(iq,k-1)+(1.-ww(k))*wblf(iq,k))
< !          jlm: this is same as:
<            wbh(k)=(zse(k)*wblf(iq,k-1)+zse(k-1)*wblf(iq,k))
<      .            /(zse(k)+zse(k-1))
<            fact=wbh(k)**(ibp2(isoil)-1)   ! i.e. wbh**(bch+1)
<            fact2=fact*fact
<            pwb = hsbh(isoil)*fact
< !          moisture diffusivity (D) is  wbh*pwb
< !          other term (K) is wbh*hyds(isoil)*fact2
<            z1(k)=wbh(k)*( (i2bp3(isoil)-1)*hyds(isoil)*fact2
<      &       -ibp2(isoil)*pwb*(wblf(iq,k)-wblf(iq,k-1))/zshh(k) )
<            z2(k)=-i2bp3(isoil)*hyds(isoil)*fact2
<      &       + ibp2(isoil)*pwb*(wblf(iq,k)-wblf(iq,k-1))/zshh(k)
<            z3(k)=pwb*wbh(k)/zshh(k)
< !          the above pwb, z1, z2, z3 are equivalent to:
< !          pwb = max(hsbh(isoil)*(wbh(k)**(ibp2(isoil)-1)),eps)
< !          z1(k)=(-1.+i2bp3(isoil))*hyds(isoil) *wbh(k)**i2bp3(isoil)
< !    &       -ibp2(isoil)*pwb*wbh(k)*(wblf(iq,k)-wblf(iq,k-1))/zshh(k)
< !          z2(k)=-i2bp3(isoil)*hyds(isoil) *wbh(k)**(i2bp3(isoil)-1)
< !    &       + ibp2(isoil)*pwb*(wblf(iq,k)-wblf(iq,k-1))/zshh(k)
< !          z3(k)=pwb*wbh(k)/zshh(k)
<            at(iq,k) = dtt(iq,k)*( z2(k)*.5*zse(k)/zshh(k) -z3(k) )
<           enddo
<           do k=1,ms-1
<              ml = max (k-1,1)
<              ct(iq,k)=dtt(iq,k)*( -z2(k+1)*.5*zse(k)/zshh(k+1) -z3(k+1))
< !            c3(k)=ct(iq,k)     ! for A
<              bt(iq,k)=1.+dtt(iq,k)*( -z2(k+1)*.5*zse(k+1)/zshh(k+1)
<      &                + z2(k)*.5*zse(ml)/zshh(k)+z3(k+1)+z3(k) )
<           enddo
<           bt(iq,ms)=1.+dtt(iq,ms)*( z2(ms)*.5*zse(ms)/zshh(ms) +z3(ms) )
<           do k=1,ms
<            wblf(iq,k) = wblf(iq,k)+dtt(iq,k)*( z1(k+1) - z1(k) )
<           enddo
<         endif   ! (nmeth.eq.1)  ! full implicit method
< 
<         if(nmeth.ge.2)then  ! part implicit method
<           do k=2,ms
<            z1mult(k)=i2bp3(isoil)   ! corresponds to 2b+3
<           enddo
<           do k=2,ms ! wbh(k) represents wblf(k-.5)
<            wbh(k)=(zse(k)*wblf(iq,k-1)+zse(k-1)*wblf(iq,k))
<      .            /(zse(k)+zse(k-1))
< !          wbh(k)=min(wblf(iq,k-1),wblf(iq,k)) ! jlm to avoid wbice problems
<            fact=wbh(k)**(ibp2(isoil)-1)   ! i.e. wbh**(bch+1)
<            if(nmeth.eq.2)pwb_wbh=hsbh(isoil)*wbh(k)*fact
<            if(nmeth.ge.3)pwb_wbh=hsbh(isoil)
<      .                           *max( pwb_min(isoil),wbh(k)*fact )
<            fact2=fact*fact
< !          moisture diffusivity (D) is  wbh*pwb
< !          other term (K) is wbh*hyds(isoil)*fact2
<            z1(k)=hyds(isoil)*fact2     !  i.e. K(k-.5)/wbh(k)
<            z3(k)=pwb_wbh/zshh(k)            !  i.e. D(k-.5)/zshh(k)
<            at(iq,k) = -dtt(iq,k)*z3(k)
<            ct(iq,k-1) = -dtt(iq,k-1)*z3(k)
<           enddo
<           do k=1,ms
<            bt(iq,k)=1.-at(iq,k)-ct(iq,k)
<           enddo
<           if(nmeth.eq.4)then   ! for simple implicit D, implicit K
<             bt(iq,1)=bt(iq,1)
<      .        +dtt(iq,1)*z1mult(1+1)*z1(1+1)*zse(1+1)/(zse(1)+zse(1+1))
<             do k=2,ms
<              at(iq,k)=at(iq,k)
<      .           -dtt(iq,k)*z1mult(k)*z1(k)*zse(k)/(zse(k)+zse(k-1))
<              ct(iq,k-1)=ct(iq,k-1)
<      .           +dtt(iq,k-1)*z1mult(k)*z1(k)*zse(k-1)/(zse(k)+zse(k-1))
<              bt(iq,k)=bt(iq,k)
<      .         -dtt(iq,k)*z1mult(k)*z1(k)*zse(k-1)/(zse(k)+zse(k-1))
<      .         +dtt(iq,k)*z1mult(k+1)*z1(k+1)*zse(k+1)/(zse(k)+zse(k+1))
<             enddo
<           endif  ! (nmeth.eq.4)
<           do k=2,ms
<            z1(k)=wbh(k)*z1(k)     !  i.e. now K(k-.5)
<           enddo
< !         the following top & bottom b.c.'s will preserve a uniform column
< c         z1(1) =z1(2)   ! simple dk/dz=0
< c         z1(ms+1)=z1(ms) ! simple dk/dz=0
<           z1(1) =min(z1(2),z1(ms))   !  N.B. z1 are here +ve
<           z1(ms+1)=z1(1)
<           if(wbficemx.lt..75)then ! no gravit. term if too much ice 11/12/00
<             do k=1,ms
<              if(nmeth.eq.4)then
<                wblf(iq,k)=wblf(iq,k)+dtt(iq,k)*((z1mult(k+1)-1.)*z1(k+1)
<      .                     - (z1mult(k)-1.)*z1(k) )
<              else
<                wblf(iq,k) = wblf(iq,k)+dtt(iq,k)*( z1(k) - z1(k+1) )
<              endif  ! (nmeth.eq.4) .. else ..
< c            rhs(k) = wblf(iq,k)      ! for A
<             enddo
<           endif  ! (wbficemx.lt..75)
<         endif    ! (nmeth.ge.2)
< 
<         if(ntest.gt.0)then
<           do k=1,ms
<            if(wblf(iq,k).gt.wblfmx)then
<              wblfmx=wblf(iq,k)
<              iqmx=iq
<            endif
<            if(wblf(iq,k).lt.wblfmn)then
<              wblfmn=wblf(iq,k)
<              iqmn=iq
<            endif
<           enddo
<         endif
<         if(ntest.gt.0.and.iq.eq.idjd)then
<           totwbb=0.
<           totwblb=0.
<           do k=1,ms
<            totwbb=totwbb+zse(k)*wb(iq,k)         ! diagnostic
<            totwblb=totwblb+zse(k)*wblf(iq,k)     ! diagnostic
<           enddo
<           print *,'nmeth, b+2, 2b+3: ',nmeth,ibp2(isoil),i2bp3(isoil)
<           write (6,"('wb   ',6f8.3)") (wb(idjd,k),k=1,ms)
<           write (6,"('wbice',6f8.3)") (wbice(idjd,k),k=1,ms)
<           write (6,"('wblf ',6f8.3)") (wblf(idjd,k),k=1,ms)
<           write (6,"('wbh  ',7f8.3)") wbh
<           write (6,"('ssatcurr',6f8.3)") ssatcurr
< 	   print *,'pwb_wbh,pwb_min* for ms ',
<      .             pwb_wbh,hsbh(isoil)*pwb_min(isoil)
<           print *,'wblfmx,wblfmn,iqmx,iqmn ',wblfmx,wblfmn,iqmx,iqmn
< c         print *,'dtt ',dtt
<           print *,'zse ',zse
<           print *,'zshh ',zshh
<           print *,'at ',(at(iq,k),k=1,ms)
<           print *,'bt ',(bt(iq,k),k=1,ms)
<           print *,'ct ',(ct(iq,k),k=1,ms)
<         endif  ! (ntest.gt.0.and.iq.eq.idjd)
< 
<         if(nmeth.eq.3)then
< !         artificial fix applied here for safety (explicit nmeth only)
<           do k=1,ms
<            wblf(iq,k)=max(0.,min(wblf(iq,k),1.))
<           enddo
<         endif   ! (nmeth.eq.3)
< 
<         wblf(iq,1)=wblf(iq,1)+dtt(iq,1)*fwtop(iq)/rhowat
< c       rhs(1) = wblf(iq,1)      ! for A
<        enddo   ! ip loop
<       endif   ! (nmeth.gt.0)
---
>        if(nmeth.ge.2)then  ! part implicit method
>          do k=2,ms
>           z1mult(k)=i2bp3(isoil)   ! corresponds to 2b+3
>          enddo
>          do k=2,ms ! wbh(k) represents wblf(k-.5)
>           wbh(k)=(zse(k)*wblf(iq,k-1)+zse(k-1)*wblf(iq,k))
>      .           /(zse(k)+zse(k-1))
> !         wbh(k)=min(wblf(iq,k-1),wblf(iq,k)) ! jlm to avoid wbice problems
>           fact=wbh(k)**(ibp2(isoil)-1)   ! i.e. wbh**(bch+1)
>           if(nmeth.eq.2)pwb_wbh=hsbh(isoil)*wbh(k)*fact
>           if(nmeth.ge.3)pwb_wbh=hsbh(isoil)
>      .                          *max( pwb_min(isoil),wbh(k)*fact )
>           fact2=fact*fact
> !         moisture diffusivity (D) is  wbh*pwb
> !         other term (K) is wbh*hyds(isoil)*fact2
>           z1(k)=hyds(isoil)*fact2     !  i.e. K(k-.5)/wbh(k)
>           z3(k)=pwb_wbh/zshh(k)            !  i.e. D(k-.5)/zshh(k)
>           at(iq,k) = -dtt(k)*z3(k)
>           ct(iq,k-1) = -dtt(k-1)*z3(k)
>          enddo
>          do k=1,ms
>           bt(iq,k)=1.-at(iq,k)-ct(iq,k)
>          enddo
>          if(nmeth.eq.4)then   ! for simple implicit D, implicit K
>            bt(iq,1)=bt(iq,1)
>      .         +dtt(1)*z1mult(1+1)*z1(1+1)*zse(1+1)/(zse(1)+zse(1+1))
>            do k=2,ms
>             at(iq,k)=at(iq,k)
>      .          -dtt(k)*z1mult(k)*z1(k)*zse(k)/(zse(k)+zse(k-1))
>             ct(iq,k-1)=ct(iq,k-1)
>      .          +dtt(k-1)*z1mult(k)*z1(k)*zse(k-1)/(zse(k)+zse(k-1))
>             bt(iq,k)=bt(iq,k)
>      .          -dtt(k)*z1mult(k)*z1(k)*zse(k-1)/(zse(k)+zse(k-1))
>      .          +dtt(k)*z1mult(k+1)*z1(k+1)*zse(k+1)/(zse(k)+zse(k+1))
>            enddo
>          endif  ! (nmeth.eq.4)
>          do k=2,ms
>           z1(k)=wbh(k)*z1(k)     !  i.e. now K(k-.5)
>          enddo
> !        the following top & bottom b.c.'s will preserve a uniform column
> c        z1(1) =z1(2)   ! simple dk/dz=0
> c        z1(ms+1)=z1(ms) ! simple dk/dz=0
>          z1(1) =min(z1(2),z1(ms))   !  N.B. z1 are here +ve
>          z1(ms+1)=z1(1)
>          if(wbficemx.lt..75)then ! no gravit. term if too much ice 11/12/00
>            do k=1,ms
>             if(nmeth.eq.4)then
>               wblf(iq,k)=wblf(iq,k)+dtt(k)*( (z1mult(k+1)-1.)*z1(k+1)
>      .                    - (z1mult(k)-1.)*z1(k) )
>             else
>               wblf(iq,k) = wblf(iq,k)+dtt(k)*( z1(k) - z1(k+1) )
>             endif  ! (nmeth.eq.4) .. else ..
> c           rhs(k) = wblf(iq,k)      ! for A
>            enddo
>          endif  ! (wbficemx.lt..75)
>        endif    ! (nmeth.ge.2)
> 
>        if(ntest.gt.0)then
>          do k=1,ms
>           if(wblf(iq,k).gt.wblfmx)then
>             wblfmx=wblf(iq,k)
>             iqmx=iq
>           endif
>           if(wblf(iq,k).lt.wblfmn)then
>             wblfmn=wblf(iq,k)
>             iqmn=iq
>           endif
>          enddo
>        endif
>        if(ntest.gt.0.and.iq.eq.idjd)then
>          totwbb=0.
>          totwblb=0.
>          do k=1,ms
>           totwbb=totwbb+zse(k)*wb(iq,k)         ! diagnostic
>           totwblb=totwblb+zse(k)*wblf(iq,k)     ! diagnostic
>          enddo
>          print *,'nmeth, b+2, 2b+3: ',nmeth,ibp2(isoil),i2bp3(isoil)
>          write (6,"('wb   ',6f8.3)") (wb(idjd,k),k=1,ms)
>          write (6,"('wbice',6f8.3)") (wbice(idjd,k),k=1,ms)
>          write (6,"('wblf ',6f8.3)") (wblf(idjd,k),k=1,ms)
>          write (6,"('wbh  ',7f8.3)") wbh
>          write (6,"('speed',6f8.3)") (speed(k)*dt/zse(k),k=1,ms-1)
>          write (6,"('ssatcurr',6f8.3)") ssatcurr
> 	  print *,'pwb_wbh,pwb_min* for ms ',
>      .            pwb_wbh,hsbh(isoil)*pwb_min(isoil)
>          print *,'wblfmx,wblfmn,iqmx,iqmn ',wblfmx,wblfmn,iqmx,iqmn
>          print *,'dtt ',dtt
>          print *,'zse ',zse
>          print *,'zshh ',zshh
>          print *,'at ',(at(iq,k),k=1,ms)
>          print *,'bt ',(bt(iq,k),k=1,ms)
>          print *,'ct ',(ct(iq,k),k=1,ms)
>        endif  ! (ntest.gt.0.and.iq.eq.idjd)
> 
>        if(nmeth.eq.3)then
> !        artificial fix applied here for safety (explicit nmeth only)
>          do k=1,ms
>           wblf(iq,k)=max(0.,min(wblf(iq,k),1.))
>          enddo
>        endif   ! (nmeth.eq.3)
> 
>        wblf(iq,1)=wblf(iq,1)+dtt(1)*fwtop(iq)/rhowat
> c      rhs(1) = wblf(iq,1)      ! for A
>       enddo   ! ip loop
931c836
< !cdir nodep
---
> *     vdir nodep
956c861
<         print *,'totwblb,totwblc ',totwblb,totwblc
---
>         print *,'totwbla,totwblb,totwblc ',totwbla,totwblb,totwblc
968c873
<       include 'parm.h'      ! ktau,dt
---
>       include 'parm.h'      ! kstart,ktau,dt
984c889
<      . ,factch(ifull),qsttg(ifull),rho(ifull),zo(ifull)
---
>      . ,factch(ifull),rsts(ifull),rho(ifull),zo(ifull)
992c897
<      . dum3(5*ijk-18*ifull)
---
>      . dum3(2*ijk-18*ifull),uav(ifull,kl),vav(ifull,kl)
1005,1008c910,913
<       do k=-2,ms ! preset to allow for non-land & snow points in trimb
<        at(:,k)=0.
<        bt(:,k)=1.
<        ct(:,k)=0.
---
>       do kq=1,ifull*(ms+3) ! preset to allow for non-land & snow points in trimb
>        at(kq,-2)=0.
>        bt(kq,-2)=1.
>        ct(kq,-2)=0.
1013c918
< *cdir nodep
---
> *     vdir nodep
1023a929
> c         if(ew.lt.0.)print *,'-ve ew for iq= ',iq,ew
1034c940
< *cdir nodep
---
> *     vdir nodep
1108a1015,1019
> cx    do kq=1,ifull*(ms+3) ! preset to allow for non-land & snow points in trimb
> cx     at(kq,-2)=0.
> cx     bt(kq,-2)=1.
> cx     ct(kq,-2)=0.
> cx    enddo
1110,1111c1021
< ! ****** next cdir nodep does not work on SX5 ****************      
< * xcdir nodep
---
> *     vdir nodep
1192,1194c1102
< *cdir nodep
<       do ip=1,ipland  ! all land points in this nsib=1 or 3 loop
<        iq=iperm(ip)
---
>       do iq=1,ifull
1202,1203c1110,1111
<        gflux(iq) =coefb(iq)*(  tgg(iq,1)-  tgg(iq,2))  ! +ve downwards
<       enddo   ! ip=1,ipland           land points
---
>        gflux(iq) =coefb(iq)*(  tgg(iq,1)-  tgg(iq,2))
>       enddo
1221c1129
<       include 'parm.h'      ! ktau,dt
---
>       include 'parm.h'      ! kstart,ktau,dt
=====================================
 
solargh.f
=====================================
1a2,4
> c Revision 1.1.1.1  2002/12/18 23:02:17  dix043
> c Source imported from farrer:~cslm/ccam
> c
=====================================
 
spa88.f
=====================================
45c45
<       parameter (ndum=5*ijk- imax*(3*lp1 +9*l))  !jlm for 64-bit machine
---
>       parameter (ndum=4*ijk- imax*(3*lp1 +9*l))  !jlm for 64-bit machine
=====================================
 
srccom.f
=====================================
1c1,4
< c $Log$
< c Revision 1.1  2003/08/13 01:24:20  dix043
< c Initial revision
< c
---
> c $Log$
> c Revision 1.1  2003/08/13 01:24:20  dix043
> c Initial revision
> c
> c Revision 1.1.1.1  2002/12/18 23:02:17  dix043
> c Source imported from farrer:~cslm/ccam
> c
=====================================
 
sscam2.f
=====================================
=====================================
 
sst.f
=====================================
1a2,4
> c Revision 1.1.1.1  2002/12/18 23:02:17  dix043
> c Source imported from farrer:~cslm/ccam
> c
=====================================
 
staguv.f
=====================================
2,4c2,3
< !     stripped down version just with nstag=nstagu=-3, mstagpt=-3      
< !     staguv    may be called from adjust5, upglobal
< !     unstaguv  may be called from adjust5,  nonlin
---
> !     staguv    may be called from adjust5, indata, upglobal
> !     unstaguv  may be called from adjust5, indata, nonlin
11d9
< c                          !    only -3 used nowadays
12a11,15
> c     mst_bs now in parm.h   ! for mst_bs=1 uses sun & yeh 1997 monotonic filter
> c                            ! for mst_bs=2 uses B & S monotonic filter
> c                            ! for mst_bs=3 uses jlm 2nd derivative filter
> c                            ! for mst_bs=4 uses jlm version of sun & yeh
> c     mstu_bs now in parm.h  ! same but for unstaguv
30c33
<       data itnmax/3/
---
>       real uc(ifull),vc(ifull),wc(ifull)
38,47c41,548
< !     if(nstag.eq.-3)then
< !       call reva6(uin,vin,uout,vout,ua,va,ub,vb,ud,vd)
< !     endif    !  (nstag.eq.-3)
< !cdir nodep
< c       do iq=1,ifull   ! precalculate rhs terms
< c         ud(iwu2(iq))= uin(iwu2(iq))/2.+uin(iq)+uin(ieu2(iq))/10.
< c         vd(isv2(iq))= vin(isv2(iq))/2.+vin(iq)+vin(inv2(iq))/10.
< c       enddo
<          do iq=2,ifull-1
<           ud(iq-1)= uin(iq-1)/2.+uin(iq)+uin(iq+1)/10.
---
>       if(nstag.eq.0)then
> !cdir nodep
>         do iq=1,ifull
>           ua(iq)=.5*(uin(ieu2(iq))+uin(iq))
>           ud(iq)=    uin(ieu2(iq))-uin(iq)
>           va(iq)=.5*(vin(inv2(iq))+vin(iq))
>           vd(iq)=    vin(inv2(iq))-vin(iq)
>         enddo   ! iq loop
> c       now combine the above to give cubic interpolated values
> !cdir nodep
>         do iq=1,ifull
>           uout(iq)=ua(iq)-(ud(ieu2(iq))-ud(iwu2(iq)))/16.
>           vout(iq)=va(iq)-(vd(inv2(iq))-vd(isv2(iq)))/16.
>         enddo   ! iq loop
> c       write (32,*) 'uout nstag=0 staguv ktau = ',ktau
> c       write (32,90) (nint(uout(iq)),iq=1,ifull)
> c       write (32,*) 'vout nstag=0 staguv ktau = ',ktau
> c       write (32,90) (nint(vout(iq)),iq=1,ifull)
>       endif  ! (nstag.eq.0)
>       if(nstag.eq.1)go to 7
>       if(nstag.eq.2)then    ! linear weighted (no mst_bs provided)
>         do iq=1,ifull       ! this option seems to crash early with staguv
>           ua(iq)=u(iq)
>           va(iq)=v(iq)
>         enddo   ! iq loop
>         do iq=1,ifull
>           avma=em(iq)+emu(iq)
>           avmb=emu(iq)+em(ieu2(iq))
>           uout(iq)=(avma*ua(iq)+avmb*ua(ieu2(iq)))/(avma+avmb)
>           avma=em(iq)+emv(iq)
>           avmb=emv(iq)+em(inv2(iq))
>           vout(iq)=(avma*va(iq)+avmb*va(inv2(iq)))/(avma+avmb)
>         enddo   ! iq loop
>       endif    ! (nstag.eq.2)
> 
>       if(nstag.eq.10)then
>         call rev_stag(uin,vin,uout,vout,ua,va,ub,vb,ud,vd)
>       endif    !  (nstag.eq.10)
>       if(nstag.eq.3)then
>         call reva(uin,vin,uout,vout,ua,va,ub,vb,ud,vd)
>       endif    !  (nstag.eq.3)
>       if(nstag.eq.4)then
>         call reva_b(uin,vin,uout,vout,ua,va,ub,vb,ud,vd)
>       endif    !  (nstag.eq.4)
>       if(nstag.eq.5.or.nstag.eq.55)then
>         if(mod(ktau,2).eq.0)then
>           call reva(uin,vin,uout,vout,ua,va,ub,vb,ud,vd)
>         else
>           call reva_b(uin,vin,uout,vout,ua,va,ub,vb,ud,vd)
>         endif    !  (mod(ktau,2).eq.0)
>       endif    !  (nstag.eq.5)
>       if(nstag.eq.6)then  ! 6-point centred formula
> !cdir nodep
>         do iq=1,ifull
>          ua(ieu2(iq))=(3.*uin(iwu2(iq))-25.*uin(iq)+150.*uin(ieu2(iq)))
>      .                /(8.*32.)
>          va(inv2(iq))=(3.*vin(isv2(iq))-25.*vin(iq)+150.*vin(inv2(iq)))
>      .                /(8.*32.)
>          ud(iwu2(iq))=(3.*uin(ieu2(iq))-25.*uin(iq)+150.*uin(iwu2(iq)))
>      .                /(8.*32.)
>          vd(isv2(iq))=(3.*vin(inv2(iq))-25.*vin(iq)+150.*vin(isv2(iq)))
>      .                /(8.*32.)
>         enddo   ! iq loop
> c       now combine the above to give quintic interpolated values
>          do iq=1,ifull
>            uout(iq)=ua(iq)+ud(ieu2(iq))
>            vout(iq)=va(iq)+vd(inv2(iq))
>          enddo   ! iq loop
>       endif  ! (nstag.eq.6)
>       if(nstag.eq.7)then          ! does reversible Akima
>         if(mod(ktau,2).eq.0)then
>           call reka(uin,vin,uout,vout,ua,va,ub,vb,ud,vd)
>         else
>           call reka_b(uin,vin,uout,vout,ua,va,ub,vb,ud,vd)
>         endif    !  (mod(ktau,2).eq.0)
>       endif    !  (nstag.eq.7)
>       if(nstag.eq.8)then
>           call reka(uin,vin,uout,vout,ua,va,ub,vb,ud,vd)
>       endif    !  (nstag.eq.8)
>       if(nstag.eq.9)then
>           call reka_b(uin,vin,uout,vout,ua,va,ub,vb,ud,vd)
>       endif    !  (nstag.eq.9)
> 
> 35    if(mst_bs.eq.1)then    ! staguv code
> !cdir nodep
>         do iq=1,ifull
>           ud(iq)=    uin(ieu2(iq))-uin(iq)
>           vd(iq)=    vin(inv2(iq))-vin(iq)
>         enddo   ! iq loop
> !cdir nodep
>         do iq=1,ifull
>           if(ud(iwu2(iq))*ud(ieu2(iq)).ge.0.)then
>             umin=min(uin(iq),uin(ieu2(iq)))
>             umax=max(uin(iq),uin(ieu2(iq)))
>             uout(iq)=min( max(umin,uout(iq)) , umax )
>           endif
>           if(vd(isv2(iq))*vd(inv2(iq)).ge.0.)then
>             vmin=min(vin(iq),vin(inv2(iq)))
>             vmax=max(vin(iq),vin(inv2(iq)))
>             vout(iq)=min( max(vmin,vout(iq)) , vmax )
>           endif
>         enddo   ! iq loop
>       elseif(mst_bs.eq.2)then    ! staguv code   B & S
> !cdir nodep
>         do iq=1,ifull
>             umin=min(uin(iq),uin(ieu2(iq)))
>             umax=max(uin(iq),uin(ieu2(iq)))
>             uout(iq)=min( max(umin,uout(iq)) , umax )
>             vmin=min(vin(iq),vin(inv2(iq)))
>             vmax=max(vin(iq),vin(inv2(iq)))
>             vout(iq)=min( max(vmin,vout(iq)) , vmax )
>         enddo   ! iq loop
>       elseif(mst_bs.eq.3)then    ! staguv code   jlm 2nd derivative test
>         do iq=1,ifull
>           ud(iq)=    uin(ieu2(iq))+uin(iwu2(iq))-2.*uin(iq)
>           vd(iq)=    vin(inv2(iq))+vin(isv2(iq))-2.*vin(iq)
>         enddo   ! iq loop
>         do iq=1,ifull
>           if(ud(iq)*ud(ieu2(iq)).lt.0.)then     ! staguv
>             uout(iq)=ua(iq)                     ! use linear here
>           endif
>           if(vd(iq)*vd(inv2(iq)).lt.0.)then     ! staguv
>             vout(iq)=va(iq)                     ! use linear here
>           endif
>         enddo   ! iq loop
>       elseif(mst_bs.eq.4)then    ! staguv code  jlm version of S & Y
>         do iq=1,ifull
>           ud(iq)=    uin(ieu2(iq))-uin(iq)
>           vd(iq)=    vin(inv2(iq))-vin(iq)
>           ua(iq)=-1.    ! just used as indicator here
>           va(iq)=-1.    ! just used as indicator here
>         enddo   ! iq loop
> !cdir nodep
>         do iq=1,ifull
>           if(ud(iq)*ud(ieu2(iq)).gt.0.)
>      .              ua(iwu2(iq))=ua(iwu2(iq))+.7 ! extreme value allowed
>           if(ud(iwu2(iq))*ud(iq).gt.0.)
>      .              ua(ieu2(iq))=ua(ieu2(iq))+.7 ! extreme value allowed
>           if(vd(iq)*vd(inv2(iq)).gt.0.)
>      .              va(isv2(iq))=va(isv2(iq))+.7 ! extreme value allowed
>           if(vd(isv2(iq))*vd(iq).gt.0.)
>      .              va(inv2(iq))=va(inv2(iq))+.7 ! extreme value allowed
>         enddo   ! iq loop
> !cdir nodep
>         do iq=1,ifull
>           if(ua(iq).lt.0.)then
>             umin=min(uin(iq),uin(ieu2(iq)))
>             umax=max(uin(iq),uin(ieu2(iq)))
>             uout(iq)=min( max(umin,uout(iq)) , umax )
>           endif
>           if(va(iq).lt.0.)then
>             vmin=min(vin(iq),vin(inv2(iq)))
>             vmax=max(vin(iq),vin(inv2(iq)))
>             vout(iq)=min( max(vmin,vout(iq)) , vmax )
>           endif
>         enddo   ! iq loop
>       endif      !   (mst_bs.eq.1) else (mst_bs.eq.2) else (mst_bs.eq.3) else (mst_bs.eq.4)
>       return
> 
>       entry unstaguv(u,v,uout,vout)
> c     staggered u & v as input; unstaggered as output
>       do iq=1,ifull
>        uin(iq)=u(iq)
>        vin(iq)=v(iq)
>       enddo   ! iq loop
> 
>       if(nstagu.le.1)then
> !cdir nodep
>         do iq=1,ifull
>           ua(iq)=.5*(uin(iq)+uin(iwu2(iq)))
>           ud(iq)=    uin(iq)-uin(iwu2(iq))
>           va(iq)=.5*(vin(iq)+vin(isv2(iq)))
>           vd(iq)=    vin(iq)-vin(isv2(iq))
>         enddo   ! iq loop
> c       now combine the above to give cubic interpolated values
> !cdir nodep
>         do iq=1,ifull
>           uout(iq)=ua(iq)-(ud(ieu2(iq))-ud(iwu2(iq)))/16.
>           vout(iq)=va(iq)-(vd(inv2(iq))-vd(isv2(iq)))/16.
>         enddo   ! iq loop
> c       write (42,*) 'uout nstag=0 unstaguv ktau = ',ktau
> c       write (42,90) (nint(uout(iq)),iq=1,ifull)
> c       write (42,*) 'vout nstag=0 unstaguv ktau = ',ktau
> c       write (42,90) (nint(vout(iq)),iq=1,ifull)
>       endif  ! (nstagu.le.1)
>       if(nstagu.eq.2)then    ! linear weighted (no mst_bs provided)
>         do iq=1,ifull
>           ua(iq)=u(iq)
>           va(iq)=v(iq)
>         enddo   ! iq loop
>         do iq=1,ifull
>           avma=emu(iwu2(iq))+em(iq)
>           avmb=em(iq)+emu(iq)
>           uout(iq)=(avma*ua(iwu2(iq))+avmb*ua(iq))/(avma+avmb)
>           avma=emv(isv2(iq))+em(iq)
>           avmb=em(iq)+emv(iq)
>           vout(iq)=(avma*va(isv2(iq))+avmb*va(iq))/(avma+avmb)
>         enddo   ! iq loop
>       endif    ! (nstagu.eq.2)
> 
>       if(nstagu.eq.10)then
>         call rev_unst(uin,vin,uout,vout,ua,va,ub,vb,ud,vd)
>       endif    !  (nstagu.eq.10)
>       if(nstagu.eq.3)then
>         call revb(uin,vin,uout,vout,ua,va,ub,vb,ud,vd)
>       endif    !  (nstagu.eq.3)
>       if(nstagu.eq.4)then
>         call revb_b(uin,vin,uout,vout,ua,va,ub,vb,ud,vd)
>       endif    !  (nstagu.eq.4)
> 
>       if(nstagu.eq.5)then
>         if(mod(ktau,2).eq.0)then
>           call revb(uin,vin,uout,vout,ua,va,ub,vb,ud,vd)
>         else
>           call revb_b(uin,vin,uout,vout,ua,va,ub,vb,ud,vd)
>         endif    !  (mod(ktau,2).eq.0)
>       endif    !  (nstagu.eq.5)
> c     if(nstagu.eq.5.and.nspec_us.ne.1)then
> c       if(mod(ktau,2).eq.0)then
> c         call revb(uin,vin,uout,vout,ua,va,ub,vb,ud,vd)
> c       else
> c         call revb_b(uin,vin,uout,vout,ua,va,ub,vb,ud,vd)
> c       endif    !  (mod(ktau,2).eq.0)
> c     endif    !  (nstagu.eq.5)
> c     if(nstagu.eq.5.and.nspec_us.eq.1)then  ! special ktau-usage for nritch=102
> c       if(mod(ktau,2).eq.0)then
> c         call revb_b(uin,vin,uout,vout,ua,va,ub,vb,ud,vd)
> c       else
> c         call revb(uin,vin,uout,vout,ua,va,ub,vb,ud,vd)
> c       endif    !  (mod(ktau,2).eq.0)
> c     endif    !  (nstagu.eq.5)
> 
>       if(nstagu.eq.55)then
>         if(mod(ktau,2).eq.0)then
>           call revb_b(uin,vin,uout,vout,ua,va,ub,vb,ud,vd)
>         else
>           call revb(uin,vin,uout,vout,ua,va,ub,vb,ud,vd)
>         endif    !  (mod(ktau,2).eq.0)
>       endif    !  (nstagu.eq.55)
>       if(nstagu.eq.6)then  ! 6-point centred formula
> !cdir nodep
>         do iq=1,ifull
>          ua(ieu2(iq))=(3.*uin(iwu2(iq))-25.*uin(iq)+150.*uin(ieu2(iq)))
>      .                /(8.*32.)
>          va(inv2(iq))=(3.*vin(isv2(iq))-25.*vin(iq)+150.*vin(inv2(iq)))
>      .                /(8.*32.)
>          ud(iwu2(iq))=(3.*uin(ieu2(iq))-25.*uin(iq)+150.*uin(iwu2(iq)))
>      .                /(8.*32.)
>          vd(isv2(iq))=(3.*vin(inv2(iq))-25.*vin(iq)+150.*vin(isv2(iq)))
>      .                /(8.*32.)
>         enddo   ! iq loop
> c       now combine the above to give quintic interpolated values
>          do iq=1,ifull
>            uout(iq)=ua(iwu2(iq))+ud(iq)
>            vout(iq)=va(isv2(iq))+vd(iq)
>          enddo   ! iq loop
>       endif  ! (nstagu.eq.6)
>       if(nstagu.eq.7)then          ! does reversible Akima
>         if(mod(ktau,2).eq.0)then
>           call rekb(uin,vin,uout,vout,ua,va,ub,vb,ud,vd)
>         else
>           call rekb_b(uin,vin,uout,vout,ua,va,ub,vb,ud,vd)
>         endif   !  (mod(ktau,2).eq.0)
>       endif     !  (nstagu.eq.7)
>       if(nstagu.eq.8)then
>           call rekb(uin,vin,uout,vout,ua,va,ub,vb,ud,vd)
>       endif     !  (nstagu.eq.8)
>       if(nstagu.eq.9)then
>           call rekb_b(uin,vin,uout,vout,ua,va,ub,vb,ud,vd)
>       endif     !  (nstagu.eq.9)
> 
>       if(mstu_bs.eq.1)then    ! unstaguv code
> !cdir nodep
>         do iq=1,ifull
>           ud(iq)=    uin(iq)-uin(iwu2(iq))
>           vd(iq)=    vin(iq)-vin(isv2(iq))
>         enddo   ! iq loop
> !cdir nodep
>         do iq=1,ifull
>           if(ud(iwu2(iq))*ud(ieu2(iq)).ge.0.)then
>             umin=min(uin(iq),uin(iwu2(iq)))
>             umax=max(uin(iq),uin(iwu2(iq)))
>             uout(iq)=min( max(umin,uout(iq)) , umax )
>           endif
>           if(vd(isv2(iq))*vd(inv2(iq)).ge.0.)then
>             vmin=min(vin(iq),vin(isv2(iq)))
>             vmax=max(vin(iq),vin(isv2(iq)))
>             vout(iq)=min( max(vmin,vout(iq)) , vmax )
>           endif
>         enddo   ! iq loop
>       elseif(mstu_bs.eq.2)then    ! unstaguv code   B & S
> !cdir nodep
>         do iq=1,ifull
>             umin=min(uin(iq),uin(iwu2(iq)))
>             umax=max(uin(iq),uin(iwu2(iq)))
>             uout(iq)=min( max(umin,uout(iq)) , umax )
>             vmin=min(vin(iq),vin(isv2(iq)))
>             vmax=max(vin(iq),vin(isv2(iq)))
>             vout(iq)=min( max(vmin,vout(iq)) , vmax )
>         enddo   ! iq loop
>       elseif(mstu_bs.eq.3)then    ! unstaguv code   jlm 2nd derivative test
>         do iq=1,ifull
>           ud(iq)=    uin(ieu2(iq))+uin(iwu2(iq))-2.*uin(iq)
>           vd(iq)=    vin(inv2(iq))+vin(isv2(iq))-2.*vin(iq)
>         enddo   ! iq loop
>         do iq=1,ifull
>           if(ud(iq)*ud(iwu2(iq)).lt.0.)then   ! unstaguv
>             uout(iq)=ua(iq)                   ! use linear here
>           endif
>           if(vd(iq)*vd(isv2(iq)).lt.0.)then   ! unstaguv
>             vout(iq)=va(iq)                   ! use linear here
>           endif
>         enddo   ! iq loop
>       elseif(mstu_bs.eq.4)then    ! unstaguv code  jlm version of S & Y
>         do iq=1,ifull
>           ud(iq)=    uin(iq)-uin(iwu2(iq))
>           vd(iq)=    vin(iq)-vin(isv2(iq))
>           ua(iq)=-1.    ! just used as indicator here
>           va(iq)=-1.    ! just used as indicator here
>         enddo   ! iq loop
> !cdir nodep
>         do iq=1,ifull
>           if(ud(iq)*ud(ieu2(iq)).gt.0.)
>      .                    ua(iwu2(iq))=ua(iwu2(iq))+.7 ! extreme value allowed
>           if(ud(iwu2(iq))*ud(iq).gt.0.)
>      .                    ua(ieu2(iq))=ua(ieu2(iq))+.7 ! extreme value allowed
>           if(vd(iq)*vd(inv2(iq)).gt.0.)
>      .                    va(isv2(iq))=va(isv2(iq))+.7 ! extreme value allowed
>           if(vd(isv2(iq))*vd(iq).gt.0.)
>      .                    va(inv2(iq))=va(inv2(iq))+.7 ! extreme value allowed
>         enddo   ! iq loop
>         do iq=1,ifull
>           if(ua(iq).lt.0.)then
>             umin=min(uin(iq),uin(iwu2(iq)))
>             umax=max(uin(iq),uin(iwu2(iq)))
>             uout(iq)=min( max(umin,uout(iq)) , umax )
>           endif
>           if(va(iq).lt.0.)then
>             vmin=min(vin(iq),vin(isv2(iq)))
>             vmax=max(vin(iq),vin(isv2(iq)))
>             vout(iq)=min( max(vmin,vout(iq)) , vmax )
>           endif
>         enddo   ! iq loop
>       endif      !   (mstu_bs.eq.1) else (mst_bs.eq.2) else (mst_bs.eq.3) else (mst_bs.eq.4)
>       return
> 
> c-----------------------------------------------------------------------------
> !     following is staguv, going via Cartesian uc, vc, wc
> !     first convert ux, vx to cartesian velocity components
> 7      do iq=1,ifull       !     for nstag=1
>         uc(iq)=ax(iq)*uin(iq) + bx(iq)*vin(iq)
>         vc(iq)=ay(iq)*uin(iq) + by(iq)*vin(iq)
>         wc(iq)=az(iq)*uin(iq) + bz(iq)*vin(iq)
>        enddo     ! iq loop
> 
> !      now interpolate these to the staggered grid; special globpea code
> !      uc contribution first
>        do iq=1,ifull
>          ua(iq)=.5*(uc(ie(iq))+uc(iq))
>          va(iq)=.5*(uc(in(iq))+uc(iq))
>          ud(iq)=    uc(ie(iq))-uc(iq)
>          vd(iq)=    uc(in(iq))-uc(iq)
>        enddo   ! iq loop
>        do iq=1,ifull
>          uout(iq)=
>      .       (ua(iq)-(ud(ieu2(iq))-ud(iwu2(iq)))/16.)*axu(iq)
>          vout(iq)=
>      .       (va(iq)-(vd(inv2(iq))-vd(isv2(iq)))/16.)*bxv(iq)
>         enddo  ! iq loop
> !      vc contribution next
>        do iq=1,ifull
>          ua(iq)=.5*(vc(ie(iq))+vc(iq))
>          va(iq)=.5*(vc(in(iq))+vc(iq))
>          ud(iq)=    vc(ie(iq))-vc(iq)
>          vd(iq)=    vc(in(iq))-vc(iq)
>        enddo   ! iq loop
>        do iq=1,ifull
>          uout(iq)=uout(iq)+
>      .       (ua(iq)-(ud(ieu2(iq))-ud(iwu2(iq)))/16.)*ayu(iq)
>          vout(iq)=vout(iq)+
>      .       (va(iq)-(vd(inv2(iq))-vd(isv2(iq)))/16.)*byv(iq)
>         enddo   ! iq loop
> !      wc contribution last
>        do iq=1,ifull
>          ua(iq)=.5*(wc(ie(iq))+wc(iq))
>          va(iq)=.5*(wc(in(iq))+wc(iq))
>          ud(iq)=    wc(ie(iq))-wc(iq)
>          vd(iq)=    wc(in(iq))-wc(iq)
>        enddo   ! iq loop
>        do iq=1,ifull
>          uout(iq)=uout(iq)+
>      .       (ua(iq)-(ud(ieu2(iq))-ud(iwu2(iq)))/16.)*azu(iq)
>          vout(iq)=vout(iq)+
>      .       (va(iq)-(vd(inv2(iq))-vd(isv2(iq)))/16.)*bzv(iq)
>        enddo   ! iq loop
>        if(mst_bs.ne.0)go to 35
>        return
>       end
>       subroutine reva(uin,vin,uout,vout,ua,va,ub,vb,ud,vd)
>       include 'newmpar.h'
>       include 'indices.h' ! in,is,iw,ie,inn,iss,iww,iee
>       include 'parmhor.h' ! mstagpt
>       integer num
> !     parameter (mstagpt=2) ! 2 for 2-point  etc
>       parameter (damp=1.)      ! damping factor option for mstagpt=4
>       real uin(ifull),vin(ifull),uout(ifull),vout(ifull)
>       real ua(ifull),va(ifull),ud(ifull),vd(ifull)     ! work arrays
>       real ub(ifull),vb(ifull)                         ! work arrays
> c     data c1/-.0220/,c2/.3952/,c3/.8442/,c4/-.3214/,  ! 7-term4
> c    .     c5/.1415/,c6/-.0625/,c7/.0250/,c8/ 0.   /   ! 7-term4
> c     data c1/ .0252/,c2/.2557/,c3/.9323/,c4/-.2513/,  ! 8-term3 damps
> c    .     c5/.0412/,c6/-.0068/,c7/.0011/,c8/-.0002/   ! 8-term3
> c     data c1/-.0205/,c2/.397 /,c3/.846 /,c4/-.320 /,  ! 8-term4a
> c    .     c5/.143 /,c6/-.061 /,c7/.0265/,c8/-.011 /   ! 8-term4a
> 
> c     data c1/-.0205/,c2/.3957/,c3/.8440/,c4/-.3188/,  ! 8-term4it
> c    .     c5/.1475/,c6/-.0519/,c7/.0248/,c8/-.0096/   ! 8-term4it
> c     data c1/-.0376/,c2/.4314/,c3/.8192/,c4/-.3245/,  ! 8-term6trunc
> c    .     c5/.1653/,c6/-.0815/,c7/.0399/,c8/-.0196/   ! 8-term6trunc
> c     data c1/-.0291/,c2/.4137/,c3/.8315/,c4/-.3217/,  ! 8-term6trunc/it
> c    .     c5/.1565/,c6/-.0668/,c7/.0324/,c8/-.0146/   ! 8-term6trunc/it
> 
> c     data c1/-.0207/,c2/.3965/,c3/.8455/,c4/-.3201/,  ! 8-term4trunc
> c    .     c5/.1429/,c6/-.0611/,c7/.0264/,c8/-.0114/   ! 8-term4trunc
> c     data c1/-.1246/,c2/.6131/,c3/.6873/,c4/-.3472/,  ! 8-term6comb3b
> c    .     c5/.2915/,c6/-.1684/,c7/.1065/,c8/-.0583/   ! 8-term6comb3b
> 
> c     data c1/-.0601/,c2/.4774/,c3/.7822/,c4/-.3290/,  ! 8-term6comb3a
> c    .     c5/.2005/,c6/-.0987/,c7/.0562/,c8/-.0286/   ! 8-term6comb3a
> 
> c     data c1/-.0207/,c2/.3965/,c3/.8455/,c4/-.3201/,  ! 8-term4'
> c    .     c5/.1429/,c6/-.0611/,c7/.0264/,c8/-.0094/   ! 8-term4'
> c     data c1/-.0206/,c2/.3962/,c3/.8449/,c4/-.3196/,  ! 8-term4comb
> c    .     c5/.1446/,c6/-.0576/,c7/.0258/,c8/-.0137/   ! 8-term4comb
> c     data c1/-.0207/,c2/.3965/,c3/.8455/,c4/-.3200/,  ! 8-term4it'
> c    .     c5/.1499/,c6/-.0482/,c7/.0106/,c8/-.0136/   ! 8-term4it'
> c     data c1/-.0208/,c2/.3973/,c3/.8472/,c4/-.3207/,  ! 8-term4norm
> c    .     c5/.1432/,c6/-.0612/,c7/.0264/,c8/-.0114/   ! 8-term4norm
> c     data c1/-.0379/,c2/.4346/,c3/.8253/,c4/-.3269/,  ! 8-term6norm
> c    .     c5/.1665/,c6/-.0821/,c7/.0402/,c8/-.0197/   ! 8-term6norm
> c     data c1/-.0376/,c2/.4314/,c3/.8192/,c4/-.3245/,  ! 8-term6'
> c    .     c5/.1653/,c6/-.0815/,c7/.0399/,c8/-.0122/   ! 8-term6'
> 
> c     data c1/-.02074/,c2/.39655/,c3/.84549/,c4/-.32009/,c5/.14288/,  ! 8-term4
> c    .     c6/-.06111/,c7/.02641/,c8/-.01139/,c9/0./,c10/0./          ! 8-term4
> c     data c1/-.02074/,c2/.39655/,c3/.84549/,c4/-.32009/,c5/.14288/,  ! 10-term4
> c    .     c6/-.06111/,c7/.02641/,c8/-.01139/,c9/.00491/,c10/-.00212/ ! 10-term4
>       data c1/-.02074/,c2/.39655/,c3/.84549/,c4/-.32009/,c5/.14288/,  ! 10aterm4
>      .     c6/-.06111/,c7/.02641/,c8/-.01139/,c9/.00412/,c10/-.00212/ ! 10aterm4
> 
>       data itnmax/3/,num/0/     ! N.B. each loop is a double iteration
>       save num
>       if(num.eq.0)then
>         print *,'mstagpt,itnmax ',mstagpt,itnmax
>         if(mstagpt.eq.7)print *,'c1-10: ',c1,c2,c3,c4,c5,c6,c7,c8,c9,c10
>         sum1=c1+c2+c3+c4+c5+c6+c7+c8+c9+c10
>         sumk=c1+2.*c2+3.*c3+4.*c4+5.*c5+6.*c6+7.*c7+8.*c8+9.*c9+10.*c10
>         sum2=c1**2+c2**2+c3**2+c4**2+c5**2+c6**2+c7**2+c8**2
>      .       +c9**2+c10**2
>         print *,'sum1,sumk,sum2 ',sum1,sumk,sum2
>         num=1
>       endif
> c     reversible yh from y using yh(i+1/4)  (b from a, east-biased a)
>       if(mstagpt.ge.7)then
> !cdir nodep
>         do iq=1,ifull
>           ua(iq)=c10*uin(ieu2(iq)) +c9*uin(iq)
>           va(iq)=c10*vin(inv2(iq)) +c9*vin(iq)
>         enddo
> !cdir nodep
>         do iq=1,ifull
>           ub(iwu2(iq))=ua(ieu2(iq)) +c8*uin(iq) +c7*uin(iwu2(iq))
>           vb(isv2(iq))=va(inv2(iq)) +c8*vin(iq) +c7*vin(isv2(iq))
>         enddo
> !cdir nodep
>         do iq=1,ifull
>           ua(iwu2(iq))=ub(ieu2(iq)) +c6*uin(iq) +c5*uin(iwu2(iq))
>           va(isv2(iq))=vb(inv2(iq)) +c6*vin(iq) +c5*vin(isv2(iq))
>         enddo
> !cdir nodep
>         do iq=1,ifull
>           ub(iwu2(iq))=ua(ieu2(iq)) +c4*uin(iq) +c3*uin(iwu2(iq))
>           vb(isv2(iq))=va(inv2(iq)) +c4*vin(iq) +c3*vin(isv2(iq))
>         enddo
> !cdir nodep
>         do iq=1,ifull
>           uout(iq)=ub(ieu2(iq)) +c2*uin(iq) +c1*uin(iwu2(iq))
>           vout(iq)=vb(inv2(iq)) +c2*vin(iq) +c1*vin(isv2(iq))
>         enddo
>       return
>       endif     ! (mstagpt.ge.7)
> 
>       if(mstagpt.eq.2)then  ! 2-point scheme reva
> !cdir nodep
>         do iq=1,ifull   ! precalculate rhs terms
>           ud(iwu2(iq))= uin(iwu2(iq))/3.+uin(iq)
>           vd(isv2(iq))= vin(isv2(iq))/3.+vin(iq)
>         enddo
> !cdir nodep
>         do iq=1,ifull
>           ua(iq)=ud(iq)-ud(ieu2(iq))/3.   ! 1st guess
>           va(iq)=vd(iq)-vd(inv2(iq))/3.   ! 1st guess
>         enddo
>         do itn=1,itnmax  ! each loop is a double iteration
> !cdir nodep
>          do iq=1,ifull
>           uin(iq)=ud(iq)  -ua(ieu2(iq))/3.
>           vin(iq)=vd(iq)  -va(inv2(iq))/3.
49,50c550,553
<          do iq=il+1,ifull-il
<           vd(iq-il)= vin(iq-il)/2.+vin(iq)+vin(iq+il)/10.
---
> !cdir nodep
>          do iq=1,ifull
>           ua(iq)=ud(iq)  -uin(ieu2(iq))/3.
>           va(iq)=vd(iq)  -vin(inv2(iq))/3.
52,90c555,556
< 	  do j=1,jl
< 	   iq=1+(j-1)*il
<           ud(iwu2(iq))= uin(iwu2(iq))/2.+uin(iq)+uin(ieu2(iq))/10.
< 	   iq=il+(j-1)*il
<           ud(iwu2(iq))= uin(iwu2(iq))/2.+uin(iq)+uin(ieu2(iq))/10.
< 	  enddo
< 	  do j=1,jl,2*il
< 	   do i=1,il
< 	    iq=i+(j-1)*il
<            vd(isv2(iq))= vin(isv2(iq))/2.+vin(iq)+vin(inv2(iq))/10.
<  	   enddo
< 	  enddo
< 	  do j=2*il,jl,2*il
< 	   do i=1,il
< 	    iq=i+(j-1)*il
<            vd(isv2(iq))= vin(isv2(iq))/2.+vin(iq)+vin(inv2(iq))/10.
<  	   enddo
< 	  enddo
< c        do iq=1,ifull
< c          ua(iq)=ud(iq)-ud(ieu2(iq))/2.   ! 1st guess
< c          va(iq)=vd(iq)-vd(inv2(iq))/2.   ! 1st guess
< c        enddo
< !cdir nodep
<          do iq=1,ifull-1
<           ua(iq)=ud(iq)-ud(iq+1)/2.
<          enddo
<          do iq=1,ifull-il
<           va(iq)=vd(iq)-vd(iq+il)/2.
<          enddo
< 	  do j=1,jl
< 	   iq=il+(j-1)*il
<           ua(iq)=ud(iq)-ud(ieu2(iq))/2.    ! 1st guess
< 	  enddo
< 	  do j=2*il,jl,2*il
< 	   do i=1,il
< 	    iq=i+(j-1)*il
<            va(iq)=vd(iq)-vd(inv2(iq))/2.   ! 1st guess
<  	   enddo
< 	  enddo
---
>         enddo  ! itn=1,itnmax
>       endif     ! (mstagpt.eq.2)  reva
91a558,568
>       if(mstagpt.eq.3)then  ! 3-point scheme reva
> !cdir nodep
>         do iq=1,ifull   ! precalculate rhs terms
>           ud(iwu2(iq))= uin(iwu2(iq))/6.+uin(iq)-uin(ieu2(iq))/10.
>           vd(isv2(iq))= vin(isv2(iq))/6.+vin(iq)-vin(inv2(iq))/10.
>         enddo
> !cdir nodep
>         do iq=1,ifull
>           ua(iq)=ud(iq)-ud(ieu2(iq))/6.   ! 1st guess
>           va(iq)=vd(iq)-vd(inv2(iq))/6.   ! 1st guess
>         enddo
94,99c571,573
< c         do iq=1,ifull
< c          ub(iq)=ua(ieu2(iq))
< c          vb(iq)=va(inv2(iq))
< c         enddo
<          do iq=1,ifull-1
<           ub(iq)=ua(iq+1)
---
>          do iq=1,ifull
>           uin(iq)=ud(iq) +ua(iwu2(iq))/10. -ua(ieu2(iq))/6.
>           vin(iq)=vd(iq) +va(isv2(iq))/10. -va(inv2(iq))/6.
101,102c575,578
<          do iq=1,ifull-il
<           vb(iq)=va(iq+il)
---
> !cdir nodep
>          do iq=1,ifull
>           ua(iq)=ud(iq) +uin(iwu2(iq))/10. -uin(ieu2(iq))/6.
>           va(iq)=vd(iq) +vin(isv2(iq))/10. -vin(inv2(iq))/6.
104,105c580,596
< 	  do j=1,jl
< 	   iq=il+(j-1)*il
---
>         enddo  ! itn=1,itnmax
>       endif     ! (mstagpt.eq.3)  reva
> 
>       if(mstagpt.eq.-3)then  ! other 3-point scheme reva
> !cdir nodep
>         do iq=1,ifull   ! precalculate rhs terms
>           ud(iwu2(iq))= uin(iwu2(iq))/2.+uin(iq)+uin(ieu2(iq))/10.
>           vd(isv2(iq))= vin(isv2(iq))/2.+vin(iq)+vin(inv2(iq))/10.
>         enddo
> !cdir nodep
>         do iq=1,ifull
>           ua(iq)=ud(iq)-ud(ieu2(iq))/2.   ! 1st guess
>           va(iq)=vd(iq)-vd(inv2(iq))/2.   ! 1st guess
>         enddo
>         do itn=1,itnmax  ! each loop is a double iteration
> !cdir nodep
>          do iq=1,ifull
107,127c598
< 	  enddo
< 	  do j=2*il,jl,2*il
< 	   do i=1,il
< 	    iq=i+(j-1)*il
<            vb(iq)=va(inv2(iq))
<  	   enddo
< 	  enddo
< !cdir nodep
< c       do iq=1,ifull
< c         uin(iq)=(ud(iq)-.5*ud(ieu2(iq))
< c    .                 -ua(iwu2(iq))/10. +ub(ieu2(iq))/4.)/.95
< c         vin(iq)=(vd(iq)-.5*vd(inv2(iq))
< c    .                 -va(isv2(iq))/10. +vb(inv2(iq))/4.)/.95
< c        enddo
< 	  do iq=2,ifull-1
<           uin(iq)=(ud(iq)-.5*ud(iq+1)
<      .                 -ua(iq-1)/10. +ub(iq+1)/4.)/.95
<          enddo
<          do iq=il+1,ifull-il
<           vin(iq)=(vd(iq)-.5*vd(iq+il)
<      .                 -va(iq-il)/10. +vb(iq+il)/4.)/.95
---
>           vb(iq)=va(inv2(iq))
129,133c600,601
< 	  do j=1,jl
< 	   iq=1+(j-1)*il
<           uin(iq)=(ud(iq)-.5*ud(ieu2(iq))
<      .                 -ua(iwu2(iq))/10. +ub(ieu2(iq))/4.)/.95
< 	   iq=il+(j-1)*il
---
> !cdir nodep
>          do iq=1,ifull
136,140c604
< 	  enddo
< 	  do j=1,jl,2*il
< 	   do i=1,il
< 	    iq=i+(j-1)*il
<            vin(iq)=(vd(iq)-.5*vd(inv2(iq))
---
>           vin(iq)=(vd(iq)-.5*vd(inv2(iq))
142,158d605
<  	   enddo
< 	  enddo
< 	  do j=2*il,jl,2*il
< 	   do i=1,il
< 	    iq=i+(j-1)*il
<            vin(iq)=(vd(iq)-.5*vd(inv2(iq))
<      .                 -va(isv2(iq))/10. +vb(inv2(iq))/4.)/.95
<  	   enddo
< 	  enddo
< 
< !cdir nodep
< c         do iq=1,ifull
< c          ub(iq)=uin(ieu2(iq))
< c          vb(iq)=vin(inv2(iq))
< c         enddo
<          do iq=1,ifull-1
<           ub(iq)=uin(iq+1)
160,164c607,608
<          do iq=1,ifull-il
<           vb(iq)=vin(iq+il)
<          enddo
< 	  do j=1,jl
< 	   iq=il+(j-1)*il
---
> !cdir nodep
>          do iq=1,ifull
166,186c610
< 	  enddo
< 	  do j=2*il,jl,2*il
< 	   do i=1,il
< 	    iq=i+(j-1)*il
<            vb(iq)=vin(inv2(iq))
<  	   enddo
< 	  enddo
< !cdir nodep
< c        do iq=1,ifull
< c         ua(iq)=(ud(iq)-.5*ud(ieu2(iq))
< c    .                 -uin(iwu2(iq))/10. +ub(ieu2(iq))/4.)/.95
< c         va(iq)=(vd(iq)-.5*vd(inv2(iq))
< c    .                 -vin(isv2(iq))/10. +vb(inv2(iq))/4.)/.95
< c        enddo
< 	  do iq=2,ifull-1
<           ua(iq)=(ud(iq)-.5*ud(iq+1)
<      .                 -uin(iq-1)/10. +ub(iq+1)/4.)/.95
<          enddo
<          do iq=il+1,ifull-il
<           va(iq)=(vd(iq)-.5*vd(iq+il)
<      .                 -vin(iq-il)/10. +vb(iq+il)/4.)/.95
---
>           vb(iq)=vin(inv2(iq))
188,192c612,613
< 	  do j=1,jl
< 	   iq=1+(j-1)*il
<           ua(iq)=(ud(iq)-.5*ud(ieu2(iq))
<      .                 -uin(iwu2(iq))/10. +ub(ieu2(iq))/4.)/.95
< 	   iq=il+(j-1)*il
---
> !cdir nodep
>          do iq=1,ifull
195,206c616
< 	  enddo
< 	  do j=1,jl,2*il
< 	   do i=1,il
< 	    iq=i+(j-1)*il
<            va(iq)=(vd(iq)-.5*vd(inv2(iq))
<      .                 -vin(isv2(iq))/10. +vb(inv2(iq))/4.)/.95
<  	   enddo
< 	  enddo
< 	  do j=2*il,jl,2*il
< 	   do i=1,il
< 	    iq=i+(j-1)*il
<            va(iq)=(vd(iq)-.5*vd(inv2(iq))
---
>           va(iq)=(vd(iq)-.5*vd(inv2(iq))
208,209c618
<  	   enddo
< 	  enddo
---
>          enddo
211,215c620,666
< 	 
<         do iq=1,ifull      ! final values for output
<          uout(iq)=ua(iq)
<          vout(iq)=va(iq)
<         enddo   ! iq loop
---
>       endif     ! (mstagpt.eq.-3)  reva
> 
>       if(mstagpt.eq.4)then  ! usual 4-point scheme reva
> !       also use ub as a work array
> !cdir nodep
>         do iq=1,ifull   ! precalculate rhs terms
>           ub(iq)=uin(iq)-uin(ieu2(iq))/15.
>           vb(iq)=vin(iq)-vin(inv2(iq))/15.
>         enddo
> !cdir nodep
>         do iq=1,ifull   ! precalculate rhs terms
>           ud(iq)=( -uin(iwu2(iq))/21.+uin(iq)/3.+ub(ieu2(iq)) )*damp
>           vd(iq)=( -vin(isv2(iq))/21.+vin(iq)/3.+vb(inv2(iq)) )*damp
>         enddo
> !cdir nodep
>         do iq=1,ifull
>           ua(iq)=ud(iq)-ud(ieu2(iq))/3.   ! 1st guess
>           va(iq)=vd(iq)-vd(inv2(iq))/3.   ! 1st guess
>         enddo
>         do itn=1,itnmax  ! each loop is a double iteration
> !cdir nodep
>          do iq=1,ifull
>           ub(iq)=ua(iq)/3. -ua(ieu2(iq))/21.
>           vb(iq)=va(iq)/3. -va(inv2(iq))/21.
>          enddo
> !cdir nodep
>          do iq=1,ifull
>           uin(iq)=ud(iq) +ua(iwu2(iq))/15. -ub(ieu2(iq))
>           vin(iq)=vd(iq) +va(isv2(iq))/15. -vb(inv2(iq))
>          enddo
> !cdir nodep
>          do iq=1,ifull
>           ub(iq)=uin(iq)/3. -uin(ieu2(iq))/21.
>           vb(iq)=vin(iq)/3. -vin(inv2(iq))/21.
>          enddo
> !cdir nodep
>          do iq=1,ifull
>            ua(iq)=ud(iq)+uin(iwu2(iq))/15. -ub(ieu2(iq))
>            va(iq)=vd(iq)+vin(isv2(iq))/15. -vb(inv2(iq))
>          enddo
>         enddo  ! itn=1,itnmax
>       endif     ! (mstagpt.eq.4)
> 
>       do iq=1,ifull  ! final values for output
>         uout(iq)=ua(iq)
>         vout(iq)=va(iq)
>       enddo
218,223c669,702
<       entry unstaguv(u,v,uout,vout)
< c     staggered u & v as input; unstaggered as output
<       do iq=1,ifull
<        uin(iq)=u(iq)
<        vin(iq)=v(iq)
<       enddo   ! iq loop
---
>       entry reva_b(uin,vin,uout,vout,ua,va,ub,vb,ud,vd)
> c     reversible yh from y using yh(i-1/4)  (b from a, west-biased a)
>       if(mstagpt.ge.7)then   ! matrix-inversion/polynomial method
> !cdir nodep
>         do iq=1,ifull
>           ua(iq)=c10*uin(iwu2(iq)) +c9*uin(iq)
>           va(iq)=c10*vin(isv2(iq)) +c9*vin(iq)
>         enddo
> !cdir nodep
>         do iq=1,ifull
>           ub(ieu2(iq))=ua(iwu2(iq)) +c8*uin(iq) +c7*uin(ieu2(iq))
>           vb(inv2(iq))=va(isv2(iq)) +c8*vin(iq) +c7*vin(inv2(iq))
>         enddo
> !cdir nodep
>         do iq=1,ifull
>           ua(ieu2(iq))=ub(iwu2(iq)) +c6*uin(iq) +c5*uin(ieu2(iq))
>           va(inv2(iq))=vb(isv2(iq)) +c6*vin(iq) +c5*vin(inv2(iq))
>         enddo
> !cdir nodep
>         do iq=1,ifull
>           ub(ieu2(iq))=ua(iwu2(iq)) +c4*uin(iq) +c3*uin(ieu2(iq))
>           vb(inv2(iq))=va(isv2(iq)) +c4*vin(iq) +c3*vin(inv2(iq))
>         enddo
> !cdir nodep
>         do iq=1,ifull ! can't rely on cyclic uout,vout so using ua,va
>           ua(iwu2(iq))=ub(iwu2(iq)) +c2*uin(iq) +c1*uin(ieu2(iq))
>           va(isv2(iq))=vb(isv2(iq)) +c2*vin(iq) +c1*vin(inv2(iq))
>         enddo
>         do iq=1,ifull
>           uout(iq)=ua(iq)
>           vout(iq)=va(iq)
>         enddo
>       return
>       endif     ! (mstagpt.ge.7)
225,235c704,719
< !     if(nstagu.eq.-3)then
< !       call revb6(uin,vin,uout,vout,ua,va,ub,vb,ud,vd)
< !     endif    !  (nstagu.eq.-3)
<  
< !cdir nodep
< c       do iq=1,ifull   ! precalculate rhs terms
< c         ud(ieu2(iq))= uin(ieu2(iq))/2.+uin(iq)+uin(iwu2(iq))/10.
< c         vd(inv2(iq))= vin(inv2(iq))/2.+vin(iq)+vin(isv2(iq))/10.
< c       enddo
<          do iq=2,ifull-1
<           ud(iq+1)= uin(iq+1)/2.+uin(iq)+uin(iq-1)/10.
---
>       if(mstagpt.eq.2)then  ! 2-point scheme reva_b
> !cdir nodep
>         do iq=1,ifull   ! precalculate rhs terms
>           ud(iq)= uin(iq)+uin(ieu2(iq))/3.
>           vd(iq)= vin(iq)+vin(inv2(iq))/3.
>         enddo
> !cdir nodep
>         do iq=1,ifull
>           ua(iq)=ud(iq)-ud(iwu2(iq))/3.   ! 1st guess
>           va(iq)=vd(iq)-vd(isv2(iq))/3.   ! 1st guess
>         enddo
>         do itn=1,itnmax  ! each loop is a double iteration
> !cdir nodep
>          do iq=1,ifull
>           uin(iq)=ud(iq) -ua(iwu2(iq))/3.
>           vin(iq)=vd(iq) -va(isv2(iq))/3.
237,238c721,724
<          do iq=il+1,ifull-il
<           vd(iq+il)= vin(iq+il)/2.+vin(iq)+vin(iq-il)/10.
---
> !cdir nodep
>          do iq=1,ifull
>           ua(iq)=ud(iq) -uin(iwu2(iq))/3.
>           va(iq)=vd(iq) -vin(isv2(iq))/3.
240,278c726,727
< 	  do j=1,jl
< 	   iq=1+(j-1)*il
<           ud(ieu2(iq))= uin(ieu2(iq))/2.+uin(iq)+uin(iwu2(iq))/10.
< 	   iq=il+(j-1)*il
<           ud(ieu2(iq))= uin(ieu2(iq))/2.+uin(iq)+uin(iwu2(iq))/10.
< 	  enddo
< 	  do j=1,jl,2*il
< 	   do i=1,il
< 	    iq=i+(j-1)*il
<            vd(inv2(iq))= vin(inv2(iq))/2.+vin(iq)+vin(isv2(iq))/10.
<  	   enddo
< 	  enddo
< 	  do j=2*il,jl,2*il
< 	   do i=1,il
< 	    iq=i+(j-1)*il
<            vd(inv2(iq))= vin(inv2(iq))/2.+vin(iq)+vin(isv2(iq))/10.
<  	   enddo
< 	  enddo
< c        do iq=1,ifull
< c          ua(iq)=ud(iq)-ud(iwu2(iq))/2.   ! 1st guess
< c          va(iq)=vd(iq)-vd(isv2(iq))/2.   ! 1st guess
< c        enddo
< !cdir nodep
<          do iq=2,ifull
<           ua(iq)=ud(iq)-ud(iq-1)/2.
<          enddo
<          do iq=il+1,ifull
<           va(iq)=vd(iq)-vd(iq-il)/2.
<          enddo
< 	  do j=1,jl
< 	   iq=1+(j-1)*il
<           ua(iq)=ud(iq)-ud(iwu2(iq))/2.    ! 1st guess
< 	  enddo
< 	  do j=1,jl,2*il
< 	   do i=1,il
< 	    iq=i+(j-1)*il
<            va(iq)=vd(iq)-vd(isv2(iq))/2.   ! 1st guess
<  	   enddo
< 	  enddo
---
>         enddo  ! itn=1,itnmax
>       endif     ! (mstagpt.eq.2)  reva_b
280c729,734
<         do itn=1,itnmax  ! each loop is a double iteration
---
>       if(mstagpt.eq.3)then  ! 3-point scheme reva_b
> !cdir nodep
>         do iq=1,ifull   ! precalculate rhs terms
>           ud(iq)= -uin(iwu2(iq))/10.+uin(iq)+uin(ieu2(iq))/6.
>           vd(iq)= -vin(isv2(iq))/10.+vin(iq)+vin(inv2(iq))/6.
>         enddo
282,285c736,740
< c         do iq=1,ifull
< c          ub(iq)=ua(iwu2(iq))
< c          vb(iq)=va(isv2(iq))
< c         enddo
---
>         do iq=1,ifull
>           ua(iq)=ud(iq)-ud(iwu2(iq))/6.   ! 1st guess
>           va(iq)=vd(iq)-vd(isv2(iq))/6.   ! 1st guess
>         enddo
>         do itn=1,itnmax  ! each loop is a double iteration
287,288c742,744
<          do iq=2,ifull
<           ub(iq)=ua(iq-1)
---
>          do iq=1,ifull
>           uin(iq)=ud(iq) +ua(ieu2(iq))/10. -ua(iwu2(iq))/6.
>           vin(iq)=vd(iq) +va(inv2(iq))/10. -va(isv2(iq))/6.
290,291c746,749
<          do iq=il+1,ifull
<           vb(iq)=va(iq-il)
---
> !cdir nodep
>          do iq=1,ifull
>           ua(iq)=ud(iq) +uin(ieu2(iq))/10. -uin(iwu2(iq))/6.
>           va(iq)=vd(iq) +vin(inv2(iq))/10. -vin(isv2(iq))/6.
293,294c751,767
< 	  do j=1,jl
< 	   iq=1+(j-1)*il
---
>         enddo  ! itn=1,itnmax
>       endif     ! (mstagpt.eq.3)  reva_b
> 
>       if(mstagpt.eq.-3)then  ! other 3-point scheme reva_b
> !cdir nodep
>         do iq=1,ifull   ! precalculate rhs terms
>           ud(iq)= uin(iwu2(iq))/10.+uin(iq)+uin(ieu2(iq))/2.
>           vd(iq)= vin(isv2(iq))/10.+vin(iq)+vin(inv2(iq))/2.
>         enddo
> !cdir nodep
>         do iq=1,ifull
>           ua(iq)=ud(iq)-ud(iwu2(iq))/2.   ! 1st guess
>           va(iq)=vd(iq)-vd(isv2(iq))/2.   ! 1st guess
>         enddo
>         do itn=1,itnmax  ! each loop is a double iteration
> !cdir nodep
>          do iq=1,ifull
296,316c769
< 	  enddo
< 	  do j=1,jl,2*il
< 	   do i=1,il
< 	    iq=i+(j-1)*il
<            vb(iq)=va(isv2(iq))
<  	   enddo
< 	  enddo
< !cdir nodep
< c        do iq=1,ifull
< c         uin(iq)=(ud(iq)-.5*ud(iwu2(iq))
< c    .                 -ua(ieu2(iq))/10. +ub(iwu2(iq))/4.)/.95
< c         vin(iq)=(vd(iq)-.5*vd(isv2(iq))
< c    .                 -va(inv2(iq))/10. +vb(isv2(iq))/4.)/.95
< c        enddo
<          do iq=2,ifull-1
<           uin(iq)=(ud(iq)-.5*ud(iq-1)
<      .                 -ua(iq+1)/10. +ub(iq-1)/4.)/.95
<          enddo
<          do iq=il+1,ifull-il
<           vin(iq)=(vd(iq)-.5*vd(iq-il)
<      .                 -va(iq+il)/10. +vb(iq-il)/4.)/.95
---
>           vb(iq)=va(isv2(iq))
318,322c771,772
< 	  do j=1,jl
< 	   iq=1+(j-1)*il
<           uin(iq)=(ud(iq)-.5*ud(iwu2(iq))
<      .                 -ua(ieu2(iq))/10. +ub(iwu2(iq))/4.)/.95
< 	   iq=il+(j-1)*il
---
> !cdir nodep
>          do iq=1,ifull
325,336c775
< 	  enddo
< 	  do j=1,jl,2*il
< 	   do i=1,il
< 	    iq=i+(j-1)*il
<            vin(iq)=(vd(iq)-.5*vd(isv2(iq))
<      .                 -va(inv2(iq))/10. +vb(isv2(iq))/4.)/.95
<  	   enddo
< 	  enddo
< 	  do j=2*il,jl,2*il
< 	   do i=1,il
< 	    iq=i+(j-1)*il
<            vin(iq)=(vd(iq)-.5*vd(isv2(iq))
---
>           vin(iq)=(vd(iq)-.5*vd(isv2(iq))
338,339c777,920
<  	   enddo
< 	  enddo
---
>          enddo
> !cdir nodep
>          do iq=1,ifull
>           ub(iq)=uin(iwu2(iq))
>           vb(iq)=vin(isv2(iq))
>          enddo
> !cdir nodep
>          do iq=1,ifull
>           ua(iq)=(ud(iq)-.5*ud(iwu2(iq))
>      .                 -uin(ieu2(iq))/10. +ub(iwu2(iq))/4.)/.95
>           va(iq)=(vd(iq)-.5*vd(isv2(iq))
>      .                 -vin(inv2(iq))/10. +vb(isv2(iq))/4.)/.95
>          enddo
>         enddo  ! itn=1,itnmax
>       endif     ! (mstagpt.eq.-3)  reva_b
> 
>       if(mstagpt.eq.4)then  ! usual 4-point scheme reva_b
> c       also use ub as a work array
> !cdir nodep
>         do iq=1,ifull   ! precalculate rhs terms
>           ub(iq)=uin(iq)/3.-uin(ieu2(iq))/21.
>           vb(iq)=vin(iq)/3.-vin(inv2(iq))/21.
>         enddo
> !cdir nodep
>         do iq=1,ifull   ! precalculate rhs terms
>           ud(iq)=( -uin(iwu2(iq))/15.+uin(iq)+ub(ieu2(iq)) )*damp
>           vd(iq)=( -vin(isv2(iq))/15.+vin(iq)+vb(inv2(iq)) )*damp
>         enddo
> !cdir nodep
>         do iq=1,ifull
>           ua(iq)=ud(iq)-ud(iwu2(iq))/3.   ! 1st guess
>           va(iq)=vd(iq)-vd(isv2(iq))/3.   ! 1st guess
>         enddo
>         do itn=1,itnmax  ! each loop is a double iteration
> !cdir nodep
>          do iq=1,ifull
>           ub(iq)=ua(iq)/3. -ua(iwu2(iq))/21.
>           vb(iq)=va(iq)/3. -va(isv2(iq))/21.
>          enddo
> !cdir nodep
>          do iq=1,ifull
>           uin(iq)=ud(iq) +ua(ieu2(iq))/15. -ub(iwu2(iq))
>           vin(iq)=vd(iq) +va(inv2(iq))/15. -vb(isv2(iq))
>          enddo
> !cdir nodep
>          do iq=1,ifull
>           ub(iq)=uin(iq)/3. -uin(iwu2(iq))/21.
>           vb(iq)=vin(iq)/3. -vin(isv2(iq))/21.
>          enddo
> !cdir nodep
>          do iq=1,ifull
>            ua(iq)=ud(iq)+uin(ieu2(iq))/15. -ub(iwu2(iq))
>            va(iq)=vd(iq)+vin(inv2(iq))/15. -vb(isv2(iq))
>          enddo
>         enddo  ! itn=1,itnmax
>       endif    ! (mstagpt.eq.4)then  ! usual 4-point scheme reva_b
> 
>       do iq=1,ifull  ! final values for output
>         uout(iq)=ua(iq)
>         vout(iq)=va(iq)
>       enddo
>       return
> 
>       entry revb(uin,vin,uout,vout,ua,va,ub,vb,ud,vd)
> c     reversible y from yh using yh(i-3/4)  (a from b, west-biased b)
> c     ostensibly staggered to unstaggered
>       if(mstagpt.ge.7)then
> !cdir nodep
>         do iq=1,ifull
>           ua(iq)=c10*uin(iwu2(iq)) +c9*uin(iq)
>           va(iq)=c10*vin(isv2(iq)) +c9*vin(iq)
>         enddo
> !cdir nodep
>         do iq=1,ifull
>           ub(ieu2(iq))=ua(iwu2(iq)) +c8*uin(iq) +c7*uin(ieu2(iq))
>           vb(inv2(iq))=va(isv2(iq)) +c8*vin(iq) +c7*vin(inv2(iq))
>         enddo
> !cdir nodep
>         do iq=1,ifull
>           ua(ieu2(iq))=ub(iwu2(iq)) +c6*uin(iq) +c5*uin(ieu2(iq))
>           va(inv2(iq))=vb(isv2(iq)) +c6*vin(iq) +c5*vin(inv2(iq))
>         enddo
> !cdir nodep
>         do iq=1,ifull
>           ub(ieu2(iq))=ua(iwu2(iq)) +c4*uin(iq) +c3*uin(ieu2(iq))
>           vb(inv2(iq))=va(isv2(iq)) +c4*vin(iq) +c3*vin(inv2(iq))
>         enddo
> !cdir nodep
>         do iq=1,ifull
>           uout(iq)=ub(iwu2(iq)) +c2*uin(iq) +c1*uin(ieu2(iq))
>           vout(iq)=vb(isv2(iq)) +c2*vin(iq) +c1*vin(inv2(iq))
>         enddo
>       return
>       endif     ! (mstagpt.ge.7)
> 
>       if(mstagpt.eq.2)then  ! 2-point scheme revb
> !cdir nodep
>         do iq=1,ifull   ! precalculate rhs terms
>           ud(ieu2(iq))= uin(ieu2(iq))/3.+uin(iq)
>           vd(inv2(iq))= vin(inv2(iq))/3.+vin(iq)
>         enddo
> !cdir nodep
>         do iq=1,ifull
>           ua(iq)=ud(iq)-ud(iwu2(iq))/3.   ! 1st guess
>           va(iq)=vd(iq)-vd(isv2(iq))/3.   ! 1st guess
>         enddo
>         do itn=1,itnmax  ! each loop is a double iteration
> !cdir nodep
>          do iq=1,ifull
>           uin(iq)=ud(iq) -ua(iwu2(iq))/3.
>           vin(iq)=vd(iq) -va(isv2(iq))/3.
>          enddo
> !cdir nodep
>          do iq=1,ifull
>           ua(iq)=ud(iq) -uin(iwu2(iq))/3.
>           va(iq)=vd(iq) -vin(isv2(iq))/3.
>          enddo
>         enddo  ! itn=1,itnmax
>       endif     ! (mstagpt.eq.2)  revb
> 
>       if(mstagpt.eq.3)then  ! 3-point scheme revb
> !cdir nodep
>         do iq=1,ifull   ! precalculate rhs terms
>           ud(ieu2(iq))= uin(ieu2(iq))/6.+uin(iq)-uin(iwu2(iq))/10.
>           vd(inv2(iq))= vin(inv2(iq))/6.+vin(iq)-vin(isv2(iq))/10.
>         enddo
> !cdir nodep
>         do iq=1,ifull
>           ua(iq)=ud(iq)-ud(iwu2(iq))/6.   ! 1st guess
>           va(iq)=vd(iq)-vd(isv2(iq))/6.   ! 1st guess
>         enddo
>         do itn=1,itnmax  ! each loop is a double iteration
> !cdir nodep
>          do iq=1,ifull
>           uin(iq)=ud(iq) +ua(ieu2(iq))/10. -ua(iwu2(iq))/6.
>           vin(iq)=vd(iq) +va(inv2(iq))/10. -va(isv2(iq))/6.
>          enddo
> !cdir nodep
>          do iq=1,ifull
>           ua(iq)=ud(iq) +uin(ieu2(iq))/10. -uin(iwu2(iq))/6.
>           va(iq)=vd(iq) +vin(inv2(iq))/10. -vin(isv2(iq))/6.
>          enddo
>         enddo  ! itn=1,itnmax
>       endif     ! (mstagpt.eq.3)  revb
340a922
>       if(mstagpt.eq.-3)then  ! other 3-point scheme revb
342,345c924,933
< c         do iq=1,ifull
< c          ub(iq)=uin(iwu2(iq))
< c          vb(iq)=vin(isv2(iq))
< c         enddo
---
>         do iq=1,ifull   ! precalculate rhs terms
>           ud(ieu2(iq))= uin(ieu2(iq))/2.+uin(iq)+uin(iwu2(iq))/10.
>           vd(inv2(iq))= vin(inv2(iq))/2.+vin(iq)+vin(isv2(iq))/10.
>         enddo
> !cdir nodep
>         do iq=1,ifull
>           ua(iq)=ud(iq)-ud(iwu2(iq))/2.   ! 1st guess
>           va(iq)=vd(iq)-vd(isv2(iq))/2.   ! 1st guess
>         enddo
>         do itn=1,itnmax  ! each loop is a double iteration
347,348c935,937
<          do iq=2,ifull
<           ub(iq)=uin(iq-1)
---
>          do iq=1,ifull
>           ub(iq)=ua(iwu2(iq))
>           vb(iq)=va(isv2(iq))
350,351c939,944
<          do iq=il+1,ifull
<          vb(iq)=vin(iq-il)
---
> !cdir nodep
>          do iq=1,ifull
>           uin(iq)=(ud(iq)-.5*ud(iwu2(iq))
>      .                 -ua(ieu2(iq))/10. +ub(iwu2(iq))/4.)/.95
>           vin(iq)=(vd(iq)-.5*vd(isv2(iq))
>      .                 -va(inv2(iq))/10. +vb(isv2(iq))/4.)/.95
353,354c946,947
< 	  do j=1,jl
< 	   iq=1+(j-1)*il
---
> !cdir nodep
>          do iq=1,ifull
356,376c949
< 	  enddo
< 	  do j=1,jl,2*il
< 	   do i=1,il
< 	    iq=i+(j-1)*il
<            vb(iq)=vin(isv2(iq))
<  	   enddo
< 	  enddo
< !cdir nodep
< c        do iq=1,ifull
< c         ua(iq)=(ud(iq)-.5*ud(iwu2(iq))
< c    .                 -uin(ieu2(iq))/10. +ub(iwu2(iq))/4.)/.95
< c         va(iq)=(vd(iq)-.5*vd(isv2(iq))
< c    .                 -vin(inv2(iq))/10. +vb(isv2(iq))/4.)/.95
< c        enddo
<          do iq=2,ifull-1
<           ua(iq)=(ud(iq)-.5*ud(iq-1)
<      .                 -uin(iq+1)/10. +ub(iq-1)/4.)/.95
<          enddo
<          do iq=il+1,ifull-il
<           va(iq)=(vd(iq)-.5*vd(iq-il)
<      .                 -vin(iq+il)/10. +vb(iq-il)/4.)/.95
---
>           vb(iq)=vin(isv2(iq))
378,382c951,952
< 	  do j=1,jl
< 	   iq=1+(j-1)*il
<           ua(iq)=(ud(iq)-.5*ud(iwu2(iq))
<      .                 -uin(ieu2(iq))/10. +ub(iwu2(iq))/4.)/.95
< 	   iq=il+(j-1)*il
---
> !cdir nodep
>          do iq=1,ifull
385,389c955
< 	  enddo
< 	  do j=1,jl,2*il
< 	   do i=1,il
< 	    iq=i+(j-1)*il
<            va(iq)=(vd(iq)-.5*vd(isv2(iq))
---
>           va(iq)=(vd(iq)-.5*vd(isv2(iq))
391,399c957
<  	   enddo
< 	  enddo
< 	  do j=2*il,jl,2*il
< 	   do i=1,il
< 	    iq=i+(j-1)*il
<            va(iq)=(vd(iq)-.5*vd(isv2(iq))
<      .                 -vin(inv2(iq))/10. +vb(isv2(iq))/4.)/.95
<  	   enddo
< 	  enddo
---
>          enddo
400a959
>       endif     ! (mstagpt.eq.-3)  revb
402,405c961,1645
<         do iq=1,ifull      ! final values for output
<          uout(iq)=ua(iq)
<          vout(iq)=va(iq)
<         enddo   ! iq loop
---
>       if(mstagpt.eq.4)then  ! usual 4-point scheme revb
> !cdir nodep
>         do iq=1,ifull   ! precalculate rhs terms
>           ub(iq)=uin(iq)-uin(iwu2(iq))/15.
>           vb(iq)=vin(iq)-vin(isv2(iq))/15.
>         enddo
> !cdir nodep
>         do iq=1,ifull   ! precalculate rhs terms
>          ud(iq)=( ub(iwu2(iq))+uin(iq)/3.-uin(ieu2(iq))/21. )*damp
>          vd(iq)=( vb(isv2(iq))+vin(iq)/3.-vin(inv2(iq))/21. )*damp
>         enddo
> !cdir nodep
>         do iq=1,ifull
>          ua(iq)=ud(iq)-ud(iwu2(iq))/3.   ! 1st guess
>          va(iq)=vd(iq)-vd(isv2(iq))/3.   ! 1st guess
>         enddo
>         do itn=1,itnmax  ! each loop is a double iteration
> !cdir nodep
>          do iq=1,ifull
>           ub(iq)=ua(iq)/3. -ua(iwu2(iq))/21.
>           vb(iq)=va(iq)/3. -va(isv2(iq))/21.
>          enddo
> !cdir nodep
>          do iq=1,ifull
>           uin(iq)=ud(iq) +ua(ieu2(iq))/15. -ub(iwu2(iq))
>           vin(iq)=vd(iq) +va(inv2(iq))/15. -vb(isv2(iq))
>          enddo
> !cdir nodep
>          do iq=1,ifull
>           ub(iq)=uin(iq)/3. -uin(iwu2(iq))/21.
>           vb(iq)=vin(iq)/3. -vin(isv2(iq))/21.
>          enddo
> !cdir nodep
>          do iq=1,ifull
>           ua(iq)=ud(iq) +uin(ieu2(iq))/15. -ub(iwu2(iq))
>           va(iq)=vd(iq) +vin(inv2(iq))/15. -vb(isv2(iq))
>          enddo
>         enddo  ! itn=1,itnmax
>       endif  ! (mstagpt.eq.4)then  ! usual 4-point scheme revb
> 
>       do iq=1,ifull  ! final values for output
>         uout(iq)=ua(iq)
>         vout(iq)=va(iq)
>       enddo
>       return
> 
>       entry revb_b(uin,vin,uout,vout,ua,va,ub,vb,ud,vd)
> c     reversible y from yh using yh(i-1/4)  (a from b, east-biased b)
>       if(mstagpt.ge.7)then
> !cdir nodep
>         do iq=1,ifull
>           ua(iq)=c10*uin(ieu2(iq)) +c9*uin(iq)
>           va(iq)=c10*vin(inv2(iq)) +c9*vin(iq)
>         enddo
> !cdir nodep
>         do iq=1,ifull
>           ub(iwu2(iq))=ua(ieu2(iq)) +c8*uin(iq) +c7*uin(iwu2(iq))
>           vb(isv2(iq))=va(inv2(iq)) +c8*vin(iq) +c7*vin(isv2(iq))
>         enddo
> !cdir nodep
>         do iq=1,ifull
>           ua(iwu2(iq))=ub(ieu2(iq)) +c6*uin(iq) +c5*uin(iwu2(iq))
>           va(isv2(iq))=vb(inv2(iq)) +c6*vin(iq) +c5*vin(isv2(iq))
>         enddo
> !cdir nodep
>         do iq=1,ifull
>           ub(iwu2(iq))=ua(ieu2(iq)) +c4*uin(iq) +c3*uin(iwu2(iq))
>           vb(isv2(iq))=va(inv2(iq)) +c4*vin(iq) +c3*vin(isv2(iq))
>         enddo
> !cdir nodep
>         do iq=1,ifull ! can't rely on cyclic uout,vout so using ua,va
>           ua(ieu2(iq))=ub(ieu2(iq)) +c2*uin(iq) +c1*uin(iwu2(iq))
>           va(inv2(iq))=vb(inv2(iq)) +c2*vin(iq) +c1*vin(isv2(iq))
>         enddo
>         do iq=1,ifull
>           uout(iq)=ua(iq)
>           vout(iq)=va(iq)
>         enddo
>       return
>       endif     ! (mstagpt.ge.7)
> 
>       if(mstagpt.eq.2)then  ! 2-point scheme revb_b
> !cdir nodep
>         do iq=1,ifull   ! precalculate rhs terms
>           ud(iq)= uin(iq)+uin(iwu2(iq))/3.
>           vd(iq)= vin(iq)+vin(isv2(iq))/3.
>         enddo
> !cdir nodep
>         do iq=1,ifull
>           ua(iq)=ud(iq)-ud(ieu2(iq))/3.   ! 1st guess
>           va(iq)=vd(iq)-vd(inv2(iq))/3.   ! 1st guess
>         enddo
>         do itn=1,itnmax  ! each loop is a double iteration
> !cdir nodep
>          do iq=1,ifull
>           uin(iq)=ud(iq) -ua(ieu2(iq))/3.
>           vin(iq)=vd(iq) -va(inv2(iq))/3.
>          enddo
> !cdir nodep
>          do iq=1,ifull
>           ua(iq)=ud(iq) -uin(ieu2(iq))/3.
>           va(iq)=vd(iq) -vin(inv2(iq))/3.
>          enddo
>         enddo  ! itn=1,itnmax
>       endif     ! (mstagpt.eq.2)  revb_b
> 
>       if(mstagpt.eq.3)then  ! 3-point scheme revb_b
> !cdir nodep
>         do iq=1,ifull   ! precalculate rhs terms
>           ud(iq)= -uin(ieu2(iq))/10.+uin(iq)+uin(iwu2(iq))/6.
>           vd(iq)= -vin(inv2(iq))/10.+vin(iq)+vin(isv2(iq))/6.
>         enddo
> !cdir nodep
>         do iq=1,ifull
>           ua(iq)=ud(iq)-ud(ieu2(iq))/6.   ! 1st guess
>           va(iq)=vd(iq)-vd(inv2(iq))/6.   ! 1st guess
>         enddo
>         do itn=1,itnmax  ! each loop is a double iteration
> !cdir nodep
>          do iq=1,ifull
>           uin(iq)=ud(iq) +ua(iwu2(iq))/10. -ua(ieu2(iq))/6.
>           vin(iq)=vd(iq) +va(isv2(iq))/10. -va(inv2(iq))/6.
>          enddo
> !cdir nodep
>          do iq=1,ifull
>           ua(iq)=ud(iq) +uin(iwu2(iq))/10. -uin(ieu2(iq))/6.
>           va(iq)=vd(iq) +vin(isv2(iq))/10. -vin(inv2(iq))/6.
>          enddo
>         enddo  ! itn=1,itnmax
>       endif     ! (mstagpt.eq.3)  revb_b
> 
>       if(mstagpt.eq.-3)then  ! other 3-point scheme revb_b
> !cdir nodep
>         do iq=1,ifull   ! precalculate rhs terms
>           ud(iq)= uin(ieu2(iq))/10.+uin(iq)+uin(iwu2(iq))/2.
>           vd(iq)= vin(inv2(iq))/10.+vin(iq)+vin(isv2(iq))/2.
>         enddo
> !cdir nodep
>         do iq=1,ifull
>           ua(iq)=ud(iq)-ud(ieu2(iq))/2.   ! 1st guess
>           va(iq)=vd(iq)-vd(inv2(iq))/2.   ! 1st guess
>         enddo
>         do itn=1,itnmax  ! each loop is a double iteration
> !cdir nodep
>          do iq=1,ifull
>           ub(iq)=ua(ieu2(iq))
>           vb(iq)=va(inv2(iq))
>          enddo
> !cdir nodep
>          do iq=1,ifull
>           uin(iq)=(ud(iq)-.5*ud(ieu2(iq))
>      .                 -ua(iwu2(iq))/10. +ub(ieu2(iq))/4.)/.95
>           vin(iq)=(vd(iq)-.5*vd(inv2(iq))
>      .                 -va(isv2(iq))/10. +vb(inv2(iq))/4.)/.95
>          enddo
> !cdir nodep
>          do iq=1,ifull
>           ub(iq)=uin(ieu2(iq))
>           vb(iq)=vin(inv2(iq))
>          enddo
> !cdir nodep
>          do iq=1,ifull
>           ua(iq)=(ud(iq)-.5*ud(ieu2(iq))
>      .                 -uin(iwu2(iq))/10. +ub(ieu2(iq))/4.)/.95
>           va(iq)=(vd(iq)-.5*vd(inv2(iq))
>      .                 -vin(isv2(iq))/10. +vb(inv2(iq))/4.)/.95
>          enddo
>         enddo  ! itn=1,itnmax
>       endif     ! (mstagpt.eq.-3)  revb_b
> 
>       if(mstagpt.eq.4)then  ! usual 4-point scheme revb_b
> !       also use ub as a work array
> !cdir nodep
>         do iq=1,ifull   ! precalculate rhs terms
>           ub(iq)=uin(iq)/3.-uin(iwu2(iq))/21.
>           vb(iq)=vin(iq)/3.-vin(isv2(iq))/21.
>         enddo
> !cdir nodep
>         do iq=1,ifull   ! precalculate rhs terms
>           ud(iq)=( -uin(ieu2(iq))/15.+uin(iq)+ub(iwu2(iq)) )*damp
>           vd(iq)=( -vin(inv2(iq))/15.+vin(iq)+vb(isv2(iq)) )*damp
>         enddo
> !cdir nodep
>         do iq=1,ifull
>           ua(iq)=ud(iq)-ud(ieu2(iq))/3.   ! 1st guess
>           va(iq)=vd(iq)-vd(inv2(iq))/3.   ! 1st guess
>         enddo
>         do itn=1,itnmax  ! each loop is a double iteration
> !cdir nodep
>          do iq=1,ifull
>           ub(iq)=ua(iq)/3. -ua(ieu2(iq))/21.
>           vb(iq)=va(iq)/3. -va(inv2(iq))/21.
>          enddo
> !cdir nodep
>          do iq=1,ifull
>           uin(iq)=ud(iq) +ua(iwu2(iq))/15. -ub(ieu2(iq))
>           vin(iq)=vd(iq) +va(isv2(iq))/15. -vb(inv2(iq))
>          enddo
> !cdir nodep
>          do iq=1,ifull
>           ub(iq)=uin(iq)/3. -uin(ieu2(iq))/21.
>           vb(iq)=vin(iq)/3. -vin(inv2(iq))/21.
>          enddo
> !cdir nodep
>          do iq=1,ifull
>            ua(iq)=ud(iq)+uin(iwu2(iq))/15. -ub(ieu2(iq))
>            va(iq)=vd(iq)+vin(isv2(iq))/15. -vb(inv2(iq))
>          enddo
>         enddo  ! itn=1,itnmax
>       endif  ! (mstagpt.eq.4)then  ! usual 4-point scheme revb_b
> 
>       do iq=1,ifull  ! final values for output
>         uout(iq)=ua(iq)
>         vout(iq)=va(iq)
>       enddo
>       return
>       end
>       subroutine reka(uin,vin,uout,vout,ua,va,ub,vb,ud,vd)  ! Akima
>       include 'newmpar.h'
>       include 'indices.h' ! in,is,iw,ie,inn,iss,iww,iee
>       real uin(ifull),vin(ifull),uout(ifull),vout(ifull)
>       real ua(ifull),va(ifull),ud(ifull),vd(ifull)     ! work arrays
>       real ub(ifull),vb(ifull)                         ! work arrays
>       real ue(2*ifull),ve(ifull),uf(2*ifull),vf(ifull) ! extra  work arrays
>       equivalence (ue(ifull+1),ve),(uf(ifull+1),vf)
>       data itnmax/3/     ! N.B. each loop is a double iteration
> c     reversible yh from y using yh(i+1/4)  (b from a, east-biased a)
> !cdir nodep
>       do iq=1,ifull   ! 1-sided deriv into ue,ve
>         ue(iq)=uin(ieu2(iq))-uin(iq)
>         ve(iq)=vin(inv2(iq))-vin(iq)
>       enddo
> !cdir nodep
>       do iq=1,ifull   ! 2nd deriv into uf,vf
>         uf(iq)=1.e-6+abs( ue(iq)-ue(iwu2(iq)) )
>         vf(iq)=1.e-6+abs( ve(iq)-ve(isv2(iq)) )
>       enddo
> !cdir nodep
>       do iq=1,ifull   ! modified 1st deriv into ub,vb
>         ub(iq)=( uf(ieu2(iq))*ue(iwu2(iq))+uf(iwu2(iq))*ue(iq) )/
>      .         ( uf(ieu2(iq))             +uf(iwu2(iq)) )
>         vb(iq)=( vf(inv2(iq))*ve(isv2(iq))+vf(isv2(iq))*ve(iq) )/
>      .         ( vf(inv2(iq))             +vf(isv2(iq)) )
>       enddo
> !cdir nodep
>       do iq=1,ifull   ! precalculate rhs terms into ud,vd
>         ud(iq)= uin(ieu2(iq))
>      .            +( 10.*uin(iq)+3.*ub(iq)-9.*ub(ieu2(iq)) )/54.
>         vd(iq)= vin(inv2(iq))
>      .            +( 10.*vin(iq)+3.*vb(iq)-9.*vb(inv2(iq)) )/54.
>       enddo
> !cdir nodep
>       do iq=1,ifull
>         ua(iq)=ud(iq)-ud(ieu2(iq))/3.   ! 1st guess
>         va(iq)=vd(iq)-vd(inv2(iq))/3.   ! 1st guess
>       enddo
>       do itn=1,itnmax  ! each loop is a double iteration
> !cdir nodep
>        do iq=1,ifull   ! 1-sided deriv into ue,ve
>          ue(iq)=ua(ieu2(iq))-ua(iq)
>          ve(iq)=va(inv2(iq))-va(iq)
>        enddo
> !cdir nodep
>        do iq=1,ifull   ! 2nd deriv into uf,vf
>          uf(iq)=1.e-6+abs( ue(iq)-ue(iwu2(iq)) )
>          vf(iq)=1.e-6+abs( ve(iq)-ve(isv2(iq)) )
>        enddo
> !cdir nodep
>        do iq=1,ifull   ! modified 1st deriv into ub,vb
>          ub(iq)=( uf(ieu2(iq))*ue(iwu2(iq))+uf(iwu2(iq))*ue(iq) )/
>      .          ( uf(ieu2(iq))             +uf(iwu2(iq)) )
>          vb(iq)=( vf(inv2(iq))*ve(isv2(iq))+vf(isv2(iq))*ve(iq) )/
>      .          ( vf(inv2(iq))             +vf(isv2(iq)) )
>        enddo
> !cdir nodep
>        do iq=1,ifull
>         uin(iq)=ud(iq)
>      .      -(10.*ua(ieu2(iq)) +9.*ub(iq) -3.*ub(ieu2(iq)) )/54.
>         vin(iq)=vd(iq)
>      .      -(10.*va(inv2(iq)) +9.*vb(iq) -3.*vb(inv2(iq)) )/54.
>        enddo
> !cdir nodep      ! 2nd half of itn loop
>        do iq=1,ifull   ! 1-sided deriv into ue,ve
>          ue(iq)=uin(ieu2(iq))-uin(iq)
>          ve(iq)=vin(inv2(iq))-vin(iq)
>        enddo
> !cdir nodep
>        do iq=1,ifull   ! 2nd deriv into uf,vf
>          uf(iq)=1.e-6+abs( ue(iq)-ue(iwu2(iq)) )
>          vf(iq)=1.e-6+abs( ve(iq)-ve(isv2(iq)) )
>        enddo
> !cdir nodep
>        do iq=1,ifull   ! modified 1st deriv into ub,vb
>          ub(iq)=( uf(ieu2(iq))*ue(iwu2(iq))+uf(iwu2(iq))*ue(iq) )/
>      .          ( uf(ieu2(iq))             +uf(iwu2(iq)) )
>          vb(iq)=( vf(inv2(iq))*ve(isv2(iq))+vf(isv2(iq))*ve(iq) )/
>      .          ( vf(inv2(iq))             +vf(isv2(iq)) )
>        enddo
> !cdir nodep
>        do iq=1,ifull
>         ua(iq)=ud(iq)
>      .      -(10.*uin(ieu2(iq)) +9.*ub(iq) -3.*ub(ieu2(iq)) )/54.
>         va(iq)=vd(iq)
>      .      -(10.*vin(inv2(iq)) +9.*vb(iq) -3.*vb(inv2(iq)) )/54.
>        enddo
>       enddo  ! itn=1,itnmax
>       do iq=1,ifull  ! final values for output
>         uout(iq)=ua(iq)
>         vout(iq)=va(iq)
>       enddo
>       return
> 
>       entry reka_b(uin,vin,uout,vout,ua,va,ub,vb,ud,vd)     ! Akima
> c     reversible yh from y using yh(i-1/4)  (b from a, west-biased a)
> c     also use ub as a work array
> !cdir nodep
>       do iq=1,ifull   ! 1-sided deriv into ue,ve
>         ue(iq)=uin(ieu2(iq))-uin(iq)
>         ve(iq)=vin(inv2(iq))-vin(iq)
>       enddo
> !cdir nodep
>       do iq=1,ifull   ! 2nd deriv into uf,vf
>         uf(iq)=1.e-6+abs( ue(iq)-ue(iwu2(iq)) )
>         vf(iq)=1.e-6+abs( ve(iq)-ve(isv2(iq)) )
>       enddo
> !cdir nodep
>       do iq=1,ifull   ! modified 1st deriv into ub,vb
>         ub(iq)=( uf(ieu2(iq))*ue(iwu2(iq))+uf(iwu2(iq))*ue(iq) )/
>      .         ( uf(ieu2(iq))             +uf(iwu2(iq)) )
>         vb(iq)=( vf(inv2(iq))*ve(isv2(iq))+vf(isv2(iq))*ve(iq) )/
>      .         ( vf(inv2(iq))             +vf(isv2(iq)) )
>       enddo
> !cdir nodep
>       do iq=1,ifull   ! precalculate rhs terms into ud,vd
>         ud(iq)= uin(iq)
>      .            +( 10.*uin(ieu2(iq))+9.*ub(iq)-3.*ub(ieu2(iq)) )/54.
>         vd(iq)= vin(iq)
>      .            +( 10.*vin(inv2(iq))+9.*vb(iq)-3.*vb(inv2(iq)) )/54.
>       enddo
> 
> !cdir nodep
>       do iq=1,ifull
>         ua(iq)=ud(iq)-ud(iwu2(iq))/3.   ! 1st guess
>         va(iq)=vd(iq)-vd(isv2(iq))/3.   ! 1st guess
>       enddo
>       do itn=1,itnmax  ! each loop is a double iteration
> !cdir nodep
>        do iq=1,ifull   ! 1-sided deriv into ue,ve
>          ue(iq)=ua(ieu2(iq))-ua(iq)
>          ve(iq)=va(inv2(iq))-va(iq)
>        enddo
> !cdir nodep
>        do iq=1,ifull   ! 2nd deriv into uf,vf
>          uf(iq)=1.e-6+abs( ue(iq)-ue(iwu2(iq)) )
>          vf(iq)=1.e-6+abs( ve(iq)-ve(isv2(iq)) )
>        enddo
> !cdir nodep
>        do iq=1,ifull   ! modified 1st deriv into ub,vb
>          ub(iq)=( uf(ieu2(iq))*ue(iwu2(iq))+uf(iwu2(iq))*ue(iq) )/
>      .          ( uf(ieu2(iq))             +uf(iwu2(iq)) )
>          vb(iq)=( vf(inv2(iq))*ve(isv2(iq))+vf(isv2(iq))*ve(iq) )/
>      .          ( vf(inv2(iq))             +vf(isv2(iq)) )
>        enddo
> !cdir nodep
>        do iq=1,ifull
>         uin(iq)=ud(iq)
>      .      -(10.*ua(iwu2(iq)) -9.*ub(iq) +3.*ub(iwu2(iq)) )/54.
>         vin(iq)=vd(iq)
>      .      -(10.*va(isv2(iq)) -9.*vb(iq) +3.*vb(isv2(iq)) )/54.
>        enddo
> !cdir nodep      ! 2nd half of itn loop
>        do iq=1,ifull   ! 1-sided deriv into ue,ve
>          ue(iq)=uin(ieu2(iq))-uin(iq)
>          ve(iq)=vin(inv2(iq))-vin(iq)
>        enddo
> !cdir nodep
>        do iq=1,ifull   ! 2nd deriv into uf,vf
>          uf(iq)=1.e-6+abs( ue(iq)-ue(iwu2(iq)) )
>          vf(iq)=1.e-6+abs( ve(iq)-ve(isv2(iq)) )
>        enddo
> !cdir nodep
>        do iq=1,ifull   ! modified 1st deriv into ub,vb
>          ub(iq)=( uf(ieu2(iq))*ue(iwu2(iq))+uf(iwu2(iq))*ue(iq) )/
>      .          ( uf(ieu2(iq))             +uf(iwu2(iq)) )
>          vb(iq)=( vf(inv2(iq))*ve(isv2(iq))+vf(isv2(iq))*ve(iq) )/
>      .          ( vf(inv2(iq))             +vf(isv2(iq)) )
>        enddo
> !cdir nodep
>        do iq=1,ifull
>         ua(iq)=ud(iq)
>      .      -(10.*uin(iwu2(iq)) -9.*ub(iq) +3.*ub(iwu2(iq)) )/54.
>         va(iq)=vd(iq)
>      .      -(10.*vin(isv2(iq)) -9.*vb(iq) +3.*vb(isv2(iq)) )/54.
>        enddo
>       enddo  ! itn=1,itnmax
>       do iq=1,ifull  ! final values for output
>         uout(iq)=ua(iq)
>         vout(iq)=va(iq)
>       enddo
>       return
> 
>       entry rekb(uin,vin,uout,vout,ua,va,ub,vb,ud,vd)
> c     reversible y from yh using yh(i-3/4)  (a from b, west-biased b)
> c     ostensibly staggered to unstaggered
> !cdir nodep
>       do iq=1,ifull   ! 1-sided deriv into ue,ve
>         ue(iq)=uin(ieu2(iq))-uin(iq)
>         ve(iq)=vin(inv2(iq))-vin(iq)
>       enddo
> !cdir nodep
>       do iq=1,ifull   ! 2nd deriv into uf,vf
>         uf(iq)=1.e-6+abs( ue(iq)-ue(iwu2(iq)) )
>         vf(iq)=1.e-6+abs( ve(iq)-ve(isv2(iq)) )
>       enddo
> !cdir nodep
>       do iq=1,ifull   ! modified 1st deriv into ub,vb
>         ub(iq)=( uf(ieu2(iq))*ue(iwu2(iq))+uf(iwu2(iq))*ue(iq) )/
>      .         ( uf(ieu2(iq))             +uf(iwu2(iq)) )
>         vb(iq)=( vf(inv2(iq))*ve(isv2(iq))+vf(isv2(iq))*ve(iq) )/
>      .         ( vf(inv2(iq))             +vf(isv2(iq)) )
>       enddo
> !cdir nodep
>       do iq=1,ifull   ! precalculate rhs terms into ud,vd
>         ud(iq)= uin(iq)
>      .            +( 10.*uin(ieu2(iq))+9.*ub(iq)-3.*ub(ieu2(iq)) )/54.
>         vd(iq)= vin(iq)
>      .            +( 10.*vin(inv2(iq))+9.*vb(iq)-3.*vb(inv2(iq)) )/54.
>       enddo
> 
> !cdir nodep
>       do iq=1,ifull
>        ua(iq)=ud(iq)-ud(iwu2(iq))/3.   ! 1st guess
>        va(iq)=vd(iq)-vd(isv2(iq))/3.   ! 1st guess
>       enddo
>       do itn=1,itnmax  ! each loop is a double iteration
> !cdir nodep
>        do iq=1,ifull   ! 1-sided deriv into ue,ve
>          ue(iq)=ua(ieu2(iq))-ua(iq)
>          ve(iq)=va(inv2(iq))-va(iq)
>        enddo
> !cdir nodep
>        do iq=1,ifull   ! 2nd deriv into uf,vf
>          uf(iq)=1.e-6+abs( ue(iq)-ue(iwu2(iq)) )
>          vf(iq)=1.e-6+abs( ve(iq)-ve(isv2(iq)) )
>        enddo
> !cdir nodep
>        do iq=1,ifull   ! modified 1st deriv into ub,vb
>          ub(iq)=( uf(ieu2(iq))*ue(iwu2(iq))+uf(iwu2(iq))*ue(iq) )/
>      .          ( uf(ieu2(iq))             +uf(iwu2(iq)) )
>          vb(iq)=( vf(inv2(iq))*ve(isv2(iq))+vf(isv2(iq))*ve(iq) )/
>      .          ( vf(inv2(iq))             +vf(isv2(iq)) )
>        enddo
> !cdir nodep
>        do iq=1,ifull
>         uin(ieu2(iq))=ud(iq)
>      .      -(10.*ua(iq) +3.*ub(iq) -9.*ub(ieu2(iq)) )/54.
>         vin(inv2(iq))=vd(iq)
>      .      -(10.*va(iq) +3.*vb(iq) -9.*vb(inv2(iq)) )/54.
>        enddo
> !cdir nodep      ! 2nd half of itn loop
>        do iq=1,ifull   ! 1-sided deriv into ue,ve
>          ue(iq)=uin(ieu2(iq))-uin(iq)
>          ve(iq)=vin(inv2(iq))-vin(iq)
>        enddo
> !cdir nodep
>        do iq=1,ifull   ! 2nd deriv into uf,vf
>          uf(iq)=1.e-6+abs( ue(iq)-ue(iwu2(iq)) )
>          vf(iq)=1.e-6+abs( ve(iq)-ve(isv2(iq)) )
>        enddo
> !cdir nodep
>        do iq=1,ifull   ! modified 1st deriv into ub,vb
>          ub(iq)=( uf(ieu2(iq))*ue(iwu2(iq))+uf(iwu2(iq))*ue(iq) )/
>      .          ( uf(ieu2(iq))             +uf(iwu2(iq)) )
>          vb(iq)=( vf(inv2(iq))*ve(isv2(iq))+vf(isv2(iq))*ve(iq) )/
>      .          ( vf(inv2(iq))             +vf(isv2(iq)) )
>        enddo
> !cdir nodep
>        do iq=1,ifull
>         ua(ieu2(iq))=ud(iq)
>      .      -(10.*uin(iq) +3.*ub(iq) -9.*ub(ieu2(iq)) )/54.
>         va(inv2(iq))=vd(iq)
>      .      -(10.*vin(iq) +3.*vb(iq) -9.*vb(inv2(iq)) )/54.
>        enddo
>       enddo  ! itn=1,itnmax
> !cdir nodep
>        do iq=1,ifull   ! 1-sided deriv into ue,ve
>          ue(iq)=ua(ieu2(iq))-ua(iq)
>          ve(iq)=va(inv2(iq))-va(iq)
>        enddo
> !cdir nodep
>        do iq=1,ifull   ! 2nd deriv into uf,vf
>          uf(iq)=1.e-6+abs( ue(iq)-ue(iwu2(iq)) )
>          vf(iq)=1.e-6+abs( ve(iq)-ve(isv2(iq)) )
>        enddo
> !cdir nodep
>        do iq=1,ifull   ! modified 1st deriv into ub,vb
>          ub(iq)=( uf(ieu2(iq))*ue(iwu2(iq))+uf(iwu2(iq))*ue(iq) )/
>      .          ( uf(ieu2(iq))             +uf(iwu2(iq)) )
>          vb(iq)=( vf(inv2(iq))*ve(isv2(iq))+vf(isv2(iq))*ve(iq) )/
>      .          ( vf(inv2(iq))             +vf(isv2(iq)) )
>        enddo
>       do iq=1,ifull  ! final values for output
>         uout(iq)=ua(iq)
>         vout(iq)=va(iq)
>       enddo
>       return
> 
>       entry rekb_b(uin,vin,uout,vout,ua,va,ub,vb,ud,vd)
> c     reversible y from yh using yh(i-1/4)  (a from b, east-biased b)
> c     also use ub as a work array
> !cdir nodep
>       do iq=1,ifull   ! 1-sided deriv into ue,ve
>         ue(iq)=uin(ieu2(iq))-uin(iq)
>         ve(iq)=vin(inv2(iq))-vin(iq)
>       enddo
> !cdir nodep
>       do iq=1,ifull   ! 2nd deriv into uf,vf
>         uf(iq)=1.e-6+abs( ue(iq)-ue(iwu2(iq)) )
>         vf(iq)=1.e-6+abs( ve(iq)-ve(isv2(iq)) )
>       enddo
> !cdir nodep
>       do iq=1,ifull   ! modified 1st deriv into ub,vb
>         ub(iq)=( uf(ieu2(iq))*ue(iwu2(iq))+uf(iwu2(iq))*ue(iq) )/
>      .         ( uf(ieu2(iq))             +uf(iwu2(iq)) )
>         vb(iq)=( vf(inv2(iq))*ve(isv2(iq))+vf(isv2(iq))*ve(iq) )/
>      .         ( vf(inv2(iq))             +vf(isv2(iq)) )
>       enddo
> !cdir nodep
>       do iq=1,ifull   ! precalculate rhs terms into ud,vd
>         ud(iq)= uin(iq)
>      .            +( 10.*uin(iwu2(iq))+3.*ub(iwu2(iq))-9.*ub(iq) )/54.
>         vd(iq)= vin(iq)
>      .            +( 10.*vin(isv2(iq))+3.*vb(isv2(iq))-9.*vb(iq) )/54.
>       enddo
> 
> !cdir nodep
>       do iq=1,ifull
>         ua(iq)=ud(iq)-ud(ieu2(iq))/3.   ! 1st guess
>         va(iq)=vd(iq)-vd(inv2(iq))/3.   ! 1st guess
>       enddo
>       do itn=1,itnmax  ! each loop is a double iteration
> !cdir nodep
>        do iq=1,ifull   ! 1-sided deriv into ue,ve
>          ue(iq)=ua(ieu2(iq))-ua(iq)
>          ve(iq)=va(inv2(iq))-va(iq)
>        enddo
> !cdir nodep
>        do iq=1,ifull   ! 2nd deriv into uf,vf
>          uf(iq)=1.e-6+abs( ue(iq)-ue(iwu2(iq)) )
>          vf(iq)=1.e-6+abs( ve(iq)-ve(isv2(iq)) )
>        enddo
> !cdir nodep
>        do iq=1,ifull   ! modified 1st deriv into ub,vb
>          ub(iq)=( uf(ieu2(iq))*ue(iwu2(iq))+uf(iwu2(iq))*ue(iq) )/
>      .          ( uf(ieu2(iq))             +uf(iwu2(iq)) )
>          vb(iq)=( vf(inv2(iq))*ve(isv2(iq))+vf(isv2(iq))*ve(iq) )/
>      .          ( vf(inv2(iq))             +vf(isv2(iq)) )
>        enddo
> !cdir nodep
>        do iq=1,ifull
>         uin(iq)=ud(iq)
>      .      -(10.*ua(ieu2(iq)) +9.*ub(iq) -3.*ub(ieu2(iq)) )/54.
>         vin(iq)=vd(iq)
>      .      -(10.*va(inv2(iq)) +9.*vb(iq) -3.*vb(inv2(iq)) )/54.
>        enddo
> !cdir nodep      ! 2nd half of itn loop
>        do iq=1,ifull   ! 1-sided deriv into ue,ve
>          ue(iq)=uin(ieu2(iq))-uin(iq)
>          ve(iq)=vin(inv2(iq))-vin(iq)
>        enddo
> !cdir nodep
>        do iq=1,ifull   ! 2nd deriv into uf,vf
>          uf(iq)=1.e-6+abs( ue(iq)-ue(iwu2(iq)) )
>          vf(iq)=1.e-6+abs( ve(iq)-ve(isv2(iq)) )
>        enddo
> !cdir nodep
>        do iq=1,ifull   ! modified 1st deriv into ub,vb
>          ub(iq)=( uf(ieu2(iq))*ue(iwu2(iq))+uf(iwu2(iq))*ue(iq) )/
>      .          ( uf(ieu2(iq))             +uf(iwu2(iq)) )
>          vb(iq)=( vf(inv2(iq))*ve(isv2(iq))+vf(isv2(iq))*ve(iq) )/
>      .          ( vf(inv2(iq))             +vf(isv2(iq)) )
>        enddo
> !cdir nodep
>        do iq=1,ifull
>         ua(iq)=ud(iq)
>      .      -(10.*uin(ieu2(iq)) +9.*ub(iq) -3.*ub(ieu2(iq)) )/54.
>         va(iq)=vd(iq)
>      .      -(10.*vin(inv2(iq)) +9.*vb(iq) -3.*vb(inv2(iq)) )/54.
>        enddo
>       enddo  ! itn=1,itnmax
>       do iq=1,ifull  ! final values for output
>         uout(iq)=ua(iq)
>         vout(iq)=va(iq)
>       enddo
>       return
>       end
> 
>       subroutine rev_stag(uin,vin,uout,vout,ua,va,ub,vb,ud,vd)
> c     new reversible jlm by iteration giving staggered values
>       include 'newmpar.h'
>       include 'indices.h' ! in,is,iw,ie,inn,iss,iww,iee
>       include 'parmhor.h' ! mstagpt
>       real uin(ifull),vin(ifull),uout(ifull),vout(ifull)
>       real ua(ifull),va(ifull),ud(ifull),vd(ifull)     ! work arrays
>       real ub(ifull),vb(ifull)                         ! work arrays
>       integer num
> 
>       data itnmax/3/,num/0/     ! N.B. each loop is a double iteration
>       save num
>       if(num.eq.0)then
>         print *,'in rev_stag mstagpt,itnmax ',
>      .                       mstagpt,itnmax
>         num=1
>       endif
> 
> !cdir nodep
>       do iq=1,ifull    ! precalculate terms for ee & nn
>        ud(iq)= uin(ieu2(iq))
>        vd(iq)= vin(inv2(iq))
>       enddo
> !cdir nodep
>       do iq=1,ifull    ! 1st guess
>         ua(iq)=(7.*(uin(iq)+uin(ieu2(iq)))
>      .             -uin(iwu2(iq))-ud(ieu2(iq))  )/12.
>         va(iq)=(7.*(vin(iq)+vin(inv2(iq)))
>      .             -vin(isv2(iq))-vd(inv2(iq))  )/12.
>       enddo
>       do itn=1,itnmax  ! each loop is a double iteration
> !cdir nodep
>        do iq=1,ifull
>         ub(iq)=(4.*(uin(iq)+uin(ieu2(iq)))
>      .             -ua(iwu2(iq))-ua(ieu2(iq))  )/6.
>         vb(iq)=(4.*(vin(iq)+vin(inv2(iq)))
>      .             -va(isv2(iq))-va(inv2(iq))  )/6.
>        enddo
> !cdir nodep
>        do iq=1,ifull
>         ua(iq)=(4.*(uin(iq)+uin(ieu2(iq)))
>      .             -ub(iwu2(iq))-ub(ieu2(iq))  )/6.
>         va(iq)=(4.*(vin(iq)+vin(inv2(iq)))
>      .             -vb(isv2(iq))-vb(inv2(iq))  )/6.
>        enddo
>       enddo  ! itn=1,itnmax
> 
>       do iq=1,ifull    ! final values for output
>         uout(iq)=ua(iq)
>         vout(iq)=va(iq)
>       enddo
>       return
> 
>       entry rev_unst(uin,vin,uout,vout,ua,va,ub,vb,ud,vd)
> c     new reversible jlm by iteration giving unstaggered values
> !cdir nodep
>       do iq=1,ifull    ! precalculate terms for ww & ss
>        ud(iq)= uin(iwu2(iq))
>        vd(iq)= vin(isv2(iq))
>       enddo
> !cdir nodep
>       do iq=1,ifull    ! 1st guess
>         ua(iq)=(7.*(uin(iq)+uin(iwu2(iq)))
>      .             -ud(iwu2(iq))-uin(ieu2(iq))  )/12.
>         va(iq)=(7.*(vin(iq)+vin(isv2(iq)))
>      .             -vd(isv2(iq))-vin(inv2(iq))  )/12.
>       enddo
>       do itn=1,itnmax  ! each loop is a double iteration
> !cdir nodep
>        do iq=1,ifull
>         ub(iq)=(4.*(uin(iq)+uin(iwu2(iq)))
>      .             -ua(iwu2(iq))-ua(ieu2(iq))  )/6.
>         vb(iq)=(4.*(vin(iq)+vin(isv2(iq)))
>      .             -va(isv2(iq))-va(inv2(iq))  )/6.
>        enddo
> !cdir nodep
>        do iq=1,ifull
>         ua(iq)=(4.*(uin(iq)+uin(iwu2(iq)))
>      .             -ub(iwu2(iq))-ub(ieu2(iq))  )/6.
>         va(iq)=(4.*(vin(iq)+vin(isv2(iq)))
>      .             -vb(isv2(iq))-vb(inv2(iq))  )/6.
>        enddo
>       enddo  ! itn=1,itnmax
> 
>       do iq=1,ifull    ! final values for output
>         uout(iq)=ua(iq)
>         vout(iq)=va(iq)
>       enddo
407c1647,1648
<       end        
---
>       end
> 
=====================================
 
swr99.f
=====================================
=====================================
 
table.f
=====================================
=====================================
 
test.f
=====================================
=====================================
 
testlatl.f
=====================================
=====================================
 
tmaxmin.f
=====================================
=====================================
 
tmaxminx.f
=====================================
=====================================
 
topfilt.f
=====================================
=====================================
 
topgenx.f
=====================================
=====================================
 
topmerge.f
=====================================
=====================================
 
trim.f
=====================================
=====================================
 
tvdtest.f
=====================================
=====================================
 
updps.f
=====================================
13,15c13,17
<       common/work3/d(ifull,kl),e(ifull,kl),ee(ifull,kl),dum2(ifull,2*kl)
<       real omgf(ifull,kl)
<       equivalence (omgf,dpsldt)
---
> c     common/sdotsav/sdotsav(ifull,kl) ! adjust5, updps, vadv30
>       common/work3/d(ifull,kl),e(ifull,kl),ee(ifull,kl),dum2(ifull,kl)
>       common/work3d/tomgsav(ifull,kl)   ! just in adjust5, nonlin & updps
>       real omgf(ifull,kl),omgfnl(ifull,kl)
>       equivalence (omgf,dpsldt),(omgfnl,tomgsav)
17c19
< *cdir nodep
---
> *      vdir nodep
53,54c55,56
<  !      omgfnl(iq,k)=-rata(k)*ee(iq,k+1)-ratb(k)*ee(iq,k)
<  !   .                 -sig(k)*dpsldt(iq,k)
---
>         omgfnl(iq,k)=-rata(k)*ee(iq,k+1)-ratb(k)*ee(iq,k)
>      .                 -sig(k)*dpsldt(iq,k)
60c62
< !      omgfnl(iq,kl)=-ratb(kl)*ee(iq,kl)-sig(kl)*dpsldt(iq,kl)
---
>        omgfnl(iq,kl)=-ratb(kl)*ee(iq,kl)-sig(kl)*dpsldt(iq,kl)
75a78,81
> 
> c     do kq=1,ijk
> c      sdotsav(kq,1)=sdot(kq,1) ! Mon  07-06-1998
> c     enddo    !  kq loop
=====================================
 
upglobal.f
=====================================
4a5
> !     ux and vx then qg, [q1, q2,], tx, pslx to allow for hordifg
9c10
<       include 'liqwpar.h'  ! ifullw
---
>       include 'liqwpar.h'
13,14c14,15
<       include 'parmdyn.h'  
<       include 'parmhor.h'  ! mhint, m_bs, nt_adv
---
>       include 'parmdyn.h'  ! morder,ntomg
>       include 'parmhor.h'  ! mhint, m_bs, morder, nt_adv
22a24
>       common/mfixdiag/alph_p,alph_pm,delneg,delpos,alph_q
24,25c26,29
<       common/work2/uavx(ifull),vavx(ifull)       
<      .      ,uc(ifull),vc(ifull),wc(ifull) 
---
>       common/work2/x3d(ifull),y3d(ifull),z3d(ifull)   ! depts
>      .      ,uavx(ifull),vavx(ifull)       ! upglobal,hordifg/t (not needed now)
>      .      ,uc(ifull),vc(ifull),wc(ifull) ! upglobal,hordifg/t
>      .      ,uav(ifull),vav(ifull)         ! upglobal,hordifg/t
27,29c31,34
<      .      ,delcor(ifull),fxx(ifull),dum2(6*ifull)
<       common/work2c/x3d(ifull),y3d(ifull),z3d(ifull)   ! upglobal depts 
<       common/work3f/nface(ifull,kl),xg(ifull,kl),yg(ifull,kl) ! depts, upglobal
---
>      .      ,delcor(ifull),fxx(ifull),dum2(ifull,1)
>       common/work3/nface(ifull,kl),xg(ifull,kl),yg(ifull,kl) ! depts, upglobal
>      .             ,pslxsav(ifull,kl)
>       common/work3b/wrk1(ifull,kl),wrk2(ifull,kl)   ! just work arrays here
71,72c76
<        if(ndept.eq.0)call depts(k)     ! this one without its own k loop
<        if(ndept.eq.1)call depts1(k)    ! this one without its own k loop
---
>        call depts(k)     ! this one without its own k loop
87a92,98
>        if(mfix.eq.-1)then
> !        save pslx in pslxsav for mfix=-1
>          do iq=1,ifull
>           pslxsav(iq,k)=pslx(iq,k)
>          enddo   ! iq loop
>        endif     ! mfix.eq.-1
> 
112a124,253
>        if(nritch.eq.99)then   ! Ritchie & Tanguay 1995 treatment 99
> !        like 100, but explicit for grad(zs)
>          do iq=1,ifull                                                   !
>           pslx(iq,k)=pslx(iq,k)+dd(iq)
>          enddo    ! iq loop                                               !
>          do iq=1,ifull   !  staggered zs gradients first
>           aa(iq)=dd(ie(iq))-dd(iq)
>           bb(iq)=dd(in(iq))-dd(iq)
>          enddo   ! iq loop                                               !
>          call unstaguv(aa,bb,cc,cc2) ! convert to unstaggered positions
>          do iq=1,ifull   !  this is for 2nd order only
>           cc2(iq)=(ubar(iq,k)*cc(iq)+vbar(iq,k)*cc2(iq) )
>      .            *2./(1.+epst(iq))    ! factored to be all explicit
>          enddo    ! iq loop                                               !
>        endif      ! nritch.eq.99
> 
>        if(nritch.eq.100)then   ! Ritchie & Tanguay 1995 treatment 100
>          do iq=1,ifull   !  this is for morder_r=2
> !         N.B. in depts:  ubar(iq,k)=ubar(iq,k)*dt *.5*em(iq)/ds       !
>           aa(iq)=ubar(iq,k)*(dd(ie(iq))-dd(iw(iq)))  ! unstag u, v !
>           bb(iq)=vbar(iq,k)*(dd(in(iq))-dd(is(iq)))  ! at tau + .5 !
>           cc(iq)=(aa(iq)+bb(iq))*.5                                !
>          enddo   ! iq loop                                               !
>          do iq=1,ifull                                                   !
>           pslx(iq,k)=pslx(iq,k)+dd(iq)+cc(iq)*(1.-epst(iq))
>          enddo    ! iq loop                                               !
>          do iq=1,ifull   !  staggered zs gradients first
>           aa(iq)=dd(ie(iq))-dd(iq)
>           bb(iq)=dd(in(iq))-dd(iq)
>          enddo   ! iq loop                                               !
>          call unstaguv(aa,bb,cc,cc2) ! convert to unstaggered positions
>          do iq=1,ifull   !  this is for 2nd order only
>           cc2(iq)=ubar(iq,k)*cc(iq)+vbar(iq,k)*cc2(iq)  ! scale to 103 usage
>          enddo    ! iq loop                                               !
>        endif      ! nritch.eq.100
> 
>        if(nritch.eq.101)then   ! Ritchie & Tanguay 1995 treatment 101
> !        probably should recalculate sdot, omg in nonlin using similar in updps
> !        this goes with morder=24
>          do iq=1,ifull   !  staggered zs gradients first
>           aa(iq)=dd(ie(iq))-dd(iq)
>           bb(iq)=dd(in(iq))-dd(iq)
>          enddo   ! iq loop                                               !
>          call unstaguv(aa,bb,cc,cc2) ! convert to unstaggered positions
>          do iq=1,ifull   !  this is for 2nd order only
> !         N.B. in depts:  ubar(iq,k)=ubar(iq,k)*dt *.5*em(iq)/ds       !
>           cc(iq)=ubar(iq,k)*cc(iq)+vbar(iq,k)*cc2(iq)  ! scale to 103 usage
>          enddo    ! iq loop                                               !
>          do iq=1,ifull                                                   !
>           cc2(iq)=cc(iq)
>           pslx(iq,k)=pslx(iq,k)+dd(iq)+cc(iq)*(1.-epst(iq))
>          enddo    ! iq loop                                               !
>        endif      ! nritch.eq.101
> 
>        if(nritch.eq.102)then   ! Ritchie & Tanguay 1995 treatment 102
>          do iq=1,ifull   !  staggered zs gradients first
>           aa(iq)=dd(ie(iq))-dd(iq)
>           bb(iq)=dd(in(iq))-dd(iq)
>          enddo   ! iq loop                                               !
>          nspec_us=1   ! special turned on
>          call unstaguv(aa,bb,cc,cc2) ! convert to unstaggered positions
>          do iq=1,ifull   !  this is for 2nd order only
> !         N.B. in depts:  ubar(iq,k)=ubar(iq,k)*dt *.5*em(iq)/ds       !
>           cc(iq)=ubar(iq,k)*cc(iq)+vbar(iq,k)*cc2(iq)  ! scale to 103 usage
>          enddo    ! iq loop                                               !
>          do iq=1,ifull                                                   !
>           pslx(iq,k)=pslx(iq,k)+dd(iq)+cc(iq)*(1.-epst(iq))
>          enddo    ! iq loop                                               !
>          nspec_us=0   ! special turned off
>          call unstaguv(aa,bb,cc,cc2) ! convert to unstaggered positions
>          do iq=1,ifull   !  this is for 2nd order only
>           cc2(iq)=ubar(iq,k)*cc(iq)+vbar(iq,k)*cc2(iq)  ! scale to 103 usage
>          enddo    ! iq loop                                               !
>        endif      ! nritch.eq.102
> 
>        if(nritch.eq.103)then   ! Ritchie & Tanguay 1995 treatment 103    !
>          do iq=1,ifull   !  this is for morder_r=2
> !         N.B. in depts:  ubar(iq,k)=ubar(iq,k)*dt *.5*em(iq)/ds       !
>           aa(iq)=ubar(iq,k)*(dd(ie(iq))-dd(iw(iq)))  ! unstag u, v !
>           bb(iq)=vbar(iq,k)*(dd(in(iq))-dd(is(iq)))  ! at tau + .5 !
>           cc(iq)=(aa(iq)+bb(iq))*.5                                !
>           cc2(iq)=cc(iq)
>          enddo   ! iq loop                                               !
>          if(morder_r.gt.2)then  !  i.e. 4 or 42
>            do iq=1,ifull                                                 !
>             aa(iq)=ubar(iq,k)*(8.*(dd(ie(iq))-dd(iw(iq)))
>      .                           +dd(iww(iq))-dd(iee(iq)))/6.
>             bb(iq)=vbar(iq,k)*(8.*(dd(in(iq))-dd(is(iq)))
>      .                           +dd(iss(iq))-dd(inn(iq)))/6.
>             cc(iq)=(aa(iq)+bb(iq))*.5                                    !
>            enddo   ! iq loop                                             !
>            if(morder_r.eq.4)then
>              do iq=1,ifull                                               !
>               cc2(iq)=cc(iq)
>              enddo   ! iq loop                                           !
>            endif     ! (morder_r.eq.4)
>          endif       ! (morder_r.gt.2)
>          do iq=1,ifull                                                   !
>           pslx(iq,k)=pslx(iq,k)+dd(iq)+cc(iq)*(1.-epst(iq))
>          enddo    ! iq loop                                              !
>        endif      ! nritch.eq.103                                        !
> 
>        if(nritch.eq.104)then   ! Ritchie & Tanguay 1995 treatment 104
> !        like 103, but explicit for grad(zs)
>          do iq=1,ifull   !  this is for morder_r=2
> !         N.B. in depts:  ubar(iq,k)=ubar(iq,k)*dt *.5*em(iq)/ds       !
>           aa(iq)=ubar(iq,k)*(dd(ie(iq))-dd(iw(iq)))  ! unstag u, v !
>           bb(iq)=vbar(iq,k)*(dd(in(iq))-dd(is(iq)))  ! at tau + .5 !
>           cc(iq)=(aa(iq)+bb(iq))*.5                                !
>           cc2(iq)=cc(iq)*2./(1.+epst(iq))
>          enddo   ! iq loop                                               !
>          do iq=1,ifull                                                   !
>           pslx(iq,k)=pslx(iq,k)+dd(iq)
>          enddo    ! iq loop                                              !
>        endif      ! nritch.eq.104
> 
>        if(nritch.eq.105)then   ! Ritchie & Tanguay 1995 treatment 105
> !        uses averages of staggered calculations
>          call staguv(ubar(1,k),vbar(1,k),aa,bb)
>          do iq=1,ifull
> !         N.B. in depts:  ubar(iq,k)=ubar(iq,k)*dt *.5*em(iq)/ds       !
>           cc(iq)=.5*( aa(iq)*(dd(ie(iq))-dd(iq))
>      .                 +aa(iwu2(iq))*(dd(iq)-dd(iw(iq)))
>      .                 +bb(iq)*(dd(in(iq))-dd(iq))
>      .                 +bb(isv2(iq))*(dd(iq)-dd(is(iq))) )
>           cc2(iq)=cc(iq)
>           pslx(iq,k)=pslx(iq,k)+dd(iq)+cc(iq)*(1.-epst(iq))
>          enddo    ! iq loop                                              !
>        endif      ! nritch.eq.105
> 
135,138c276,279
< !      if(nritch.ge.404.and.ktau.eq.1)then  ! set in globpe now
< !	  nt_adv=nritch-400   ! for backward compatibility to nritch=407
< !	  print *,'resetting nritch,nt_adv,ktau ',nritch,nt_adv,ktau 
< !	endif
---
>        if(nritch.ge.404.and.ktau.eq.1)then
> 	  nt_adv=nritch-400   ! for backward compatibility to nritch=407
> 	  print *,'resetting nritch,nt_adv,ktau ',nritch,nt_adv,ktau 
> 	endif
165a307,313
> c        print *,'. idjd,zs ',idjd,(zs(iq),iq=idjd-1,idjd+1)
> c        print *,'- factr,aa,dd ',factr,(aa(iq),iq=idjd-il-1,idjd-il+1),
> c    .               (dd(iq),iq=idjd-il-1,idjd-il+1)
> c        print *,'. factr,aa,dd ',factr,(aa(iq),iq=idjd-1,idjd+1),
> c    .               (dd(iq),iq=idjd-1,idjd+1)
> c        print *,'+ factr,aa,dd ',factr,(aa(iq),iq=idjd+il-1,idjd+il+1),
> c    .               (dd(iq),iq=idjd+il-1,idjd+il+1)
168a317,325
> c        if(k.lt.9)then
> c          print 91,ktau,k,(tx(iq,k),iq=idjd-il-1,idjd-il+1),
> c    .               (cc(iq),iq=idjd-il-1,idjd-il+1)
> c          print 91,ktau,k,(tx(iq,k),iq=idjd-1,idjd+1),
> c    .               (cc(iq),iq=idjd-1,idjd+1)
> c          print 91,ktau,k,(tx(iq,k),iq=idjd+il-1,idjd+il+1),
> c    .               (cc(iq),iq=idjd+il-1,idjd+il+1)
> c91        format(2i2,' tx cc: ',3f6.1,3x,3f6.1)
> c        endif
172a330,337
> c        if(k.lt.9)then
> c          print 91,ktau,k,(tx(iq,k),iq=idjd-il-1,idjd-il+1),
> c    .               (cc(iq),iq=idjd-il-1,idjd-il+1)
> c          print 91,ktau,k,(tx(iq,k),iq=idjd-1,idjd+1),
> c    .               (cc(iq),iq=idjd-1,idjd+1)
> c          print 91,ktau,k,(tx(iq,k),iq=idjd+il-1,idjd+il+1),
> c    .               (cc(iq),iq=idjd+il-1,idjd+il+1)
> c        endif
179a345,346
> c       call printa('ux  ',ux(1,nlv),ktau,nlv,ia,ib,ja,jb,0.,1.)
> c       call printa('vx  ',vx(1,nlv),ktau,nlv,ia,ib,ja,jb,0.,1.)
182c349
<         call printa('uavx',ux(1,nlv),ktau,nlv,ia,ib,ja,jb,0.,1.)
---
>         call printa('uavx',ux(1,k),ktau,nlv,ia,ib,ja,jb,0.,1.)
184c351
<         call printa('vavx',vx(1,nlv),ktau,nlv,ia,ib,ja,jb,0.,1.)
---
>         call printa('vavx',vx(1,k),ktau,nlv,ia,ib,ja,jb,0.,1.)
195a363,365
>        if(mspec.eq.1.and.nhor.gt.0)then   ! don't use, especially with k loop
>          call hordifg(k)   ! note uc, vc, wc here updated
>        endif     ! (mspec.eq.1.and.nhor.gt.0)
197c367
<         print *,'uc,vc,wc before advection'
---
>         print *,'uc,vc,wc after hordif but before advection'
266,270c436,440
<         call ints(qg(1,k),intsch,nface(1,k),xg(1,k),yg(1,k),4)
<         if(ifullw.gt.1)then
<           call ints(qlg(1,k),intsch,nface(1,k),xg(1,k),yg(1,k),4)
<           call ints(qfg(1,k),intsch,nface(1,k),xg(1,k),yg(1,k),4)
<         endif     ! ifullw.gt.1
---
>            call ints(qg(1,k),intsch,nface(1,k),xg(1,k),yg(1,k),4)
>         if(ilw.gt.1)then
>           call ints(qc(1,k),intsch,nface(1,k),xg(1,k),yg(1,k),4)
>           call ints(qp(1,k),intsch,nface(1,k),xg(1,k),yg(1,k),4)
>         endif     ! ilw.gt.1
314a485,492
> c!         firstly the implicit Coriolis step giving (tau+.5) values
> c          tempux    =(ux(iq,k)+.5*dt*(1.+epsf)*f(iq)*vx(iq,k))/
> c     .                      (1.+(.5*dt*(1.+epsf)*f(iq))**2)
> c          tempvx    =(vx(iq,k)-.5*dt*(1.+epsf)*f(iq)*ux(iq,k))/
> c     .                      (1.+(.5*dt*(1.+epsf)*f(iq))**2)
> c!         then add the explicit Coriolis part (can add un, vn here; watch epsf)
> c          ux(iq,k)=tempux+.5*dt*((1.-epsf)*f(iq)*tempvx+un(iq,k))
> c          vx(iq,k)=tempvx-.5*dt*((1.-epsf)*f(iq)*tempux-vn(iq,k))
407a586,595
>        if(nuv.lt.10)then
>          do iq=1,ifull
> !         save in u,v the latest unstaggered ux,vx        globpea
> !         N.B. increments to be added at end of adjust5   globpea
>           u(iq,k)=ux(iq,k)
>           v(iq,k)=vx(iq,k)
>          enddo     ! iq loop
>        endif   !  (nuv.lt.10)
> 
> 
426c614,616
<       tx(:,:)=tx(:,:)+.5*dt*tn(:,:) ! moved from adjust5 30/11/00
---
>       do kq=1,ijk
>        tx(kq,1)=tx(kq,1)+.5*dt*tn(kq,1) ! moved from adjust5 30/11/00
>       enddo      ! kq loop
446a637,674
> 
> !       check for unstable layers from level 5 up; theta in xg array
> c       do k=1,kl
> c        do iq=1,ifull
> c         xg(iq,k)=tx(iq,k)*sig(k)**(-r/cp)
> c        enddo     ! iq loop
> c       enddo      !  k loop
> c       do k=5,kl
> c        do iq=1,ifull
> c         if(xg(iq,k).lt.xg(iq,k-1))then
> c          xg(iq,k)=(dsig(k-1)*xg(iq,k-1)+dsig(k)*xg(iq,k))/
> c    .                     (dsig(k-1)+dsig(k))      ! this is theta_bar
> c          tx(iq,k)=xg(iq,k)/(sig(k)**(-r/cp))
> c          tx(iq,k-1)=xg(iq,k)/(sig(k-1)**(-r/cp))
> c         endif
> c        enddo     ! iq loop
> c       enddo      !  k loop
> 
>       if(mfix.eq.-1)then   ! perform conservation fix on pslx
> !       delpos is the sum of all positive changes over globe
> !       delneg is the sum of all negative changes over globe
> !       alph_p is chosen to satisfy alph_p*delpos + delneg/alph_p = 0
>         delpos=0.
>         delneg=0.
>         do iq=1,ifull
>          do k=1,kl
>           wrk1(iq,k)=pslx(iq,k)-pslxsav(iq,k)  ! has increments
>           delpos=delpos+max(0.,-dsig(k)*wrk1(iq,k)/em(iq)**2)
>           delneg=delneg+min(0.,-dsig(k)*wrk1(iq,k)/em(iq)**2)
>          enddo   ! k loop
>         enddo    ! iq loop
>         alph_p = sqrt( -delneg/delpos)
>         alph_pm=1./alph_p
>         do kq=1,ijk
>          pslx(kq,1)=pslxsav(kq,1)+
>      .       alph_p*max(0.,wrk1(kq,1)) + alph_pm*min(0.,wrk1(kq,1))
>         enddo    ! kq loop
>       endif      !  mfix.eq.-1
=====================================
 
vadv30.f
=====================================
1,13c1,5
<       subroutine vadv30(tin,tout,uin,uout,vin,vout)   
< !     only calls vadvbess (nvad=7) from Aug 2003      
<       parameter (ntest=0) !  0: usual   1: for diagnostic prints
<       parameter (nvdep=7) !  0  for original;
< !                            1  for newer average vels
< !                            2  for newest jlm
< !                            3  for newest jlm (quadratic right at end)
< !                            4+ for new similar to that of depts3d
< !                              - only used in vadv30, vadvl_w (not vadvtvd)
<       parameter (nvint=2) !  0 simple+1/2; 1 simple;  **set in vadv30in also
< !                            2 for Bessel
< !                            3 for spline
< !                            7 for Akima
---
>       subroutine vadv30(tin,tout,uin,uout,vin,vout)   ! globpea  version
>       parameter (ntest=0)  ! 0: usual   1: for diagnostic prints
> !       nvint:   0 simple+1/2; 1 simple;  (nvint was called nbess)
> !                2 for Bessel; 3 for spline; 7 for Akima (was called 4)
> !       nvdep:   0 for original; 1 for new average vels
14a7,22
> !     for mixed schemes:
> !           nvad=54   TVD for u, v, qg
> !                     S-L     T
> !           nvad=55   TVD for T
> !                     S-L     u, v, qg
> !           nvad=56   TVD for T, qg
> !                     S-L     u, v
> !           nvad=57   TVD for qg
> !                     S-L     T, u, v
> !           nvad=58   TVD for T, u, v
> !                     S-L     qg
> !           nvad=59   TVD for u, v
> !                     S-L     T, qg
> 
> !           nvad=65   L-W for T
> !                     S-L     u, v, qg
20c28
<       include 'liqwpar.h'  ! ifullw
---
>       include 'liqwpar.h'
29,32c37,44
<       common/work3b/wrk1(ifull,kl),ders(ifull,kl)   ! just work arrays here
<       common/work3c/kdel(ifull,kl)
<       common/work3d/sd(ifull,kl)
<       common/work3f/st(ifull,kl),anew(ifull,kl),gwrk(ifull,kl)
---
>       common/work3/st(ifull,kl),anew(ifull,kl),gwrk(ifull,kl),
>      .             dum3(ifull,kl)           ! this dum used in upglobal
>       common/work3b/wrk1(ifull,kl),wrk2(ifull,kl)   ! just work arrays here
> c     common/sdotsav/sdotsav(ifull,kl) ! adjust5, updps, vadv30
> c     real sdotav(ifull,kl)       ! probably change back to sdot
> c     equivalence (sdotav,gwrk)
>       dimension kdel(ifull,kl)
>       equivalence (kdel,wrk2)
35,38c47,60
<       real bb(kl),sddk(0:kl+1)
<       real dersh(ifull,kl),sdotder(ifull,kl+1)
<       equivalence (dersh,gwrk),(sdotder,wrk1)
<       data sddk/kl2*0./
---
>       real bb(kl),sd(kl),sdd(0:kl+1)
>       integer nsign
>       data sdd/kl2*0./,nsign/1/
>       save nsign   ! -1,1, -1,1 and so on
> c     if(nvadh.eq.2)then
> c       nsign=-nsign      !  -1,1, -1,1 and so on
> c       if(nsign.lt.0)then
> c         tfact=.5*(1.-epsp)
> c       else
> c         tfact=.5*(1.+epsp)
> c       endif
> c     else       ! i.e. nvadh.ne.2
> c       tfact=1.
> c     endif      ! (nvadh.eq.2)
40,42d61
<       if(ktau.eq.1)then
<         print *,'in vadv30 nvdep,nvint: ',nvdep,nvint
<       endif
45c64,69
< c     & was converted in updps/adjust5 to units of grid-steps/timestep  (+ve upwards)
---
> c     & was converted in nonlin to units of grid-steps/timestep  (+ve upwards)
> 
> c     do kq=1,ijk     !**  watch out: need k+1 too!
> c      sdotav(kq,1)=.5*(sdotsav(kq,1)+sdot(kq,1)) ! Mon  07-06-1998
> c      sdotav(kq,1)=sdot(kq,1)                      ! regular scheme
> c     enddo    !  kq loop
48,50c72,74
<       if(nvdep.eq.1)then
< !       this method not so good if trajectory > 1/2 grid length
<         do iq=1,ifull
---
>       do iq=1,ifull
>        if(nvdep.eq.1)then
> !        this method not so good if trajectory > 1/2 grid length
56,59c80
<         enddo  ! iq loop
<       endif     ! (nvdep.eq.1)
<       if(nvdep.eq.0)then  ! original jlm method follows 
<         do iq=1,ifull
---
>        else      ! original jlm method follows (nvdep=0)
62c83
<           sd(iq,k)=(sdot(iq,k)+sdot(iq,k+1))*.5  ! linear at ends
---
>           sd(k)=(sdot(iq,k)+sdot(iq,k+1))*.5
66c87
<           sd(iq,k)=sd(iq,k)-(bb(k+1)-bb(k-1))/16.   ! interpolated sdot
---
>           sd(k)=sd(k)-(bb(k+1)-bb(k-1))/16.   ! interpolated sdot
71c92,95
<           sddk(k)=(sdot(iq,k+1)**2-sdot(iq,k)**2)/4.
---
> c         sdd(k)=(sdot(iq,k)*(sd(k)-sd(k-1))
> c    .           +sdot(iq,k+1)*(sd(k+1)-sd(k)))/4.
> c         an alternative formula for sdd follows
>           sdd(k)=(sdot(iq,k+1)**2-sdot(iq,k)**2)/4.
74,150c98,101
<           sddd=(sdot(iq,k)*(sddk(k)-sddk(k-1))
<      .         +sdot(iq,k+1)*(sddk(k+1)-sddk(k)))/6.  
<           st(iq,k)=k -tfact*(sd(iq,k) -tfact*(sddk(k) -tfact*sddd))
<          enddo   ! k loop
<         enddo  ! iq loop
<       endif   ! (nvdep.eq.0)
<        
<       if(nvdep.eq.2)then  !  jlm method in 2003
<         do iq=1,ifull
<          sd(iq,1) =.75*sdot(iq,2) -.125*sdot(iq,3)     ! quadratic at ends
<          sd(iq,kl)=.75*sdot(iq,kl)-.125*sdot(iq,kl-1)  ! quadratic at ends
<         enddo  ! iq loop
< c       interpolate sdot to full-level sd with cubic polynomials
<         do k=2,kl-1
<          do iq=1,ifull
<           sd(iq,k)=(9.*(sdot(iq,k)+sdot(iq,k+1))
<      .                 -sdot(iq,k-1)-sdot(iq,k+2))/16.   
<          enddo  ! iq loop
<         enddo   ! k loop
< c       build in 1/2 & 1/6 into sdd & sddd
<         do k=1,kl    ! sdd is kdot*(dkdot/dk)/2  or d(kdot**2)/dk /4
<          do iq=1,ifull
<           sdd=(sdot(iq,k+1)**2-sdot(iq,k)**2)/4.
< !	   sddd is kdot*(dsdd/dk)/3 or kdot*(d2(kdot**2)/dk2)/12
<           sddd=sd(iq,k)*(sdot(iq,k)**2-2.*sd(iq,k)**2+sdot(iq,k+1)**2)/3.
<           st(iq,k)=k -tfact*(sd(iq,k) -tfact*(sdd -tfact*sddd))
<          enddo  ! iq loop
<         enddo   ! k loop
<       endif   ! (nvdep.eq.2) 
<        
<       if(nvdep.eq.3)then  !  jlm method in 2003 - quadratic right at end
<         do iq=1,ifull
<          sd(iq,1) =.25*sdot(iq,2)     ! quadratic right at end
<          sd(iq,kl)=.25*sdot(iq,kl)    ! quadratic right at end
<         enddo  ! iq loop
< c       interpolate sdot to full-level sd with cubic polynomials
<         do k=2,kl-1
<          do iq=1,ifull
<           sd(iq,k)=(9.*(sdot(iq,k)+sdot(iq,k+1))
<      .                 -sdot(iq,k-1)-sdot(iq,k+2))/16.   
<          enddo  ! iq loop
<         enddo   ! k loop
< c       build in 1/2 & 1/6 into sdd & sddd
<         do k=1,kl    ! sdd is kdot*(dkdot/dk)/2  or d(kdot**2)/dk /4
<          do iq=1,ifull
<           sdd=(sdot(iq,k+1)**2-sdot(iq,k)**2)/4.
< !	   sddd is kdot*(dsdd/dk)/3 or kdot*(d2(kdot**2)/dk2)/12
<           sddd=sd(iq,k)*(sdot(iq,k)**2-2.*sd(iq,k)**2+sdot(iq,k+1)**2)/3.
<           st(iq,k)=k -tfact*(sd(iq,k) -tfact*(sdd -tfact*sddd))
<          enddo  ! iq loop
<         enddo   ! k loop
<       endif   ! (nvdep.eq.3) 
<        
<       if(nvdep.eq.4)then  !  newer method similar to depts3d - very poor
<         do iq=1,ifull
<          sd(iq,1) =.25*sdot(iq,2)     ! quadratic right at end
<          sd(iq,kl)=.25*sdot(iq,kl)    ! quadratic right at end
<         enddo  ! iq loop
< c       interpolate sdot to full-level sd with cubic polynomials
<         do k=2,kl-1
<          do iq=1,ifull
<           sd(iq,k)=(9.*(sdot(iq,k)+sdot(iq,k+1))
<      .                 -sdot(iq,k-1)-sdot(iq,k+2))/16.   
<          enddo    ! iq loop
<         enddo     ! k loop
< 	 ders=-tfact*sd  ! 3D
<         do k=1,kl    
<          do iq=1,ifull
<           st(iq,k)=k+ders(iq,k) 
<          enddo  ! iq loop
<         enddo   ! k loop
< 	 do itn=2,3
< c	 do itn=2,2  
<          do k=2,kl-1
<           do iq=1,ifull
<            wrk1(iq,k)=-.5*tfact*sd(iq,k)*(ders(iq,k+1)-ders(iq,k-1))/itn
<           enddo  ! iq loop
---
>           sddd=(sdot(iq,k)*(sdd(k)-sdd(k-1))
>      .         +sdot(iq,k+1)*(sdd(k+1)-sdd(k)))/6.  ! originally had 12.
> c         st(iq,k)=k-sd(k)+sdd(k)-sddd
>           st(iq,k)=k -tfact*(sd(k) -tfact*(sdd(k) -tfact*sddd))
152,331c103,104
<          do iq=1,ifull
< !         assume ders=0 off ends and varies quadratically to 1st level	
<           wrk1(iq,1)=-tfact*sd(iq,1)*4.*ders(iq,1)/itn
<           wrk1(iq,kl)=tfact*sd(iq,kl)*4.*ders(iq,kl)/itn
<          enddo  ! iq loop
<          ders=wrk1   ! 3D
<          st=st+ders  ! 3D
< 	 enddo  ! itn loop
<       endif    ! (nvdep.eq.4) 
<        
<       if(nvdep.eq.5)then  !  newer method similar to depts3d  itn=2
<         do iq=1,ifull
<          sd(iq,1) =.25*sdot(iq,2)     ! quadratic right at end
<          sd(iq,kl)=.25*sdot(iq,kl)    ! quadratic right at end
<         enddo  ! iq loop
< c       interpolate sdot to full-level sd with cubic polynomials
<         do k=2,kl-1
<          do iq=1,ifull
<           sd(iq,k)=(9.*(sdot(iq,k)+sdot(iq,k+1))
<      .                 -sdot(iq,k-1)-sdot(iq,k+2))/16.   
<          enddo    ! iq loop
<         enddo     ! k loop
< 	 ders=-tfact*sd  ! 3D
<         do k=1,kl    
<          do iq=1,ifull
<           st(iq,k)=k+ders(iq,k) 
<          enddo  ! iq loop
<         enddo   ! k loop
< 	 itn=2   ! spell it out as for nvdep=3
<          do k=1,kl
<           do iq=1,ifull
<            wrk1(iq,k)=.5*tfact*(sdot(iq,k+1)**2-sdot(iq,k)**2)/itn
<           enddo  ! iq loop
<          enddo   ! k loop
<          ders=wrk1   ! 3D
<          st=st+ders  ! 3D
<  	 itn=3
<          do k=2,kl-1
<           do iq=1,ifull
<            wrk1(iq,k)=-.5*tfact*sd(iq,k)*(ders(iq,k+1)-ders(iq,k-1))/itn
<           enddo  ! iq loop
<          enddo   ! k loop
<          do iq=1,ifull
< !         assume ders=0 off ends and varies quadratically to 1st level	
<           wrk1(iq,1)=-tfact*sd(iq,1)*4.*ders(iq,1)/itn
<           wrk1(iq,kl)=tfact*sd(iq,kl)*4.*ders(iq,kl)/itn
<          enddo  ! iq loop
<          ders=wrk1   ! 3D
<          st=st+ders  ! 3D
<       endif    ! (nvdep.eq.5) 
<        
<       if(nvdep.eq.6)then  !  newer method similar to depts3d  
<         do iq=1,ifull
<          sd(iq,1) =.25*sdot(iq,2)     ! quadratic right at end
<          sd(iq,kl)=.25*sdot(iq,kl)    ! quadratic right at end
<         enddo  ! iq loop
< c       interpolate sdot to full-level sd with cubic polynomials
<         do k=2,kl-1
<          do iq=1,ifull
<           sd(iq,k)=(9.*(sdot(iq,k)+sdot(iq,k+1))
<      .                 -sdot(iq,k-1)-sdot(iq,k+2))/16.   
<          enddo    ! iq loop
<         enddo     ! k loop
< 	 ders=-tfact*sd  ! 3D
<         do k=1,kl-1    
<          do iq=1,ifull
<           dersh(iq,k)=-tfact*sdot(iq,k+1) ! N.B. dersh(,0)=dersh(,kl)=0
<          enddo  ! iq loop
<         enddo   ! k loop
<         do k=1,kl    
<          do iq=1,ifull
<           st(iq,k)=k+ders(iq,k) 
<          enddo  ! iq loop
<         enddo   ! k loop
< 	 itn=2   ! spell it out 
<         do iq=1,ifull
<          wrk1(iq,1)=-tfact*sdot(iq,2)*(ders(iq,2)-ders(iq,1))/itn  ! new dersh
<          ders(iq,1)=-tfact*sd(iq,1)*dersh(iq,1)/itn    ! new ders
<         enddo  ! iq loop
<         do k=2,kl-1
<          do iq=1,ifull  ! for new dersh, ders
<           wrk1(iq,k)=-tfact*sdot(iq,k+1)*(ders(iq,k+1)-ders(iq,k))/itn  
<           ders(iq,k)=-tfact*sd(iq,k)*(dersh(iq,k)-dersh(iq,k-1))/itn  ! new ders
<          enddo  ! iq loop
<         enddo   ! k loop
<         do iq=1,ifull
<          ders(iq,kl)=tfact*sd(iq,kl)*dersh(iq,kl-1)/itn  ! new ders
<         enddo  ! iq loop
<         st=st+ders  ! 3D
<   	 itn=3
<         do iq=1,ifull
<          ders(iq,1)=-tfact*sd(iq,1)*wrk1(iq,k)/itn    ! new ders
<         enddo  ! iq loop
<         do k=2,kl-1
<          do iq=1,ifull
<           ders(iq,k)=-tfact*sd(iq,k)*(wrk1(iq,k)-wrk1(iq,k-1))/itn  ! new ders
<          enddo  ! iq loop
<         enddo   ! k loop
<         do iq=1,ifull
<          ders(iq,kl)=tfact*sd(iq,kl)*wrk1(iq,kl-1)/itn  ! new ders
<         enddo  ! iq loop
<         st=st+ders  ! 3D
<       endif    ! (nvdep.eq.6) 
<        
<       if(nvdep.eq.7)then  !  iterative
<         do iq=1,ifull
<          sd(iq,1) =.25*sdot(iq,2)     ! quadratic right at end
<          sd(iq,kl)=.25*sdot(iq,kl)    ! quadratic right at end
<          sdotder(iq,1)   =0.
<          sdotder(iq,kl+1)=0.
<         enddo  ! iq loop
< c       interpolate sdot to full-level sd with cubic polynomials
<         do k=2,kl-1
<          do iq=1,ifull
<           sd(iq,k)=(9.*(sdot(iq,k)+sdot(iq,k+1))
<      .                 -sdot(iq,k-1)-sdot(iq,k+2))/16.   
<          enddo  ! iq loop
<         enddo   ! k loop
<         do k=2,kl
<          do iq=1,ifull
<           sdotder(iq,k)=.5*(sdot(iq,k+1)-sdot(iq,k-1))
<          enddo  ! iq loop
<         enddo   ! k loop
<         do k=1,kl    
<          do iq=1,ifull
<           st(iq,k)=k -tfact*sd(iq,k)        ! 1st guess
<          enddo  ! iq loop
<         enddo   ! k loop
<         if(diag.or.ntest.eq.1)then
<           print *,'1st guess:  '
<           write (6,"('st  ',9f8.3/4x,9f8.3)") (st(idjd,kk),kk=1,kl)
<         endif
<         do k=1,kl    
<          do iq=1,ifull
< !	   following kdel and st apply to sdot interp
<           st(iq,k)=max(1.,min(st(iq,k)+.5,kl+1.))
<           kdel(iq,k)=max(1,min(int(st(iq,k)),kl))  ! 1 <= kdel <= kl
<           st(iq,k)=st(iq,k)-kdel(iq,k)             ! 0 <= st   <= 1.
<          enddo  ! iq loop
<          do iq=1,ifull  ! calculate upstream values of sdot
<           kk=kdel(iq,k)
<           gwrk(iq,k)=sdot(iq,kk)+st(iq,k)*(sdotder(iq,kk)
<      .                      +st(iq,k)*(3.*(sdot(iq,kk+1)-sdot(iq,kk))
<      .                               -2.*sdotder(iq,kk)-sdotder(iq,kk+1)
<      .                      +st(iq,k)*(2.*(sdot(iq,kk)-sdot(iq,kk+1))
<      .                              +sdotder(iq,kk)+sdotder(iq,kk+1) )))     
<          enddo  ! iq loop
<         enddo   ! k loop
<         do k=1,kl    
<          do iq=1,ifull
<           st(iq,k)=k -.5*tfact*(sd(iq,k)+gwrk(iq,k))        ! 2nd guess
<          enddo  ! iq loop
<         enddo   ! k loop
<         if(diag.or.ntest.eq.1)then
<           print *,'2nd guess:  '
<           write (6,"('st  ',9f8.3/4x,9f8.3)") (st(idjd,kk),kk=1,kl)
<         endif
<         do k=1,kl    
<          do iq=1,ifull
< !	   following kdel and st apply to sdot interp
<           st(iq,k)=max(1.,min(st(iq,k)+.5,kl+1.))
<           kdel(iq,k)=max(1,min(int(st(iq,k)),kl))  ! 1 <= kdel <= kl
<           st(iq,k)=st(iq,k)-kdel(iq,k)             ! 0 <= st   <= 1.
<          enddo  ! iq loop
<          do iq=1,ifull  ! calculate upstream values of sdot
<           kk=kdel(iq,k)
<           gwrk(iq,k)=sdot(iq,kk)+st(iq,k)*(sdotder(iq,kk)
<      .                      +st(iq,k)*(3.*(sdot(iq,kk+1)-sdot(iq,kk))
<      .                               -2.*sdotder(iq,kk)-sdotder(iq,kk+1)
<      .                      +st(iq,k)*(2.*(sdot(iq,kk)-sdot(iq,kk+1))
<      .                              +sdotder(iq,kk)+sdotder(iq,kk+1) )))     
<          enddo  ! iq loop
<         enddo   ! k loop
<         do k=1,kl    
<          do iq=1,ifull
<           st(iq,k)=k -.5*tfact*(sd(iq,k)+gwrk(iq,k))        ! 3rd guess
<          enddo  ! iq loop
<         enddo   ! k loop
<       endif   ! (nvdep.eq.7) 
<        
---
>        endif   ! (nvdep.eq.1) ... else ...
>       enddo  ! iq loop
335,336c108,109
<          write (6,"('sdot',9f8.3/4x,9f8.3)") (sdot(idjd,kk),kk=1,kl)
<          write (6,"('st  ',9f8.3/4x,9f8.3)") (st(idjd,kk),kk=1,kl)
---
>          print *,'sdot ',(sdot(idjd,k),k=1,kl+1)
>          print *,'dep. level ',(st(idjd,k),k=1,kl)
339,340c112
< !     here transform array st (i.e. nvad=7)
< !        this should do Bessell better, with zero gradient top & bottom      
---
> !     here transform array st
342,379c114,139
<          do iq=1,ifull
<              st(iq,k)=min( max(st(iq,k),1.) ,real(kl))  ! 1 <= st   <= kl
<              kdel(iq,k)=min(max(int(st(iq,k)),1),kl-1)  ! 1 <= kdel <= kl-1
<              st(iq,k)=st(iq,k)-kdel(iq,k)               ! 0 <= st   <= 1.
<          enddo  ! iq loop
<         enddo   ! k loop
<         if(diag.or.ntest.eq.1)then
<          write (6,"('Bess st',9f8.3/4x,9f8.3)") (st(idjd,kk),kk=1,kl)
<           print *,'new kdel ',(kdel(idjd,k),k=1,kl)
<         endif
<         call vadvbess(tin,tout,st,kdel,1)                          
<         call vadvbess(uin,uout,st,kdel,2)                          
<         call vadvbess(vin,vout,st,kdel,2)                          
<         call vadvbess(qg,qg,st,kdel,3)                          
<         if(ilt.gt.1)then
<           do ntr=1,ntrac
<            call vadvbess(tr(1,1,ntr),tr(1,1,ntr),st,kdel,3)           ! tr next
<           enddo
<         endif   ! (ilt.gt.1)
< 	 return
<       end
< 
< c     this one also returns t, u, v, q -  but tendencies formed in vadv30
< !     watch out for replacing qg in place!
<       subroutine vadvbess(t,tout,st,kdel,ifield)
<       parameter (ntopp=1)  ! 1 for 1-sided gradient at top & bottom full-levels
< c                          ! 2 for zero gradient at top & bottom full-levels
<       include 'newmpar.h'
<       include 'parm.h'
<       include 'parmvert.h'
<       include 'sigs.h'
<       real t(ifull,kl),tout(ifull,kl),st(ifull,kl)
<       dimension kdel(ifull,kl)
<       common/work3/tgrad(ifull,kl),toutt(ifull,kl),dum(3*ijk)
< c     st() is the sigma displacement array
<       if(ktau.eq.1)then
<         print *,'in vadvbess with ntopp = ',ntopp
<       endif
---
>          if(nvint.eq.1.or.nvint.eq.2)then  ! simple or Bessel; no top extrap.
>            do iq=1,ifull
>              st(iq,k)=min( max(st(iq,k),1.) ,real(kl))
>              kdel(iq,k)=min(kl-1,max(int(st(iq,k)),1))
>              st(iq,k)=st(iq,k)-kdel(iq,k)
>             enddo  ! iq loop
>          elseif(nvint.eq.3)then   ! for spline method
>            do iq=1,ifull
>              st(iq,k)=min( max(st(iq,k),.5) ,real(kl))
>              kdel(iq,k)=min(kl,max(int(st(iq,k)),0))
>              st(iq,k)=st(iq,k)-kdel(iq,k)
>             enddo  ! iq loop
>          elseif(nvint.eq.7)then   ! for Akima with top extrap allowed
>            do iq=1,ifull
>              st(iq,k)=min( max(st(iq,k),.5) ,real(kl)+.5)
>              kdel(iq,k)=min(kl,max(int(st(iq,k)),0))
>              st(iq,k)=st(iq,k)-kdel(iq,k)
>             enddo  ! iq loop
>          else      ! i.e. simple nvint=0 with top extrap allowed
>            do iq=1,ifull
>              st(iq,k)=min( max(st(iq,k),.5) ,real(kl)+.5)
>              kdel(iq,k)=min(kl-1,max(int(st(iq,k)),1))
>              st(iq,k)=st(iq,k)-kdel(iq,k)
>             enddo  ! iq loop
>          endif     !  (nvint.eq.2)then   else  ..
>         enddo ! k loop
381,413c141,147
<       if(ntopp.eq.1)then  ! 1-sided
<         do iq=1,ifull
<          tgrad(iq,1)=t(iq,2)-t(iq,1)
<          tgrad(iq,kl)=t(iq,kl)-t(iq,kl-1)
<         enddo
<       endif  ! (ntopp.eq.2)
<       if(ntopp.eq.2)then
<         do iq=1,ifull
<          tgrad(iq,1)=0.
<          tgrad(iq,kl)=0.
<         enddo
<       endif  ! (ntopp.eq.2)
< 
<       do k=2,kl-1
<        do iq=1,ifull
<         tgrad(iq,k)=.5*(t(iq,k+1)-t(iq,k-1))
<        enddo   ! iq loop
<       enddo    ! k loop
< 
<       do k=1,kl
<        do iq=1,ifull
<         kk=kdel(iq,k)
<         toutt(iq,k)=t(iq,kk)+st(iq,k)*(tgrad(iq,kk)
<      .                      +st(iq,k)*(3.*(t(iq,kk+1)-t(iq,kk))
<      .                                 -2.*tgrad(iq,kk)-tgrad(iq,kk+1)
<      .                      +st(iq,k)*(2.*(t(iq,kk)-t(iq,kk+1))
<      .                                 +tgrad(iq,kk)+tgrad(iq,kk+1) )))     
<        enddo
<       enddo
<       if(diag)then
<         print *,'t in  ',(t(idjd,k),k=1,kl)
<         print *,'tgrad ',(tgrad(idjd,k),k=1,kl)
<         print *,'toutt ',(toutt(idjd,k),k=1,kl)
---
>       if(diag.or.ntest.eq.1)then
>         print *,'kdel ',(kdel(idjd,k),k=1,kl)
>         print *,'st ',(st(idjd,k),k=1,kl)
>         print *,'t col ',(tin(idjd,k),k=1,kl)
>         print *,'u col ',(uin(idjd,k),k=1,kl)
>         print *,'v col ',(vin(idjd,k),k=1,kl)
>         print *,'qg col ',(qg(idjd,k),k=1,kl)
416,421c150,223
< !     can impose non-negative constraint here
<       if(ifield.eq.3)then
<         tout=max(toutt,0.)
<       else
<         tout=toutt
<       endif
---
>       if(nvad.ne.55.and.nvad.ne.56.and.nvad.ne.58.and.nvad.ne.65)then
> !      will do TVD for T for  nvad=55,56,58
> !      will do L-W for T for  nvad=65
>        if(nvint.eq.3)then
>          call vadsplin(tin,anew,st,kdel,wrk1,gwrk,1)  ! anew for diags below
>        elseif(nvint.eq.7)then
>          call vadvakim(tin,anew,st,kdel,wrk1,gwrk,1) ! anew for diags below
>        else
>          do kq=1,ijk
>           anew(kq,1)=tin(kq,1)
>          enddo    !  kq loop
>          call vadv30in(anew,st,kdel,1)                            ! T first
>        endif     !     nvint.eq.3  .. else ..
>        do kq=1,ijk
>         tout(kq,1)=anew(kq,1)
>        enddo   !  kq loop
>        if(diag.or.ntest.eq.1)then
>          print *,'tout ',(tout(idjd,k),k=1,kl)
>        endif
>       endif      ! (nvad.ne.55.and.nvad.ne.56.and.nvad.ne.58)
> 
>       if(nvad.ne.54.and.nvad.ne.58.and.nvad.ne.59)then
> !      will do TVD for u,v for nvad=54,58,59
>        if(nvint.eq.3)then
>          call vadsplin(uin,uout,st,kdel,wrk1,gwrk,2)
>          call vadsplin(vin,vout,st,kdel,wrk1,gwrk,2)
>        elseif(nvint.eq.7)then
>          call vadvakim(uin,uout,st,kdel,wrk1,gwrk,2)
>          call vadvakim(vin,vout,st,kdel,wrk1,gwrk,2)
>        else
>          do kq=1,ijk
>           anew(kq,1)=uin(kq,1)
>          enddo    !  kq loop
>          call vadv30in(anew,st,kdel,2)                            ! u next
>          do kq=1,ijk
>           uout(kq,1)=anew(kq,1)
>           anew(kq,1)=vin(kq,1)
>          enddo    !  kq loop
>          call vadv30in(anew,st,kdel,2)                            ! v next
>          do kq=1,ijk
>           vout(kq,1)=anew(kq,1)
>          enddo  !  kq loop
>        endif    !(nvint.eq.3) .. else
>        if(diag.or.ntest.eq.1)then
>          print *,'uout ',(uout(idjd,k),k=1,kl)
>          print *,'vout ',(vout(idjd,k),k=1,kl)
>        endif
>       endif     ! (nvad.ne.54.and.nvad.ne.58.and.nvad.ne.59)
> 
>       if(nvad.ne.54.and.nvad.ne.56.and.nvad.ne.57)then
> !       will do TVD for qg for  nvad=54,56,57
>         if(mspec.eq.1)then   ! advect qg after preliminary step
>          if(nvint.eq.3)then
>            call vadsplin(qg,qg,st,kdel,wrk1,gwrk,3)
>          elseif(nvint.eq.7)then
>            call vadvakim(qg,anew,st,kdel,wrk1,gwrk,3)
>            do kq=1,ijk
>             qg(kq,1)=anew(kq,1)
>            enddo
>          else
>            call vadv30in(qg,st,kdel,3)                            ! qg next
>            if(ilw.gt.1)stop 'call vadvrain'
>            if(ilt.gt.1)then
>              do ntr=1,ntrac
> c             print *,'calling vadv30in for ntr = ',ntr
>               call vadv30in(tr(1,1,ntr),st,kdel,3)              ! tr next
>              enddo
>            endif
>          endif  !   nvint.eq.3  .. else ..
>          if(diag.or.ntest.eq.1)then
>            print *,'qgout ',(qg(idjd,k),k=1,kl)
>          endif
>         endif   !   (mspec.eq.1)
>       endif     ! (nvad.ne.54.and.nvad.ne.56.and.nvad.ne.57)
423,425d224
<       if(diag)then
<         print *,'tout  ',(tout (idjd,k),k=1,kl)
<       endif
=====================================
 
vadvtvd.f
=====================================
4a5,7
> !       nqq:     0 for simple qg; 2 for k**3 treatment; 4 for qg**(1/4)
> !                7 for old nqq=3 (up to July '98)
> !     This is vector version,with sdotfilt>0 removed    [not yet done for qg]
20c23
<       include 'liqwpar.h'  ! ifullw
---
>       include 'liqwpar.h'
24c27
<       include 'parmvert.h' ! nthub,nimp,ntvd
---
>       include 'parmvert.h' ! nqq,nthub,nimp,ntvd,[n_bs,ntop,nvdep,nvint]
28c31
< c     common/work2/aa(ifull),dum2(ifull,17) 
---
>       common/work2/aa(ifull),dum2(ifull,17) 
31c34
<      .             dum3(3*ijk-2*ifull)
---
>      .             dum3(2*ijk-2*ifull)
56,57c59,60
<         print *,'In vadvtvd nvad,nvadh,nimp,nthub,ntvd,tfact ',
<      .                      nvad,nvadh,nimp,nthub,ntvd,tfact
---
>         print *,'In vadvtvd nvad,nvadh,nqq,nimp,nthub,ntvd,tfact ',
>      .                      nvad,nvadh,nqq,nimp,nthub,ntvd,tfact
108d110
< !        N.B. nimp=1 gives especially silly results if sdot>1	 
198c200,251
< c     qg
---
> c       qg
>         if(nqq.eq.2)then
>           do k=1,kl
>            do iq=1,ifull
>             qg(iq,k)=qg(iq,k)*k**3
> !           uav is sdot at level k
>             uav(iq,k)=.5*tfact*(sdot(iq,k+1)+sdot(iq,k))
>             udiff(iq,k)= tfact*(sdot(iq,k+1)-sdot(iq,k))
>            enddo    ! iq loop
>           enddo     ! k loop
>         endif       ! (nqq.eq.2)
>         if(nqq.eq.6)then
>           do k=1,kl
>            do iq=1,ifull
>             qg(iq,k)=qg(iq,k)/(1.-k/(kl+.5))**3
> !           uav is sdot at level k
>             uav(iq,k)=.5*tfact*(sdot(iq,k+1)+sdot(iq,k))
>             udiff(iq,k)= tfact*(sdot(iq,k+1)-sdot(iq,k))
>            enddo    ! iq loop
>           enddo     ! k loop
>         endif       ! (nqq.eq.6)
>         if(nqq.eq.7)then
>           do k=1,kl
>            do iq=1,ifull
>             qg(iq,k)=qg(iq,k)/sig3(k)
> !           uav is sdot at level k
>             uav(iq,k)=.5*tfact*(sdot(iq,k+1)+sdot(iq,k))
>             udiff(iq,k)= tfact*(sdot(iq,k+1)-sdot(iq,k))
>            enddo    ! iq loop
>           enddo     ! k loop
>         endif       ! (nqq.eq.7)
>         if(nqq.eq.2.or.nqq.eq.6.or.nqq.eq.7)then
>           do k=2,kl-1
>            do iq=1,ifull
> !          uav is sdot at level k
>            uav(iq,k)=uav(iq,k)
>      .                 -(udiff(iq,k+1)-udiff(iq,k-1))/16.
>            enddo    ! iq loop
>           enddo     ! k loop
>         endif  ! (nqq.eq.2.or.nqq.eq.6.or.nqq.eq.7)
>         if(nqq.eq.3)then
>           do kq=1,ijk
> !          qg(kq,1)=cbrt(qg(kq,1))
>            qg(kq,1)=qg(kq,1)**(1./3.)
>           enddo     ! kq loop
>         endif       ! (nqq.eq.3)
>         if(nqq.eq.4)then
>           do kq=1,ijk
>            qg(kq,1)=sqrt(sqrt(qg(kq,1)))
>           enddo     ! kq loop
>         endif       ! (nqq.eq.4)
> 
262,341c315,359
<       if(ifullw.gt.1)then
<        do k=1,kl-1       ! qlg first
<         do iq=1,ifull
<           delt(iq,k)=qlg(iq,k+1)-qlg(iq,k)
<         enddo    ! iq loop
<        enddo     ! k loop
<        do iq=1,ifull
<         delt(iq,0)=min(delt(iq,1),qlg(iq,1))       ! for non-negative tt
<        enddo    ! iq loop
<        do k=1,kl-1  ! for fluxh at interior (k + 1/2)  half-levels
<         do iq=1,ifull
<          kp=sign(1.,sdot(iq,k+1))
<          kx=k+(1-kp)/2  !  k for sdot +ve,  k+1 for sdot -ve
<          rat=delt(iq,k-kp)/(delt(iq,k)+sign(1.e-20,delt(iq,k)))
<          if(ntvd.eq.1)phi=(rat+abs(rat))/(1.+abs(rat))       ! 0 for -ve rat
<          if(ntvd.eq.2)phi=max(0.,min(2.*rat,.5+.5*rat,2.))   ! 0 for -ve rat
<          if(ntvd.eq.3)phi=max(0.,min(1.,2.*rat),min(2.,rat)) ! 0 for -ve rat
<          if(nthub.eq.1)fluxhi=.5*(qlg(iq,k)+qlg(iq,k+1))
<          if(nthub.eq.2)then     ! higher order scheme
<            fluxhi=.5*(qlg(iq,k)+qlg(iq,k+1)
<      .                   -delt(iq,k)*tfact*sdot(iq,k))
<          endif  ! (nthub.eq.2)
<          fluxlo=qlg(iq,kx)
<          fluxh(iq,k)=sdot(iq,k+1)*(fluxlo+phi*(fluxhi-fluxlo))
<         enddo    ! iq loop
<        enddo     ! k loop
<        do k=1,kl
<         do iq=1,ifull
<          if(nimp.eq.1)then
<           hdsdot=.5*tfact*(sdot(iq,k+1)-sdot(iq,k))
<           qlg(iq,k)=(qlg(iq,k)
<      .                +tfact*(fluxh(iq,k-1)-fluxh(iq,k))
<      .                +hdsdot*qlg(iq,k) )/(1.-hdsdot)
<          else
<           qlg(iq,k)=qlg(iq,k)
<      .                +tfact*(fluxh(iq,k-1)-fluxh(iq,k)
<      .                +qlg(iq,k)*(sdot(iq,k+1)-sdot(iq,k)))
<          endif   ! (nimp.eq.1)
<         enddo     ! iq loop
<        enddo      ! k loop
<        do k=1,kl-1       ! qfg next
<         do iq=1,ifull
<           delt(iq,k)=qfg(iq,k+1)-qfg(iq,k)
<         enddo    ! iq loop
<        enddo     ! k loop
<        do iq=1,ifull
<         delt(iq,0)=min(delt(iq,1),qfg(iq,1))       ! for non-negative tt
<        enddo    ! iq loop
<        do k=1,kl-1  ! for fluxh at interior (k + 1/2)  half-levels
<         do iq=1,ifull
<          kp=sign(1.,sdot(iq,k+1))
<          kx=k+(1-kp)/2  !  k for sdot +ve,  k+1 for sdot -ve
<          rat=delt(iq,k-kp)/(delt(iq,k)+sign(1.e-20,delt(iq,k)))
<          if(ntvd.eq.1)phi=(rat+abs(rat))/(1.+abs(rat))       ! 0 for -ve rat
<          if(ntvd.eq.2)phi=max(0.,min(2.*rat,.5+.5*rat,2.))   ! 0 for -ve rat
<          if(ntvd.eq.3)phi=max(0.,min(1.,2.*rat),min(2.,rat)) ! 0 for -ve rat
<          if(nthub.eq.1)fluxhi=.5*(qfg(iq,k)+qfg(iq,k+1))
<          if(nthub.eq.2)then     ! higher order scheme
<            fluxhi=.5*(qfg(iq,k)+qfg(iq,k+1)
<      .                   -delt(iq,k)*tfact*sdot(iq,k))
<          endif  ! (nthub.eq.2)
<          fluxlo=qfg(iq,kx)
<          fluxh(iq,k)=sdot(iq,k+1)*(fluxlo+phi*(fluxhi-fluxlo))
<         enddo    ! iq loop
<        enddo     ! k loop
<        do k=1,kl
<         do iq=1,ifull
<          if(nimp.eq.1)then
<           hdsdot=.5*tfact*(sdot(iq,k+1)-sdot(iq,k))
<           qfg(iq,k)=(qfg(iq,k)
<      .                +tfact*(fluxh(iq,k-1)-fluxh(iq,k))
<      .                +hdsdot*qfg(iq,k) )/(1.-hdsdot)
<          else
<           qfg(iq,k)=qfg(iq,k)
<      .                +tfact*(fluxh(iq,k-1)-fluxh(iq,k)
<      .                +qfg(iq,k)*(sdot(iq,k+1)-sdot(iq,k)))
<          endif   ! (nimp.eq.1)
<         enddo     ! iq loop
<        enddo      ! k loop
<       endif      ! if(ifullw.gt.1)
---
> !       if(ntvd_av.ne.0)then              ! this option does nothing
> !         do k=1,kl
> !          do iq=1,ifull
> !           qg(iq,k)=qg(iq,k)+avg(iq)
> !          enddo    ! iq loop
> !         enddo     ! k loop 
> !       endif   ! (ntvd_av.ne.0)
>         if(nqq.eq.2)then
>           do k=1,kl
>            do iq=1,ifull
>             qg(iq,k)=qg(iq,k)*
>      .                 (k+1.5*uav(iq,k))/(k*k*k*(k-1.5*uav(iq,k)))
>            enddo    ! iq loop
>           enddo     ! k loop
>         endif       ! (nqq.eq.2)
>         if(nqq.eq.3)then
>           do kq=1,ijk
>            qg(kq,1)=qg(kq,1)**3
>           enddo     ! kq loop
>         endif       ! (nqq.eq.3)
>         if(nqq.eq.4)then
>           do kq=1,ijk
>            qg(kq,1)=qg(kq,1)**4
>           enddo     ! kq loop
>         endif       ! (nqq.eq.4)
>         if(nqq.eq.6)then
>           do k=1,kl
>            do iq=1,ifull
>             qg(iq,k)=qg(iq,k)*(1.-k/(kl+.5))**3
>      .            *(kl-k+.5+1.5*uav(iq,k))/(kl-k+.5-1.5*uav(iq,k))
>            enddo    ! iq loop
>           enddo     ! k loop
>         endif       ! (nqq.eq.6)
>         if(nqq.eq.7)then   ! used to be called nqq=3
>           do k=1,kl
>            do iq=1,ifull
> c           N.B. real sdot is uav*dsig(k)/dt
> c           so factor of (sig - 1.5*sdot*dt )/(sig + 1.5*sdot*dt )
> c           becomes      (sig - 1.5*uav(iq,*dsig)/(sig + 1.5*uav(iq,*dsig)
>             qg(iq,k)=qg(iq,k)*sig3(k)
>      .                 *(sig(k)-1.5*uav(iq,k)*dsig(k))/
>      .                  (sig(k)+1.5*uav(iq,k)*dsig(k))
>            enddo    ! iq loop
>           enddo     ! k loop
>         endif       ! (nqq.eq.7)
344a363,365
>       do iq=1,ifull
>        delt(iq,0)=min(delt(iq,1),tr(iq,1,ntr))       ! for non-negative tt
>       enddo    ! iq loop
350,352d370
<       do iq=1,ifull
<        delt(iq,0)=min(delt(iq,1),tr(iq,1,ntr))       ! for non-negative tt
<       enddo    ! iq loop
387a406,857
> 
>       return
>       end
> 
>       subroutine vadvl_w(tin,tout,uin,uout,vin,vout)   ! globpea  version
> c     split vertical advection routine; Lax-Wendroff scheme;
> c     called from nonlin for nvad=8
> c     applies increments to tn etc
> !       nqq:     0 for simple qg; 2 for k**3 treatment; 4 for qg**(1/4)
> !                                 5 for sig**3 interp only
> !     parameter (n_bs=0)   ! 1 for limiter on top level u,v,t
> !                            2 for 3-pt limiter on all levels u,v,t,qg
> !                            3 for limiter on just all half-levels u,v,t,qg =0
> !                            4 for directional limiter on all levels u,v,t,qg
> !                            5 for directional SY limiter on all levels u,v,t,qg
> !                            6 for integrated 2-way correction
> !                            7 for 5 then 6
> !                            8 for Nair Cote Staniforth (NCS)
> !     parameter (ntop=2)   ! 1 enforces zero deriv & no change at top
> !                            2,3 zero top u,v,qg
> !                            4 zero top u,v,qg, but t like Matsuno
> !                            5 zero top u,v,qg, but t from 'flux'
> !     parameter (nvdep=1)  ! 0 for simple vel av; 1 for higher order vel av
>       parameter (ngadd=1)  ! 0 for simple L_W; 1 for Gadd
>       parameter (nhalf=1)  ! 0 for simple T av; 1 ratha & rathb av
>       include 'newmpar.h'
>       include 'arrays.h'
>       include 'map.h'
>       include 'nlin.h'
>       include 'parm.h'
>       include 'parmdyn.h'
>       include 'parmvert.h'
>       include 'sigs.h'
>       include 'tracers.h'
>       include 'vvel.h'
>       real tin(ifull,kl),tout(ifull,kl),uin(ifull,kl),uout(ifull,kl),
>      .     vin(ifull,kl),vout(ifull,kl)
>       real a(kl),ap(-1:kl+1),agadd(kl),sig3(kl),rathqa(kl),rathqb(kl)
>       real anew(kl),up(0:kl),uav(kl),udiff(kl)
>       dimension ka(kl),kb(kl),kaa(kl),kbb(kl),kaaa(kl),kbbb(kl)
>       integer num,nsign
>       data num/0/,nsign/1/
>       save num,nsign   ! -1,1, -1,1 and so on
> 
> c     if(nvadh.eq.2)then
> c       nsign=-nsign      !  -1,1, -1,1 and so on
> c       if(nsign.lt.0)then
> c         tfact=.5*(1.-epsp)
> c       else
> c        tfact=.5*(1.+epsp)
> c       endif
> c     else       ! i.e. nvadh.ne.2
> c       tfact=1.
> c     endif
>       tfact=1./nvadh   ! simpler alternative
>       if(num.eq.0)then
>         print *,'nvad,nvadh,ngadd,nvdep,nhalf,ntop,nqq,n_bs,tfact ',
>      .           nvad,nvadh,ngadd,nvdep,nhalf,ntop,nqq,n_bs,tfact
>         num=1
>       endif
> 
> c     note sdot coming through is at level k-.5 
> c     converted in nonlin to units of grid-steps/timestep,  +ve upwards
>       up(0)=0.      ! i.e. sdot(1/2)
>       up(kl)=0.     ! i.e. sdot(kl + 1/2)
>       agadd(1)=0.   ! simple L_W for k=1
>       agadd(kl)=0.  ! simple L_W for k=kl
>       do k=1,kl
>        sig3(k)=sig(k)**3
>       enddo     ! k loop
>       do k=1,kl-1
>        rathqa(k)=ratha(k)*(sigmh(k+1)/sig(k+1))**3
>        rathqb(k)=rathb(k)*(sigmh(k+1)/sig(k  ))**3
>       enddo     ! k loop
>       ka(kl)=kl
>       kaa(kl)=kl
>       kaaa(kl)=kl
>       kb(kl)=kl-1
>       kbb(kl)=kl-2
>       kbbb(kl)=kl-3
>       ka(1)=2
>       kaa(1)=3
>       kaaa(1)=4
>       kb(1)=1
>       kbb(1)=1
>       kbbb(1)=1
> 
>       do iq=1,ifull   ! this is a very long loop
> c      print *,'iq in vadvl_w ',iq
>        do k=1,kl-1
>         up(k)= tfact*sdot(iq,k+1)  ! i.e. sdot(k + 1/2)
>        enddo     ! k loop
>        do k=1,kl
>         uav(k)=.5*(up(k)+up(k-1))                    ! i.e. sdot(k)
>         udiff(k)=  up(k)-up(k-1)
>        enddo     ! k loop
>        if(nvdep.eq.1)then
>          do k=2,kl-1
>           uav(k)=uav(k)-(udiff(k+1)-udiff(k-1))/16.  ! i.e. sdot(k)
>          enddo     ! k loop
>        endif   ! (nvdep.eq.1)
>        uav(kl)=max(uav(kl),0.)  ! zero gradient condition for down-flow at kl
>        if(ngadd.eq.1)then
>          do k=2,kl-1
>           agadd(k)=.75*(1.-uav(k)**2)
>          enddo     ! k loop
>        endif   ! (ngadd.eq.1)
>        if(n_bs.ge.4)then
>          do k=2,kl-1
>           if(uav(k).gt.0.)then
>             ka(k)=k
>             kaa(k) =min(k+1,kl)
>             kaaa(k)=min(k+2,kl)
>             kb(k)  =max(k-1,1)
>             kbb(k) =max(k-2,1)
>             kbbb(k)=max(k-3,1)
>           else
>             ka(k)  =min(k+1,kl)
>             kaa(k) =min(k+2,kl)
>             kaaa(k)=min(k+3,kl)
>             kb(k)=k
>             kbb(k) =max(k-1,1)
>             kbbb(k)=max(k-2,1)
>           endif
>          enddo     ! k loop
>        endif   ! (n_bs.ge.4)
> 
>        if(nvad.eq.10)go to 880     ! in vadvl_w
>        if(nvad.eq.65)go to 885     ! doing just T in vadvl_w
> 
> c      u
>        do k=1,kl
>         a(k)=uin(iq,k)
>        enddo     ! k loop
>        ap(0)=0.
>        do k=1,kl-1
>         if(nhalf.eq.0)ap(k)=.5*( a(k+1)+a(k) -up(k)*(a(k+1)-a(k)) )
>         if(nhalf.eq.1)ap(k)=ratha(k)*a(k+1)+rathb(k)*a(k)
>      .                       -.5*up(k)*(a(k+1)-a(k))
>         if(n_bs.eq.3)ap(k)=
>      .        min( max(min(a(k),a(k+1)) , ap(k)) , max(a(k),a(k+1)) )
>        enddo     ! k loop
>        ap(kl)=a(kl)
>        if(ntop.eq.1)ap(kl)=ap(kl-1)
>        if(ntop.ge.2)ap(kl)=0.
>        do k=1,kl
>         if(ngadd.eq.0)tincr= -uav(k)*(ap(k)-ap(k-1))              ! simple L_W
>         if(ngadd.eq.1)tincr= -uav(k)*( (1.+agadd(k))*(ap(k)-ap(k-1))    ! Gadd
>      .                                -agadd(k)*(ap(k+1)-ap(k-2))/3. )  ! Gadd
>         anew(k)=a(k)+tincr
>         if(n_bs.eq.2)then   ! limiter for all levels
>           kp=min(k+1,kl)
>           km=max(k-1,1)
>           anew(k)=min( max(min(a(km),a(k),a(kp)),anew(k)) ,
>      .              max(a(km),a(k),a(kp)) )
>         endif     !  (n_bs.eq.2)
>         if(n_bs.eq.4)then   ! directional limiter for all levels u
>           anew(k)=min( max(min( a(ka(k)) , a(kb(k)) ),anew(k)) ,
>      .              max( a(ka(k)) , a(kb(k)) ) )
>         endif     !  (n_bs.eq.4)
>         if(n_bs.eq.5.or.n_bs.eq.7)then ! directional SY limiter for all levels u
>           if((a(kaa(k))-a(ka(k)))*(a(kb(k))-a(kbb(k))).ge.0.)then
>             anew(k)=min( max(min( a(ka(k)) , a(kb(k)) ),anew(k)) ,
>      .                max( a(ka(k)) , a(kb(k)) ) )
>           endif
>         endif     !  (n_bs.eq.5.or.n_bs.eq.7)
>         if(n_bs.eq.8)then ! directional NCS limiter for all levels u
>           if( (a(kaa(k))-a(ka(k)))*(a(kaaa(k))-a(kaa(k))).lt.0.
>      .    .or.(a(kb(k))-a(kbb(k)))*(a(kbb(k))-a(kbbb(k))).lt.0.
>      .    .or.(a(kaa(k))-a(ka(k)))*(a(kb(k))-a(kbb(k))).ge.0.)then
>             anew(k)=min( max(min( a(ka(k)) , a(kb(k)) ),anew(k)) ,
>      .                max( a(ka(k)) , a(kb(k)) ) )
>           endif
>         endif     !  (n_bs.eq.8)
>        enddo  ! k loop
>        if(n_bs.eq.1)then   ! limiter for top level u
>          anew(kl)=min( max(min(a(kl-1),a(kl)),anew(kl)) ,
>      .                     max(a(kl-1),a(kl)) )
>        endif     !  (n_bs.eq.1)
>        if(n_bs.eq.6.or.n_bs.eq.7)then   ! columnwise integral constraint
>          sumsrc=0.
>          delpos=0.
>          delneg=0.
>          do k=1,kl
>           sumsrc=sumsrc-a(k)*(up(k)-up(k-1))*dsig(k)   ! use all -dsig
>           delpos=delpos+max(0., -dsig(k)*(anew(k)-a(k)) )
>           delneg=delneg+min(0., -dsig(k)*(anew(k)-a(k)) )
>          enddo
>          eps=(sumsrc-delpos-delneg)/max(1.e-6,delpos-delneg)
>          do k=1,kl
>           anew(k)=a(k) +(1.+eps)*max(0.,anew(k)-a(k))
>      .                 +(1.-eps)*min(0.,anew(k)-a(k))
>          enddo
>        endif     !  (n_bs.eq.6.or.n_bs.eq.7)
>        do k=1,kl
>         uout(iq,k)=anew(k)
>        enddo
> 
> c     v
>        do k=1,kl
>         a(k)=vin(iq,k)
>        enddo     ! k loop
>        ap(0)=0.
>        do k=1,kl-1
>         if(nhalf.eq.0)ap(k)=.5*( a(k+1)+a(k) -up(k)*(a(k+1)-a(k)) )
>         if(nhalf.eq.1)ap(k)=ratha(k)*a(k+1)+rathb(k)*a(k)
>      .                       -.5*up(k)*(a(k+1)-a(k))
>         if(n_bs.eq.3)ap(k)=
>      .        min( max(min(a(k),a(k+1)) , ap(k)) , max(a(k),a(k+1)) )
>        enddo     ! k loop
>        ap(kl)=a(kl)
>        if(ntop.eq.1)ap(kl)=ap(kl-1)
>        if(ntop.ge.2)ap(kl)=0.
>        do k=1,kl
>         if(ngadd.eq.0)tincr= -uav(k)*(ap(k)-ap(k-1))              ! simple L_W
>         if(ngadd.eq.1)tincr= -uav(k)*( (1.+agadd(k))*(ap(k)-ap(k-1))    ! Gadd
>      .                                -agadd(k)*(ap(k+1)-ap(k-2))/3. )  ! Gadd
>         anew(k)=a(k)+tincr
>         if(n_bs.eq.2)then   ! limiter for all levels
>           kp=min(k+1,kl)
>           km=max(k-1,1)
>           anew(k)=min( max(min(a(km),a(k),a(kp)),anew(k)) ,
>      .              max(a(km),a(k),a(kp)) )
>         endif     !  (n_bs.eq.2)
>         if(n_bs.eq.4)then ! directional limiter for all levels u
>           anew(k)=min( max(min( a(ka(k)) , a(kb(k)) ),anew(k)) ,
>      .              max( a(ka(k)) , a(kb(k)) ) )
>         endif     !  (n_bs.eq.4)
>         if(n_bs.eq.5.or.n_bs.eq.7)then ! directional SY limiter for all levels u
>           if((a(kaa(k))-a(ka(k)))*(a(kb(k))-a(kbb(k))).ge.0.)then
>             anew(k)=min( max(min( a(ka(k)) , a(kb(k)) ),anew(k)) ,
>      .                max( a(ka(k)) , a(kb(k)) ) )
>           endif
>         endif     !  (n_bs.eq.5.or.n_bs.eq.7)
>         if(n_bs.eq.8)then ! directional NCS limiter for all levels u
>           if( (a(kaa(k))-a(ka(k)))*(a(kaaa(k))-a(kaa(k))).lt.0.
>      .    .or.(a(kb(k))-a(kbb(k)))*(a(kbb(k))-a(kbbb(k))).lt.0.
>      .    .or.(a(kaa(k))-a(ka(k)))*(a(kb(k))-a(kbb(k))).ge.0.)then
>             anew(k)=min( max(min( a(ka(k)) , a(kb(k)) ),anew(k)) ,
>      .                max( a(ka(k)) , a(kb(k)) ) )
>           endif
>         endif     !  (n_bs.eq.8)
>        enddo  ! k loop
>        if(n_bs.eq.1)then   ! limiter for top level u
>          anew(kl)=min( max(min(a(kl-1),a(kl)),anew(kl)) ,
>      .                     max(a(kl-1),a(kl)) )
>        endif     !  (n_bs.eq.1)
>        if(n_bs.eq.6.or.n_bs.eq.7)then   ! columnwise integral constraint
>          sumsrc=0.
>          delpos=0.
>          delneg=0.
>          do k=1,kl
>           sumsrc=sumsrc-a(k)*(up(k)-up(k-1))*dsig(k)   ! use all -dsig
>           delpos=delpos+max(0., -dsig(k)*(anew(k)-a(k)) )
>           delneg=delneg+min(0., -dsig(k)*(anew(k)-a(k)) )
>          enddo
>          eps=(sumsrc-delpos-delneg)/max(1.e-6,delpos-delneg)
>          do k=1,kl
>           anew(k)=a(k) +(1.+eps)*max(0.,anew(k)-a(k))
>      .                 +(1.-eps)*min(0.,anew(k)-a(k))
>          enddo
>        endif     !  (n_bs.eq.6.or.n_bs.eq.7)
>        do k=1,kl
>         vout(iq,k)=anew(k)
>        enddo
> 
> 880    continue   !       if(nvad.eq.10)go to 880     ! in vadvl_w
> 
>        if(mspec.eq.1)then   ! advect qg and gases after preliminary step
> c        qg
>          if(nqq.eq.2)then
>            do k=1,kl
>             qg(iq,k)=qg(iq,k)*k**3
>            enddo     ! k loop
>          endif       ! (nqq.eq.2)
>          if(nqq.eq.3)then
>            do k=1,kl
> !           qg(iq,1)=cbrt(qg(iq,1))
>             qg(iq,1)=qg(iq,1)**(1./3.)
>            enddo     ! k loop
>          endif       ! (nqq.eq.3)
>          if(nqq.eq.4)then
>            do k=1,kl
>             qg(iq,k)=sqrt(sqrt(qg(iq,k)))
>            enddo     ! k loop
>          endif       ! (nqq.eq.4)
>          do k=1,kl
>           a(k)=qg(iq,k)
>          enddo     ! k loop
>          ap(0)=a(1)
>          do k=1,kl-1
>           if(nhalf.eq.0)ap(k)=.5*( a(k+1)+a(k) -up(k)*(a(k+1)-a(k)) )
>           if(nhalf.eq.1)ap(k)=ratha(k)*a(k+1)+rathb(k)*a(k)
>      .                       -.5*up(k)*(a(k+1)-a(k))
>           if(nqq.eq.5)ap(k)=rathqa(k)*a(k+1)+rathqb(k)*a(k)
>      .                       -.5*up(k)*(a(k+1)-a(k))
>           if(n_bs.eq.3)ap(k)=
>      .          min( max(min(a(k),a(k+1)) , ap(k)) , max(a(k),a(k+1)) )
>          enddo     ! k loop
> c        ap(kl)=0.
>          ap(kl)=a(kl)    ! from Mon  09-29-1997
>          if(ntop.eq.1)ap(kl)=ap(kl-1)
>          if(ntop.ge.2)ap(kl)=0.
>          do k=1,kl
>           if(ngadd.eq.0)tincr= -uav(k)*(ap(k)-ap(k-1))             ! simple L_W
>           if(ngadd.eq.1)tincr= -uav(k)*( (1.+agadd(k))*(ap(k)-ap(k-1))   ! Gadd
>      .                                  -agadd(k)*(ap(k+1)-ap(k-2))/3. ) ! Gadd
>         anew(k)=a(k)+tincr
>         if(n_bs.eq.2)then   ! limiter for all levels
>           kp=min(k+1,kl)
>           km=max(k-1,1)
>           anew(k)=min( max(min(a(km),a(k),a(kp)),anew(k)) ,
>      .              max(a(km),a(k),a(kp)) )
>         endif     !  (n_bs.eq.2)
>         if(n_bs.eq.4)then   ! directional limiter for all levels u
>           anew(k)=min( max(min( a(ka(k)) , a(kb(k)) ),anew(k)) ,
>      .              max( a(ka(k)) , a(kb(k)) ) )
>         endif     !  (n_bs.eq.4)
>         if(n_bs.eq.5.or.n_bs.eq.7)then ! directional SY limiter for all levels u
>           if((a(kaa(k))-a(ka(k)))*(a(kb(k))-a(kbb(k))).ge.0.)then
>             anew(k)=min( max(min( a(ka(k)) , a(kb(k)) ),anew(k)) ,
>      .                max( a(ka(k)) , a(kb(k)) ) )
>           endif
>         endif     !  (n_bs.eq.5.or.n_bs.eq.7)
>         if(n_bs.eq.8)then ! directional NCS limiter for all levels u
>           if( (a(kaa(k))-a(ka(k)))*(a(kaaa(k))-a(kaa(k))).lt.0.
>      .    .or.(a(kb(k))-a(kbb(k)))*(a(kbb(k))-a(kbbb(k))).lt.0.
>      .    .or.(a(kaa(k))-a(ka(k)))*(a(kb(k))-a(kbb(k))).ge.0.)then
>             anew(k)=min( max(min( a(ka(k)) , a(kb(k)) ),anew(k)) ,
>      .                max( a(ka(k)) , a(kb(k)) ) )
>           endif
>         endif     !  (n_bs.eq.8)
>        enddo  ! k loop
>        if(n_bs.eq.1)then   ! limiter for top level u
>          anew(kl)=min( max(min(a(kl-1),a(kl)),anew(kl)) ,
>      .                     max(a(kl-1),a(kl)) )
>        endif     !  (n_bs.eq.1)
>        if(n_bs.eq.6.or.n_bs.eq.7)then   ! columnwise integral constraint
>          sumsrc=0.
>          delpos=0.
>          delneg=0.
>          do k=1,kl
>           sumsrc=sumsrc-a(k)*(up(k)-up(k-1))*dsig(k)   ! use all -dsig
>           delpos=delpos+max(0., -dsig(k)*(anew(k)-a(k)) )
>           delneg=delneg+min(0., -dsig(k)*(anew(k)-a(k)) )
>          enddo
>          eps=(sumsrc-delpos-delneg)/max(1.e-6,delpos-delneg)
>          do k=1,kl
>           anew(k)=a(k) +(1.+eps)*max(0.,anew(k)-a(k))
>      .                 +(1.-eps)*min(0.,anew(k)-a(k))
>          enddo
>        endif     !  (n_bs.eq.6.or.n_bs.eq.7)
>        do k=1,kl
>         qg(iq,k)=anew(k)
>        enddo
>          if(nqq.eq.2)then
>            do k=1,kl
>             qg(iq,k)=qg(iq,k)*
>      .          (k+1.5*uav(k))/(k*k*k*(k-1.5*uav(k)))
>            enddo     ! k loop
>          endif       ! (nqq.eq.2)
>          if(nqq.eq.3)then
>            do k=1,kl
>             qg(iq,k)=qg(iq,k)**3
>            enddo     ! k loop
>          endif       ! (nqq.eq.3)
>          if(nqq.eq.4)then
>            do k=1,kl
>             qg(iq,k)=qg(iq,k)**4
>            enddo     ! k loop
>          endif       ! (nqq.eq.4)
>          if(ilt.gt.1)stop 'vadvbott'
>        endif       ! if(mspec.eq.1)
> 
>       if(nvad.eq.9)go to 889
> 
> c      t
> 885     do k=1,kl
>         a(k)=tin(iq,k)
>        enddo     ! k loop
>        ap(0)=a(1)
>        do k=1,kl-1
>         if(nhalf.eq.0)ap(k)=.5*( a(k+1)+a(k) -up(k)*(a(k+1)-a(k)) )
>         if(nhalf.eq.1)ap(k)=ratha(k)*a(k+1)+rathb(k)*a(k)
>      .                       -.5*up(k)*(a(k+1)-a(k))
>         if(n_bs.eq.3)ap(k)=
>      .          min( max(min(a(k),a(k+1)) , ap(k)) , max(a(k),a(k+1)) )
>        enddo     ! k loop
>        ap(kl)=a(kl)
>        if(ntop.eq.1)ap(kl)=ap(kl-1)
>        do k=1,kl
>         if(ngadd.eq.0)tincr= -uav(k)*(ap(k)-ap(k-1))              ! simple L_W
>         if(ngadd.eq.1)tincr= -uav(k)*( (1.+agadd(k))*(ap(k)-ap(k-1))    ! Gadd
>      .                                -agadd(k)*(ap(k+1)-ap(k-2))/3. )  ! Gadd
>         anew(k)=a(k)+tincr
>         if(n_bs.eq.2)then   ! limiter for all levels
>           kp=min(k+1,kl)
>           km=max(k-1,1)
>           anew(k)=min( max(min(a(km),a(k),a(kp)),anew(k)) ,
>      .              max(a(km),a(k),a(kp)) )
>         endif     !  (n_bs.eq.2)
>         if(n_bs.eq.4)then   ! directional limiter for all levels u
>           anew(k)=min( max(min( a(ka(k)) , a(kb(k)) ),anew(k)) ,
>      .              max( a(ka(k)) , a(kb(k)) ) )
>         endif     !  (n_bs.eq.4)
>         if(n_bs.eq.5.or.n_bs.eq.7)then ! directional SY limiter for all levels u
>           if((a(kaa(k))-a(ka(k)))*(a(kb(k))-a(kbb(k))).ge.0.)then
>             anew(k)=min( max(min( a(ka(k)) , a(kb(k)) ),anew(k)) ,
>      .                max( a(ka(k)) , a(kb(k)) ) )
>           endif
>         endif     !  (n_bs.eq.5.or.n_bs.eq.7)
>         if(n_bs.eq.8)then ! directional NCS limiter for all levels u
>           if( (a(kaa(k))-a(ka(k)))*(a(kaaa(k))-a(kaa(k))).lt.0.
>      .    .or.(a(kb(k))-a(kbb(k)))*(a(kbb(k))-a(kbbb(k))).lt.0.
>      .    .or.(a(kaa(k))-a(ka(k)))*(a(kb(k))-a(kbb(k))).ge.0.)then
>             anew(k)=min( max(min( a(ka(k)) , a(kb(k)) ),anew(k)) ,
>      .                max( a(ka(k)) , a(kb(k)) ) )
>           endif
>         endif     !  (n_bs.eq.8)
>        enddo  ! k loop
>        if(ntop.eq.4)then   ! Matsuno-like formula for top level t
>          atemp   =a(kl)-.5*up(kl-1)*(a(kl)-a(kl-1))
>          anew(kl)=a(kl)-.5*up(kl-1)*(atemp-anew(kl-1))
>        endif     !  (ntop.eq.4)
>        if(ntop.eq.5)then   ! simple 'flux' formula for top level t
>          anew(kl)=a(kl)-.5*up(kl-1)*(a(kl)-a(kl-1))
>        endif     !  (ntop.eq.5)
>        if(n_bs.eq.1)then   ! limiter for top level u
>          anew(kl)=min( max(min(a(kl-1),a(kl)),anew(kl)) ,
>      .                     max(a(kl-1),a(kl)) )
>        endif     !  (n_bs.eq.1)
>        if(n_bs.eq.6.or.n_bs.eq.7)then   ! columnwise integral constraint
>          sumsrc=0.
>          delpos=0.
>          delneg=0.
>          do k=1,kl
>           sumsrc=sumsrc-a(k)*(up(k)-up(k-1))*dsig(k)   ! use all -dsig
>           delpos=delpos+max(0., -dsig(k)*(anew(k)-a(k)) )
>           delneg=delneg+min(0., -dsig(k)*(anew(k)-a(k)) )
>          enddo
>          eps=(sumsrc-delpos-delneg)/max(1.e-6,delpos-delneg)
>          do k=1,kl
>           anew(k)=a(k) +(1.+eps)*max(0.,anew(k)-a(k))
>      .                 +(1.-eps)*min(0.,anew(k)-a(k))
>          enddo
>        endif     !  (n_bs.eq.6.or.n_bs.eq.7)
>        do k=1,kl
>         tout(iq,k)=anew(k)
>        enddo
> 
> 889    continue  ! nvad.eq.9
>       enddo    ! iq loop
=====================================
 
vertmix.f
=====================================
1,2c1,2
<       subroutine vertmix
< !     inputs & outputs: t,u,v,qg
---
>       subroutine vertmix(nvsplit)  ! version for globpea and DARLAM 
> !     outputs: tn,un,vn,qg
7a8
>       parameter (kscmom=1)     ! 0 default, 1 turns off Tiedtke momentum
16d16
<       include 'liqwpar.h'  ! ifullw, qfg, qlg
27c27
<       common/savuv/savu(ifull,kl),savv(ifull,kl)
---
> c     following common block passes uav, vav from sflux to vertmix
29,31c29,32
<      .             thebas(ifull,kl),cu(ifull,kl),dum3(ifull,kl)
<       common/work3b/uav(ifull,kl),vav(ifull,kl)   
< !     n.b. uav & vav also used by pbldif; all of work3 used by tracervmix
---
>      .             uav(ifull,kl),vav(ifull,kl)
> !     N.B. uav & vav also used by pbldif; all of work3 used by tracervmix
>       real cu(ifull,kl)
>       equivalence (cu,vav)
35,36c36,37
<      . ,dz(ifull),dzr(ifull),fm(ifull),fh(ifull),ri(ifull),sqmxl(ifull)
<      . ,x(ifull),zhv(ifull),theeb(ifull),dum2(ifull,6)
---
>      . ,dz(ifull),dzr(ifull),fm(ifull),fh(ifull),ri(ifull)
>      . ,sqmxl(ifull),x(ifull),zhv(ifull),thee1(ifull),dum2(ifull,6)
39d39
<       real alfqq_l(kl),alfqq_s(kl),alfqq1_l(kl),alfqq1_s(kl)
54,56c54,56
< c arithmetic statement functions to replace call to establ.
< c t is temp in kelvin, which should lie between 123.16 and 343.16;
< c tdiff is difference between t and 123.16, subject to 0 <= tdiff <= 220
---
> c Arithmetic statement functions to replace call to establ.
> c T is temp in Kelvin, which should lie between 123.16 and 343.16;
> c TDIFF is difference between T and 123.16, subject to 0 <= TDIFF <= 220
84,87c84,89
<       tmnht(:,1)=(t(:,2)*rlogs1-t(:,1)*rlogs2+
<      .           (t(:,1)-t(:,2))*rlogh1)*rlog12
< !     n.b. an approximate zh is quite adequate for this routine
<       zh(:,1)=t(:,1)*delh(1)
---
>       do iq=1,ifull
>        tmnht(iq,1)=(t(iq,2)*rlogs1-t(iq,1)*rlogs2+
>      .               (t(iq,1)-t(iq,2))*rlogh1)*rlog12
> c      n.b. an approximate zh is quite adequate for this routine
>        zh(iq,1)=t(iq,1)*delh(1)
>       enddo      ! iq loop
93a96,99
>       do kq=1,ijk-ifull  ! top level set separately to 0 for gt & guv
>        rkh(kq,1)=0.
>        rkm(kq,1)=0.
>       enddo
101,105d106
<       do k=1,kl-1  ! top level set separately to 0 for gt & guv
<        rkh(:,k)=0.
<        rkm(:,k)=0.
<        delthet(:,k)=rhs(:,k+1)-rhs(:,k)  ! rhs is theta here
<       enddo      !  k loop
107c108
<       if(ktau.eq.1)then
---
>       If(ktau.eq.1)then
117,121c118,130
<         print *,'For shallow convection:'
<         print *,'ksc,kscbase,ksctop,kscsea ',
<      .           ksc,kscbase,ksctop,kscsea
< 	 write (6,"(' sigkscb,sigksct,tied_con,tied_over,tied_rh:',
<      .       5f8.3)")sigkscb,sigksct,tied_con,tied_over,tied_rh
---
>         if(ksc.gt.0)then  
>           ksc=ksctop
>           print *,'Tiedtke shallow convection'
>           print *,'ksc,kscbase,ksctop,kscmom,kscsea ',
>      .             ksc,kscbase,ksctop,kscmom,kscsea
> 	   write (6,"(' sigkscb,sigksct,tied_con,tied_over,tied_rh:',
>      .        5f8.3)")sigkscb,sigksct,tied_con,tied_over,tied_rh
>         endif
>         if(ksc.lt.0)then
>           ksc=-ksctop
>           print *,'Geleyn shallow conv: ksc,sigkscb,sigksct,kscbase: ',
>      .                                  ksc,sigkscb,sigksct,kscbase
>         endif
125,132d133
<         do k=1,kl
<          alfqq_s(k)=alfsea
<          alfqq_l(k)=alflnd
<          alfqq_s(k)=1./tied_rh
<          alfqq_l(k)=1./tied_rh
<          alfqq1_s(k)=0.
<          alfqq1_l(k)=0.
<         enddo     ! k loop
136c137,138
<       if(ksc.eq.99)then
---
> !     main difference from bmrc's is mixing of momentum and range of levels
>       if(ksc.gt.0)then
138c140
<         theeb(iq)=prcpv(kscbase)*t(iq,kscbase)*
---
>         thee1(iq)=prcpv(kscbase)*t(iq,kscbase)*
143c145
<           do k=kscbase+1,ksctop
---
>           do k=kscbase+1,ksc
147c149
<      .                           /(t(iq,k) - .5*hlcp*qs(iq,k))
---
>      .                            /(t(iq,k) - .5*hlcp*qs(iq,k))
149c151,152
<      .       and.thee.lt.theeb(iq))then               !  default tied_rh=.75
---
>      .       and.thee.lt.thee1(iq))then               !  default tied_rh=.75
>               if(kscmom.eq.0)rkm(iq,k-1)=tied_con !  m**2/sec  6., originally 10.
150a154
>               if(kscmom.eq.0)rkm(iq,k)=tied_over  !  m**2/sec
154,156c158,160
<           enddo   ! end of k=kscbase+1,ksctop loop
<         else      !  i.e. Tiedtke original scheme over land and sea
<           do k=kscbase+1,ksctop  ! typically kscbase=3 & ksctop=6
---
>           enddo   ! end of k=kscbase+1,ksc loop
>         else      !  i.e. original scheme over land and sea
>           do k=kscbase+1,ksc  ! typically kscbase=3 & ksc=6
159c163
<      .                           /(t(iq,k) - .5*hlcp*qs(iq,k))
---
>      .                            /(t(iq,k) - .5*hlcp*qs(iq,k))
161c165,166
<      .       and.thee.lt.theeb(iq))then               !  default tied_rh=.75
---
>      .       and.thee.lt.thee1(iq))then               !  default tied_rh=.75
>               if(kscmom.eq.0)rkm(iq,k-1)=tied_con !  m**2/sec  6., originally 10.
162a168
>               if(kscmom.eq.0)rkm(iq,k)=tied_over  !  m**2/sec
164,166c170,172
< 		if(ntest.eq.3.and.k.eq.ksctop)then
< 		  print *,'ktau,iq,theeb,thee,delthee ',
<      .       		    ktau,iq,theeb(iq),thee,theeb(iq)-thee
---
> 		if(ntest.eq.3.and.k.eq.ksc)then
> 		  print *,'ktau,iq,thee1,thee,delthee ',
>      .       		    ktau,iq,thee1(iq),thee,thee1(iq)-thee
170c176
<           enddo   ! end of k=kscbase+1,ksctop loop
---
>           enddo   ! end of k=kscbase+1,ksc loop
172c178
<       endif       ! (ksc.eq.99)
---
>       endif       ! (ksc.gt.0)
175,207c181,185
< c     ************ Tiedtke_jlm shallow convection 97 ***************
<       if(ksc.eq.97)then
<         do k=kscbase,ksctop-1
<          do iq=1,ifull
< 	   qbas=min(qg(iq,k)/tied_rh,qs(iq,k))
< c         thebas(iq,k)=t(iq,k)+hlcp*qbas  + hght
<           thebas(iq,k)=prcpv(k)*t(iq,k)*(t(iq,k) + .5*hlcp*qbas)
<      .                                 /(t(iq,k) - .5*hlcp*qbas)
<          enddo  ! iq loop
<         enddo   ! k loop
< 	 theeb(:)=thebas(:,kscbase)
<         do k=kscbase+1,ksctop+1
<          do iq=1,ifull
<           thee=prcpv(k)*t(iq,k)*(t(iq,k) + .5*hlcp*qs(iq,k))
<      .                         /(t(iq,k) - .5*hlcp*qs(iq,k))
<           if(theeb(iq).gt.thee)then
<             rkh(iq,k-1)=tied_con                !  m**2/sec  6., originally 10.
<             rkh(iq,k)=tied_over                 !  m**2/sec
< 	   else
< 	     theeb(iq)=thebas(iq,k) ! ready for next k in k-loop
<           endif
<          enddo  ! iq loop
<         enddo   ! k loop
< !       suppress pseudo-deep convection	 
<         do k=kscbase,ksctop
<          do iq=1,ifull
<           if(rkh(iq,ksctop).gt..9*tied_con)then  ! to allow for tied_over=0.
<             rkh(iq,k)=0.
<           endif
<          enddo  ! iq loop
<         enddo   ! k loop
<       endif     ! (ksc.eq.97)
< c     *********** end of Tiedtke_jlm shallow convection 97 *************
---
>       do k=1,kl-1
>        do iq=1,ifull
>         delthet(iq,k)=rhs(iq,k+1)-rhs(iq,k)  ! rhs is theta here
>        enddo     ! iq loop
>       enddo      !  k loop
210,211c188,190
<       if(ksc.eq.-99)then
<         do k=kscbase,ksctop    ! new usage of ksc thu  02-17-2000
---
>       if(ksc.lt.0)then
> !       do k=-ksc,kl/2
>         do k=kscbase,-ksc    ! new usage of ksc Thu  02-17-2000
217c196
<       endif     ! (ksc.eq.-99)
---
>       endif     ! (ksc.lt.0)
220,245d198
<       if(ntest.ne.0.or.diag)then
<         iq=idjd
<         print *,'for shallow convection in vertmix '
< 	 print *,'kbsav,ktsav,theeb: ',kbsav(iq),ktsav(iq),theeb(iq)
<         write (6,"('rh   ',19f7.2/(8x,19f7.2))") 
<      .             (100.*qg(idjd,k)/qs(idjd,k),k=1,kl)
<         write (6,"('qs   ',19f7.3/(8x,19f7.3))") 
<      .             (1000.*qs(idjd,k),k=1,kl)
<         write (6,"('qg   ',19f7.3/(8x,19f7.3))") 
<      .             (1000.*qg(idjd,k),k=1,kl)
<         write (6,"('qbas ',19f7.3/(8x,19f7.3))") 
<      .             (1000.*qg(idjd,k)/tied_rh,k=1,kl)
<         write (6,"('t    ',19f7.2/(8x,19f7.2))") 
<      .             (t(idjd,k),k=1,kl)
<         write (6,"('thebas',19f7.2/(8x,19f7.2))") 
<      .             (thebas(iq,k),k=1,kl)
< c        write (6,"('hs',19f7.2/(8x,19f7.2))") 
< c     .             (t(idjd,k)+hlcp*qs(idjd,k),k=1,kl)
<         write (6,"('thee',19f7.2/(8x,19f7.2))") 
<      .            (prcpv(k)*t(iq,k)*(t(iq,k) + .5*hlcp*qs(iq,k))
<      .                             /(t(iq,k) - .5*hlcp*qs(iq,k)),k=1,kl)
<       endif
< 
< !     following now defined in vertmix (don't need to pass from sflux)
<       uav(:,:)=av_vmod*u(:,:)+(1.-av_vmod)*savu(:,:)   ! 3D
<       vav(:,:)=av_vmod*v(:,:)+(1.-av_vmod)*savv(:,:)   ! 3D
253c206
<      .                   +(vav(iq,k+1)-vav(iq,k))**2 )
---
>      .                     +(vav(iq,k+1)-vav(iq,k))**2 )
262c215
< c       fm and fh denote f(Louis style)*dvmod
---
> c       fm and fh denote f(louis style)*dvmod
280a234,283
>        if(nvmix.eq.2)then
> c        code as used in early mesoscale version
>          ric=0.067 *(dz(ifull/2)*100.)**0.25
>          do iq=1,ifull
>           sqmxl(iq)=(vkar3*zh(iq,k)/(1.+vkar3*zh(iq,k)/amxlsq))**2
>           dvmod(iq)=max(dvmod(iq),1.e-4*dz(iq))
>           ri(iq)=x(iq)/dvmod(iq)**2
>           if(ri(iq).lt. 0.)then  ! unstable case
> c           first do momentum
>             denma=dvmod(iq)+cm*( 2.*bprm*sqmxl(iq)*
>      .                            sqrt(-x(iq)*csq(iq)) )
>             fm(iq)=dvmod(iq)-(2.*bprmj *x(iq))/denma
> c           now heat
>             denha=dvmod(iq)+ch*( 2.*bprm*sqmxl(iq)*
>      .                            sqrt(-x(iq)*csq(iq)) )
>             fh(iq)=( dvmod(iq)-(2.*bprm *x(iq))/denha  )/.74
>           else                     ! stable case
> c           linearly interpolate to calculate f for stable case; f lies between
> c           1 (ri = 0) and 0 (r = ric);  multiply by dvmod to give fm and fh
>             fm(iq)=max( dvmod(iq)*(ric-ri(iq))/ric , 0. )
>             fh(iq)=fm(iq)/.74    !vertmixb didn't have the .74
>           endif
>          enddo   ! iq loop
>        endif
> 
>        if(nvmix.eq.3)then
> c        newish code, vkar4 & also with ric=.5 typically
>          ric=.5
>          do iq=1,ifull
>           sqmxl(iq)=(vkar4*zh(iq,k)/(1.+vkar4*zh(iq,k)/amxlsq))**2
>           dvmod(iq)=max( dvmod(iq) , 1. )
>           ri(iq)=x(iq)/dvmod(iq)**2
>           if(ri(iq).lt. 0.)then  ! unstable case
> c           first do momentum
>             denma=dvmod(iq)+cmj*( 2.*bprmj*sqmxl(iq)*
>      .                            sqrt(-x(iq)*csq(iq)) )
>             fm(iq)=dvmod(iq)-(2.*bprmj *x(iq))/denma
> c           now heat
>             denha=dvmod(iq)+chj*( 2.*bprmj*sqmxl(iq)*
>      .                            sqrt(-x(iq)*csq(iq)) )
>             fh(iq)=dvmod(iq)-(2.*bprmj *x(iq))/denha
>           else                     ! stable case
> c           linearly interpolate to calculate f for stable case; f lies between
> c           1 (ri = 0) and 0 (r = ric);  multiply by dvmod to give fm and fh
>             fm(iq)=max( dvmod(iq)*(ric-ri(iq))/ric , 0. )
>             fh(iq)=fm(iq)
>           endif
>          enddo   ! iq loop
>        endif
> 
297c300
< c           the following is the original Louis stable formula
---
> c           The following is the original Louis stable formula
305c308
< c      nonlocal scheme usually applied to temperature and moisture, not momentum
---
> c      nonlocal scheme usually applied to temperature and moisture, NOT momentum
349,350c352,353
< !       n.b. *** pbldif partially updates qg and theta (t done during trim)	 
< !       ncar info is returned in rkm_nl and rkh_nl arrays
---
> !       N.B. *** pbldif partially updates qg and theta (T done during trim)	 
> !       NCAR info is returned in rkm_nl and rkh_nl arrays
376,377c379,386
<       guv(:,kl)=0.
<       gt(:,kl)=0.
---
>       do iq=1,ifull
>        guv(iq,kl)=0.
>        gt(iq,kl)=0.
>       enddo      ! iq loop
>       if(diag.or.ntest.ge.1)then
>         print *,'before trim '
>         write (6,"('tn*dt',19f7.3/(8x,19f7.3))") (dt*tn(idjd,k),k=1,kl) 
>       endif
386a396
>         call printa('tn  ',tn(1,nlv),ktau,nlv,ia,ib,ja,jb,0.,100.*dt)
409,410c419,430
<       at(:,1)=0.
<       rhs(:,1)=rhs(:,1)-(conflux/cp)*fg(:)/ps(:)
---
>       if(ntsur.ne.6)then   !  Tue  09-28-1993
>         do iq=1,ifull
>          at(iq,1)=0.
>          rhs(iq,1)=rhs(iq,1)-(conflux/cp)*fg(iq)/ps(iq)
>         enddo    ! iq loop
>       else       ! for ntsur=6 using cdtq
>         do iq=1,ifull       ! N.B. cdtq array not set up in sflux nowadays
>          cdt=fg(iq)*r*tss(iq)/((tss(iq)-rhs(iq,1))*cp*ps(iq))
>          at(iq,1) =cdt*condrag/tss(iq)
>          rhs(iq,1)=rhs(iq,1)-at(iq,1)*tss(iq)
>         enddo    ! iq loop
>       endif
419c439
< *cdir nodep
---
> *        vdir nodep
424c444
<       else       ! i.e. npanels=0   darlam
---
>       else       ! i.e. npanels=0   DARLAM
431c451
< *cdir nodep
---
> *        vdir nodep
446,448c466,483
<         do iq=1,ifull
<          t(iq,k)=rhs(iq,k)/sigkap(k)
<         enddo  ! iq loop
---
>        if(npanels.gt.0)then
>         if(nvsplit.ne.0)then  ! splitting u,v,T in vertmix
>           do iq=1,ifull
>            t(iq,k)=rhs(iq,k)/sigkap(k)
>           enddo  ! iq loop
>         else
>           do iq=1,ifull
>            tn(iq,k)=tn(iq,k)+(rhs(iq,k)/sigkap(k)-t(iq,k))/dt ! tendency
>           enddo  ! iq loop
>         endif    ! (nvsplit.ne.0)
>        else         ! npanels=0  DARLAM
>          do j=2,jl
>           do i=2,il
> 	    iq=i+(j-1)*il
>            t(iq,k)=rhs(iq,k)/sigkap(k)
>           enddo
>          enddo
>        endif     ! (npanels.gt.0)
449a485,486
>       if(ntest.eq.2)print *,'after trim t1,t2,tn1,tn2,rhs1 ',
>      .        t(idjd,1),t(idjd,2),tn(idjd,1),tn(idjd,2),rhs(idjd,1)
458,459c495,513
<       rhs(:,:)=qg(:,:)
<       rhs(:,1)=rhs(:,1)-(conflux/hl)*eg(:)/ps(:)
---
>       do kq=1,ijk
>        rhs(kq,1)=qg(kq,1)
>       enddo      ! kq loop
>       if(ntsur.ne.6)then   !  Tue  09-28-1993
>         do iq=1,ifull
>          rhs(iq,1)=rhs(iq,1)-(conflux/hl)*eg(iq)/ps(iq)
>         enddo    ! iq loop
>       else       ! for ntsur=6 using cdtq
> !       do iq=1,ifull             ! DARLAM has this possibility for ntsur=6
> !        at(iq,1)=dw(iq)*at(iq,1)
> !       enddo
>         do iq=1,ifull
>          es=establ(tss(iq))
>          rsts=.622*es/(ps(iq)-es)
>          cdq=eg(iq)*r*tss(iq)/((rsts-qg(iq,1))*2.5e6*ps(iq))
>          at(iq,1) =cdq*condrag/rsts
>          rhs(iq,1)=rhs(iq,1)-at(iq,1)*rsts
>          enddo   ! iq loop
>       endif      ! (ntsur.ne.6)
462,486c516,526
<       qg(:,:)=rhs(:,:)
< 
<       if(ifullw.eq.ifull)then
< c       now do qfg
< 	 do k=1,kl
< 	  do iq=1,ifullw
<           rhs(iq,k)=qfg(iq,k)
<          enddo
<         enddo
<         call trim(at,ct,rhs,0)    ! for qfg
< 	 do k=1,kl
< 	  do iq=1,ifullw
<           qfg(iq,k)=rhs(iq,k)
<          enddo
<         enddo
< c       now do qlg
< 	 do k=1,kl
< 	  do iq=1,ifullw
<           rhs(iq,k)=qlg(iq,k)
<          enddo
<         enddo
<         call trim(at,ct,rhs,0)    ! for qlg
< 	 do k=1,kl
< 	  do iq=1,ifullw
<           qlg(iq,k)=rhs(iq,k)
---
>       if(npanels.gt.0)then
>         do kq=1,ijk
>          qg(kq,1)=rhs(kq,1)
>         enddo    ! kq loop
>       else
>         do k=1,kl
>          do j=2,jl
>           do i=2,il
> 	    iq=i+(j-1)*il
>            qg(iq,k)=rhs(iq,k)
>           enddo
488,489c528,529
<         enddo
<       endif    ! (ifullw.eq.ifull)
---
>         enddo    ! k loop
>       endif      !  (npanels.gt.0)
492c532
<       if(ngas.gt.0)call tracervmix( at, ct, rhs )
---
>       if(ngas.gt.0)call TracerVMix( at, ct, rhs )
495,505c535,565
<       au(:,1)=cduv(:)*condrag/tss(:)   ! globpea
<       do k=2,kl
<        do iq=1,ifull
<         au(iq,k) =-guv(iq,k-1)/dsig(k)  ! globpea
<        enddo   ! iq loop
<       enddo    !  k loop
<       do k=1,kl
<        do iq=1,ifull
<         cu(iq,k) =-guv(iq,k)/dsig(k)    ! globpea
<        enddo   ! iq loop
<       enddo    !  k loop
---
>       if(npanels.gt.0)then
>         do iq=1,ifull
>          au(iq,1)=cduv(iq)*condrag/tss(iq)   ! globpea
>         enddo    ! iq loop
>         do k=2,kl
>          do iq=1,ifull
>           au(iq,k) =-guv(iq,k-1)/dsig(k)  ! globpea
>          enddo   ! iq loop
>         enddo    !  k loop
>         do k=1,kl
> *        vdir nodep
>          do iq=1,ifull
>           cu(iq,k) =-guv(iq,k)/dsig(k)    ! globpea
>          enddo   ! iq loop
>         enddo    !  k loop
>       else       ! i.e. npanels=0   DARLAM
>         do iq=1,ifull-1   !xxx   following for u
>          au(iq,1) =.5*(cduv(iq)+cduv(iq+1))*condrag/tss(iq)
>         enddo    ! iq loop
>         do k=2,kl
>          do iq=1,ifull-1   !xxx   following for u
>           au(iq,k) =-.5*(guv(iq,k-1)+guv(iq+1,k-1))/dsig(k) ! DARLAM
>          enddo   ! iq loop
>         enddo    !  k loop
>         do k=1,kl
> *        vdir nodep
>          do iq=1,ifull-1   !      following for u
>           cu(iq,k) =-.5*(guv(iq,k)+guv(iq+1,k))/dsig(k)    ! DARLAM
>          enddo   ! iq loop
>         enddo    !  k loop
>       endif      !  (npanels.gt.0) .. else ..
512c572,574
<       rhs(:,:)=u(:,:)
---
>       do kq=1,ijk
>        rhs(kq,1)=u(kq,1)
>       enddo      ! kq loop
514c576,610
<       u(:,:)=rhs(:,:)
---
>       if(npanels.gt.0)then
>         if(nvsplit.ne.0)then  ! splitting u,v,T in vertmix
>           do kq=1,ijk
>            u(kq,1)=rhs(kq,1)
>            un(kq,1)=0.
>           enddo  ! kq loop
>         else
>           do kq=1,ijk
>            un(kq,1)=(rhs(kq,1)-u(kq,1))/dt  ! to give tendency
>           enddo  ! kq loop
>         endif    ! (nvsplit.ne.0)
>       else       ! npanels=0 for DARLAM
> c       DARLAM usually does split for u & v
>         do k=1,kl
>          do j=3,jl-1
>           do i=2,il-1
> 	    iq=i+(j-1)*il
>            u(iq,k)=rhs(iq,k)
>           enddo
>          enddo
>         enddo   ! k loop
>         do iq=1,ifull-il    !   following for DARLAM v
>          au(iq,1) =.5*(cduv(iq)+cduv(iq+il))*condrag/tss(iq)
>         enddo   ! iq loop
>         do k=2,kl
>          do iq=1,ifull-il   !   following for DARLAM v
>           au(iq,k) =-.5*(guv(iq,k-1)+guv(iq+il,k-1))/dsig(k)
>          enddo  ! iq loop
>         enddo   !  k loop
>         do k=1,kl
>          do iq=1,ifull-il   !   following for DARLAM v
>           cu(iq,k) =-.5*(guv(iq,k)+guv(iq+il,k))/dsig(k)
>          enddo  ! iq loop
>         enddo   !  k loop
>       endif     ! (npanels.gt.0)
520c616,618
<       rhs(:,:)=v(:,:)
---
>       do kq=1,ijk
>        rhs(kq,1)=v(kq,1)
>       enddo  ! kq loop
522c620,640
<       v(:,:)=rhs(:,:)
---
>       if(npanels.gt.0)then
>         if(nvsplit.ne.0)then  ! splitting u,v,T in vertmix
>           do kq=1,ijk
>            v(kq,1)=rhs(kq,1)
>            vn(kq,1)=0.
>           enddo  ! kq loop
>         else
>           do kq=1,ijk
>            vn(kq,1)=(rhs(kq,1)-v(kq,1))/dt  ! to give tendency
>           enddo  ! kq loop
>         endif    ! (nvsplit.ne.0)
>       else  ! for DARLAM
>         do k=1,kl
>          do j=2,jl-1
>           do i=3,il-1
> 	    iq=i+(j-1)*il
>            v(iq,k)=rhs(iq,k)
>           enddo
>          enddo
>         enddo   !  k loop
>       endif  ! (npanels.gt.0)
529a648,650
>         write (6,"('thee',19f7.2/(8x,19f7.2))") 
>      .        (prcpv(k)*t(idjd,k)*(t(idjd,k) + .5*hlcp*qs(idjd,k))
>      .                   /(t(idjd,k) - .5*hlcp*qs(idjd,k)),k=1,kl)
531a653,655
>         write (6,"('tn*dt',19f7.3/(8x,19f7.3))") (dt*tn(idjd,k),k=1,kl) 
>         write (6,"('un*dt',19f7.3/(8x,19f7.3))") (dt*un(idjd,k),k=1,kl) 
>         write (6,"('vn*dt',19f7.3/(8x,19f7.3))") (dt*vn(idjd,k),k=1,kl) 
542c666
<       subroutine tracervmix( at, ct, updtr )
---
>       Subroutine TracerVMix( at, ct, updTr )
553,554c677,678
<       common/work3/vmixarrs(ifull,kl,3),trsrc(ifull,kl),spare(ifull,kl)
<       real updtr(ifull,kl),at(ifull,kl),ct(ifull,kl)
---
>       common/work3/vmixarrs(ifull,kl,3),trsrc(ifull,kl)
>       real updTr(ifull,kl),at(ifull,kl),ct(ifull,kl)
556,557c680,681
<       co2fact=1000.*trfact*fair_molm/fc_molm
<       o2fact=1000.*trfact*fair_molm/fo2_molm
---
>       CO2fact=1000.*trfact*fAIR_MolM/fC_MolM
>       O2fact=1000.*trfact*fAIR_MolM/fO2_MolM
559,560c683,684
< c     rates of change of mixing ratio m from the surface are computed
< c     using the expression
---
> c     Rates of change of mixing ratio m from the surface are computed
> C     using the expression
562c686
< c     where phi is a mass flux of air with same number of molecules as in
---
> c     where phi is a mass flux of AIR with SAME number of molecules as in
570,573c694,696
<       if( iradon.ne.0 ) then
< 	 k2=max(2*iradon,1)/max(iradon,1)  ! 1 for iradon=0	 
<         if(ntest.eq.1)print *,'ktau,iradon,trfact ',ktau,iradon,trfact
<         call radonsflux
---
>       if( iRADON.NE.0 ) then
>         if(ntest.eq.1)print *,'ktau,iRADON,trfact ',ktau,iRADON,trfact
>         call RadonSFlux
575,576c698,699
<      .  tr(idjd,1,max(1,iradon)),tr(idjd,k2,max(1,iradon)),trsrc(idjd,1)
<         call radonvmix (updtr, trfact )
---
>      .         tr(idjd,1,iradon),tr(idjd,2,iradon),trsrc(idjd,1)
>         call RadonVMix (updTr, trfact )
578,579c701,702
<      .  tr(idjd,1,max(1,iradon)),tr(idjd,k2,max(1,iradon)),updtr(idjd,1)
<         call trimcopy(at,ct,updtr,iradon) ! same as trim but holds bdy vals
---
>      .          tr(idjd,1,iradon),tr(idjd,2,iradon),updtr(idjd,1)
>         call trimcopy(at,ct,updTr,iRADON) ! same as trim but holds bdy vals
581c704
<      .  tr(idjd,1,max(1,iradon)),tr(idjd,k2,max(1,iradon)),updtr(idjd,1)
---
>      .          tr(idjd,1,iradon),tr(idjd,2,iradon),updtr(idjd,1)
584,587c707,709
<       if( ico2.ne.0 ) then
< 	 k2=max(2*ico2,1)/max(ico2,1)  ! 1 for ico2=0
<         if(ntest.eq.1)print *,'ktau,ico2,co2fact ',ktau,ico2,co2fact
<         call co2sflux
---
>       if( iCO2.NE.0 ) then
>         if(ntest.eq.1)print *,'ktau,iCO2,CO2fact ',ktau,iCO2,CO2fact
>         call CO2SFlux
589,590c711,712
<      .      tr(idjd,1,max(1,ico2)),tr(idjd,k2,max(1,ico2)),trsrc(idjd,1)
<         call co2vmix(updtr, co2fact )
---
>      .             tr(idjd,1,ico2),tr(idjd,2,ico2),trsrc(idjd,1)
>         call CO2vmix(updTr, CO2fact )
592,593c714,715
<      .      tr(idjd,1,max(1,ico2)),tr(idjd,k2,max(1,ico2)),updtr(idjd,1)
<         call trimcopy(at,ct,updtr,ico2)
---
>      .             tr(idjd,1,ico2),tr(idjd,2,ico2),updtr(idjd,1)
>         call trimcopy(at,ct,updTr,iCO2)
595c717
<      .      tr(idjd,1,max(1,ico2)),tr(idjd,k2,max(1,ico2)),updtr(idjd,1)
---
>      .             tr(idjd,1,ico2),tr(idjd,2,ico2),updtr(idjd,1)
597,599c719,721
< c         print *,'can mel sources ',ktau,trsrc(46,57,1),trsrc(39,52,1)
< c         print *,'can mel conc lev1 ',ktau,tr(46,57,1,2),tr(39,52,1,2)
<           call printa('co2 ',tr(1,1,k2),ktau,1,ia,ib,ja,jb,357.,1.)
---
> c         print *,'Can Mel sources ',ktau,trsrc(46,57,1),trsrc(39,52,1)
> c         print *,'Can Mel conc lev1 ',ktau,tr(46,57,1,2),tr(39,52,1,2)
>           call printa('co2 ',tr(1,1,2),ktau,1,ia,ib,ja,jb,357.,1.)
604,606c726,728
<       if( io2.ne.0 ) then
<         call o2vmix(updtr, o2fact )
<         call trimcopy(at,ct,updtr,io2)
---
>       if( iO2.NE.0 ) then
>         call O2vmix(updTr, O2fact )
>         call trimcopy(at,ct,updTr,iO2)
609,614c731,736
<       if(iso2.gt.0) then
<         so2fact(1) = trfact
<         do i=2,nso2lev
<           so2fact(i) = g * dt / dsig(i)
<         end do  !   i=1,nso2lev
<         if( iso2.gt.0.and.nso2lev.lt.1 )stop 'vertmix: nso2lev.lt.1'
---
>       if(iSO2.gt.0) then
>         SO2fact(1) = trfact
>         do i=2,nSO2lev
>           SO2fact(i) = g * dt / dsig(i)
>         end do  !   i=1,nSO2lev
>         if( iSO2.gt.0.and.nSO2lev.lt.1 )stop 'vertmix: nSO2lev.lt.1'
617,623c739,759
<       if( iso2.ne.0 ) then
<        call so2sflux
<        call so2vmix(updtr )
<        call trimcopy(at,ct,updtr,iso2)
< 	do k=1,klt
< 	 do iq=1,ilt*jlt
<          tr(iq,k,max(1,iso2))=max(-100.,min(tr(iq,k,max(1,iso2)),9000.))
---
>       if( iSO2.NE.0 ) then
>         call SO2SFlux
>         call SO2vmix(updTr )
>         call trimcopy(at,ct,updTr,iSO2)
>         if(ntest.eq.1)then
>           smax=-10.e10
>           smin=10.e10
>           do kq=1,ijk
>            if( tr(kq,1,iSO2).gt.smax) then
>              smax= tr(kq,1,iSO2)
>              imm=kq
>            endif
>            if( tr(kq,1,iSO2).lt.smin) then
>              smin= tr(kq,1,iSO2)
>              immm=kq
>            endif
>           enddo
>           print *,'max,min',smax,imm,smin,immm
>         endif  ! (ntest.eq.1)
>         do kq=1,ijk
>          tr(kq,1,iSO2) = max(-100.,min(tr(kq,1,iSO2),9000.))
625d760
<        enddo
628,631c763,766
<       if( iso4.ne.0 ) then
< *       call so4sflux
< *       call so4vmix( updtr )
< *       call trimcopy(at,ct,updtr,iso4)
---
>       if( iSO4.NE.0 ) then
> *       call SO4SFlux
> *       call SO4vmix( updTr )
> *       call trimcopy(at,ct,updTr,iSO4)
634,637c769,772
<       if( ich4.ne.0 ) then
< *       call ch4sflux
< *       call ch4vmix( updtr )
< *       call trimcopy(at,ct,updtr,ich4)
---
>       if( iCH4.NE.0 ) then
> *       call CH4SFlux
> *       call CH4vmix( updTr )
> *       call trimcopy(at,ct,updTr,iCH4)
640,643c775,778
<       if( io2.ne.0 ) then
< *       call o2sflux
< *       call o2vmix(updtr )
< *       call trimcopy(at,ct,updtr,io2)
---
>       if( iO2.NE.0 ) then
> *       call O2SFlux
> *       call O2vmix(updTr )
> *       call trimcopy(at,ct,updTr,iO2)
648,649c783,784
< c     not needed, except for setting darlam boundary values?
<       subroutine trimcopy(at,ct,updtr,itracer)
---
> c     not needed, except for setting DARLAM boundary values?
>       Subroutine TrimCopy(at,ct,updTr,iTracer)
654,658c789,793
<       real updtr(ifull,kl),at(ifull,kl),ct(ifull,kl)
<       call trim(at,ct,updtr,0)
<       do k=1,klt
<          do iq=1,ilt*jlt   !  alter all values for c-c
<           tr(iq,k,itracer)=updtr(iq,k)
---
>       real updTr(ifull,kl),at(ifull,kl),ct(ifull,kl)
>       call trim(at,ct,updTr,0)
>       do k=1,kl
>          do iq=1,ifull   !  alter all values for C-C
>           tr(iq,k,iTracer)=updTr(iq,k)
=====================================
 
vertmixx.f
=====================================
=====================================
 
